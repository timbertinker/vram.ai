"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [934],
  {
    4250: function (t, e, i) {
      let r, s, n, a, o;
      i.d(e, {
        $TI: function () {
          return InstancedInterleavedBuffer;
        },
        $V: function () {
          return Spherical;
        },
        $YQ: function () {
          return DepthTexture;
        },
        $wi: function () {
          return tm;
        },
        A5E: function () {
          return rH;
        },
        ACn: function () {
          return RenderTarget;
        },
        AXT: function () {
          return CubicBezierCurve;
        },
        B02: function () {
          return m;
        },
        BFQ: function () {
          return t7;
        },
        BG$: function () {
          return ed;
        },
        BVF: function () {
          return X;
        },
        BVQ: function () {
          return CapsuleGeometry;
        },
        BbS: function () {
          return Audio;
        },
        Bf4: function () {
          return tv;
        },
        Bgp: function () {
          return td;
        },
        BtG: function () {
          return CubeTexture;
        },
        CJI: function () {
          return Triangle;
        },
        CaW: function () {
          return er;
        },
        CdI: function () {
          return th;
        },
        CtA: function () {
          return t2;
        },
        CtF: function () {
          return ng;
        },
        Cy: function () {
          return q;
        },
        D1R: function () {
          return tL;
        },
        D67: function () {
          return io;
        },
        D9w: function () {
          return t1;
        },
        Djp: function () {
          return ec;
        },
        DqL: function () {
          return CompressedTextureLoader;
        },
        DvJ: function () {
          return BoxGeometry;
        },
        E2K: function () {
          return t5;
        },
        EB7: function () {
          return CompressedTexture;
        },
        EJi: function () {
          return MeshPhysicalMaterial;
        },
        EcG: function () {
          return getByteLength;
        },
        EoG: function () {
          return to;
        },
        F1y: function () {
          return ih;
        },
        F5G: function () {
          return t4;
        },
        F5T: function () {
          return Material;
        },
        FDw: function () {
          return tk;
        },
        FE5: function () {
          return TorusKnotGeometry;
        },
        FIo: function () {
          return RawShaderMaterial;
        },
        FM8: function () {
          return Vector2;
        },
        FT0: function () {
          return LineDashedMaterial;
        },
        FUD: function () {
          return ex;
        },
        FvO: function () {
          return SpotLightHelper;
        },
        GG6: function () {
          return ey;
        },
        GQ: function () {
          return Box3Helper;
        },
        GUF: function () {
          return eY;
        },
        GVz: function () {
          return WebGLArrayRenderTarget;
        },
        Gih: function () {
          return eg;
        },
        Gql: function () {
          return ObjectLoader;
        },
        H$k: function () {
          return TetrahedronGeometry;
        },
        H7L: function () {
          return arrayNeedsUint32;
        },
        HTd: function () {
          return tC;
        },
        HdW: function () {
          return eA;
        },
        HgB: function () {
          return iM;
        },
        HkE: function () {
          return ArrayCamera;
        },
        Hmr: function () {
          return AudioContext;
        },
        Hw6: function () {
          return Source;
        },
        Hy8: function () {
          return U;
        },
        Hyl: function () {
          return Curve;
        },
        I3e: function () {
          return iV;
        },
        IEO: function () {
          return DataTexture;
        },
        IFH: function () {
          return eO;
        },
        IKL: function () {
          return MeshToonMaterial;
        },
        ILR: function () {
          return t9;
        },
        IOt: function () {
          return eq;
        },
        Ilk: function () {
          return Color;
        },
        Ir4: function () {
          return iv;
        },
        JCZ: function () {
          return iC;
        },
        JOQ: function () {
          return Plane;
        },
        JQ4: function () {
          return tD;
        },
        JUT: function () {
          return Data3DTexture;
        },
        JWc: function () {
          return ix;
        },
        Jjb: function () {
          return id;
        },
        KI_: function () {
          return eX;
        },
        Kgo: function () {
          return DodecahedronGeometry;
        },
        KhW: function () {
          return E;
        },
        Kj0: function () {
          return Mesh;
        },
        Kz5: function () {
          return tN;
        },
        L5s: function () {
          return InstancedBufferGeometry;
        },
        LBq: function () {
          return Cylindrical;
        },
        LSk: function () {
          return i_;
        },
        LY2: function () {
          return tu;
        },
        LgZ: function () {
          return N;
        },
        LsT: function () {
          return tF;
        },
        Ltg: function () {
          return Vector4;
        },
        Lun: function () {
          return MeshDistanceMaterial;
        },
        M$G: function () {
          return il;
        },
        M5h: function () {
          return C;
        },
        M6v: function () {
          return ti;
        },
        M8C: function () {
          return iP;
        },
        Mig: function () {
          return AmbientLight;
        },
        MyG: function () {
          return e7;
        },
        N$j: function () {
          return Bone;
        },
        N4l: function () {
          return T;
        },
        NDo: function () {
          return tn;
        },
        NKc: function () {
          return Z;
        },
        NMF: function () {
          return eP;
        },
        NYV: function () {
          return ep;
        },
        Ns1: function () {
          return tr;
        },
        NwF: function () {
          return StringKeyframeTrack;
        },
        Ny0: function () {
          return EllipseCurve;
        },
        O4K: function () {
          return warnOnce;
        },
        O5A: function () {
          return createCanvasElement;
        },
        O78: function () {
          return ic;
        },
        O7d: function () {
          return ExtrudeGeometry;
        },
        OAl: function () {
          return ie;
        },
        ORg: function () {
          return tp;
        },
        OTo: function () {
          return tJ;
        },
        Oau: function () {
          return aa;
        },
        OdW: function () {
          return Skeleton;
        },
        OoA: function () {
          return tA;
        },
        Ox3: function () {
          return DirectionalLight;
        },
        PA7: function () {
          return eJ;
        },
        PMe: function () {
          return SpotLight;
        },
        Pa4: function () {
          return Vector3;
        },
        PeU: function () {
          return c;
        },
        Pnf: function () {
          return ek;
        },
        PpQ: function () {
          return ImageUtils;
        },
        PzK: function () {
          return eH;
        },
        QM0: function () {
          return ib;
        },
        QO2: function () {
          return eS;
        },
        QRU: function () {
          return ImageBitmapLoader;
        },
        QZ1: function () {
          return ig;
        },
        Qey: function () {
          return probeAsync;
        },
        QmN: function () {
          return u;
        },
        Qpg: function () {
          return HemisphereLightHelper;
        },
        R2R: function () {
          return ColorKeyframeTrack;
        },
        RNb: function () {
          return Int8BufferAttribute;
        },
        ROQ: function () {
          return CanvasTexture;
        },
        RSm: function () {
          return MeshNormalMaterial;
        },
        Rhp: function () {
          return mergeUniforms;
        },
        Rki: function () {
          return CameraHelper;
        },
        RlZ: function () {
          return W;
        },
        RsA: function () {
          return l;
        },
        RvT: function () {
          return ii;
        },
        S2y: function () {
          return p;
        },
        S3k: function () {
          return ImageLoader;
        },
        S9g: function () {
          return Layers;
        },
        SJI: function () {
          return AudioListener;
        },
        SPe: function () {
          return InstancedMesh;
        },
        SUY: function () {
          return Clock;
        },
        Se2: function () {
          return Y;
        },
        Sm8: function () {
          return L;
        },
        SvJ: function () {
          return ev;
        },
        Syv: function () {
          return eV;
        },
        T6w: function () {
          return ip;
        },
        T95: function () {
          return tE;
        },
        TOt: function () {
          return EdgesGeometry;
        },
        TUj: function () {
          return Box2;
        },
        TUv: function () {
          return SkinnedMesh;
        },
        T_1: function () {
          return ShapePath;
        },
        T_J: function () {
          return e5;
        },
        T__: function () {
          return ArcCurve;
        },
        T_f: function () {
          return RectAreaLight;
        },
        TlE: function () {
          return BufferAttribute;
        },
        Tme: function () {
          return Object3D;
        },
        Tn7: function () {
          return ShadowMaterial;
        },
        TyD: function () {
          return t_;
        },
        U7: function () {
          return LineCurve3;
        },
        UCm: function () {
          return tZ;
        },
        USm: function () {
          return Euler;
        },
        UY4: function () {
          return PointsMaterial;
        },
        UZH: function () {
          return h;
        },
        UcC: function () {
          return Matrix2;
        },
        Uk6: function () {
          return WireframeGeometry;
        },
        UlW: function () {
          return eD;
        },
        Uol: function () {
          return PolyhedronGeometry;
        },
        V1s: function () {
          return Camera;
        },
        VLJ: function () {
          return GridHelper;
        },
        VYz: function () {
          return PositionalAudio;
        },
        Vdb: function () {
          return G;
        },
        Vkp: function () {
          return Matrix3;
        },
        VzW: function () {
          return tU;
        },
        W2J: function () {
          return im;
        },
        WMw: function () {
          return _;
        },
        WTc: function () {
          return Uint8BufferAttribute;
        },
        WXh: function () {
          return TubeGeometry;
        },
        Wbm: function () {
          return I;
        },
        Wid: function () {
          return MeshStandardMaterial;
        },
        Wl3: function () {
          return b;
        },
        Wpd: function () {
          return j;
        },
        Wqd: function () {
          return CurvePath;
        },
        WwZ: function () {
          return eN;
        },
        Wzm: function () {
          return FramebufferTexture;
        },
        Xaj: function () {
          return z;
        },
        Xcj: function () {
          return AnimationMixer;
        },
        XvJ: function () {
          return TorusGeometry;
        },
        Y8D: function () {
          return tY;
        },
        YBo: function () {
          return MeshLambertMaterial;
        },
        YGz: function () {
          return tl;
        },
        YKA: function () {
          return eB;
        },
        YLQ: function () {
          return tT;
        },
        YT8: function () {
          return CatmullRomCurve3;
        },
        Ywn: function () {
          return WebGL3DRenderTarget;
        },
        Z6B: function () {
          return iS;
        },
        ZAu: function () {
          return Group;
        },
        ZQ6: function () {
          return QuadraticBezierCurve;
        },
        ZRs: function () {
          return e3;
        },
        ZTh: function () {
          return eT;
        },
        ZXd: function () {
          return Controls;
        },
        ZZA: function () {
          return ny;
        },
        Z_g: function () {
          return CompressedArrayTexture;
        },
        Zen: function () {
          return iu;
        },
        Zp0: function () {
          return LoaderUtils;
        },
        Zr5: function () {
          return Q;
        },
        ZzF: function () {
          return Box3;
        },
        Zzh: function () {
          return Line3;
        },
        _12: function () {
          return PlaneGeometry;
        },
        _7h: function () {
          return eW;
        },
        _AM: function () {
          return et;
        },
        _C8: function () {
          return Interpolant;
        },
        _Li: function () {
          return M;
        },
        _MY: function () {
          return f;
        },
        _RZ: function () {
          return iT;
        },
        _YM: function () {
          return BooleanKeyframeTrack;
        },
        _YX: function () {
          return SkeletonHelper;
        },
        _am: function () {
          return CubeCamera;
        },
        _fP: function () {
          return Quaternion;
        },
        _iA: function () {
          return y;
        },
        _kC: function () {
          return Light;
        },
        _lf: function () {
          return eR;
        },
        _sL: function () {
          return eE;
        },
        _wr: function () {
          return H;
        },
        a$l: function () {
          return Float32BufferAttribute;
        },
        aCh: function () {
          return eZ;
        },
        aH4: function () {
          return tz;
        },
        aLr: function () {
          return Sphere;
        },
        aNw: function () {
          return Loader;
        },
        aVm: function () {
          return Int16BufferAttribute;
        },
        ad5: function () {
          return e$;
        },
        aq0: function () {
          return PolarGridHelper;
        },
        av9: function () {
          return t3;
        },
        bBp: function () {
          return AnimationAction;
        },
        bGH: function () {
          return B;
        },
        b_z: function () {
          return ConeGeometry;
        },
        bdR: function () {
          return A;
        },
        blk: function () {
          return LineLoop;
        },
        bnF: function () {
          return Shape;
        },
        brP: function () {
          return t$;
        },
        bsb: function () {
          return eM;
        },
        c8b: function () {
          return k;
        },
        cBI: function () {
          return DirectionalLightHelper;
        },
        cBK: function () {
          return CubeTextureLoader;
        },
        cJO: function () {
          return IcosahedronGeometry;
        },
        cLu: function () {
          return tG;
        },
        cPb: function () {
          return PerspectiveCamera;
        },
        cRx: function () {
          return tQ;
        },
        cU9: function () {
          return DiscreteInterpolant;
        },
        cac: function () {
          return createElementNS;
        },
        ce8: function () {
          return e1;
        },
        cek: function () {
          return PointLight;
        },
        cum: function () {
          return is;
        },
        dSO: function () {
          return tb;
        },
        dUE: function () {
          return NumberKeyframeTrack;
        },
        dYG: function () {
          return CubicInterpolant;
        },
        dZ3: function () {
          return tc;
        },
        dd2: function () {
          return WebGLRenderTarget;
        },
        dj0: function () {
          return iy;
        },
        dpR: function () {
          return TextureLoader;
        },
        dwf: function () {
          return cloneUniforms;
        },
        dwk: function () {
          return x;
        },
        e62: function () {
          return Float16BufferAttribute;
        },
        eD: function () {
          return $;
        },
        eMJ: function () {
          return e6;
        },
        eaV: function () {
          return ei;
        },
        ehD: function () {
          return w;
        },
        ejS: function () {
          return LineSegments;
        },
        ekQ: function () {
          return ea;
        },
        epp: function () {
          return iF;
        },
        f2y: function () {
          return ew;
        },
        fHI: function () {
          return CylinderGeometry;
        },
        fO1: function () {
          return VideoTexture;
        },
        fQA: function () {
          return BoxHelper;
        },
        fSK: function () {
          return D;
        },
        fY$: function () {
          return tg;
        },
        fto: function () {
          return es;
        },
        g8_: function () {
          return tM;
        },
        gH0: function () {
          return UniformsGroup;
        },
        gSk: function () {
          return eF;
        },
        g_z: function () {
          return LineCurve;
        },
        ghN: function () {
          return R;
        },
        gi4: function () {
          return eu;
        },
        gti: function () {
          return SplineCurve;
        },
        hEm: function () {
          return t0;
        },
        hH6: function () {
          return FileLoader;
        },
        iAb: function () {
          return tO;
        },
        iDF: function () {
          return ShapeUtils;
        },
        iKG: function () {
          return OrthographicCamera;
        },
        iLg: function () {
          return QuaternionKeyframeTrack;
        },
        iMs: function () {
          return Raycaster;
        },
        iUV: function () {
          return PropertyBinding;
        },
        iWC: function () {
          return O;
        },
        iWj: function () {
          return Frustum;
        },
        iiP: function () {
          return eb;
        },
        irR: function () {
          return tW;
        },
        j17: function () {
          return eK;
        },
        j4z: function () {
          return ir;
        },
        j87: function () {
          return Int32BufferAttribute;
        },
        jAl: function () {
          return ez;
        },
        jFi: function () {
          return S;
        },
        jZA: function () {
          return eh;
        },
        jes: function () {
          return J;
        },
        jfJ: function () {
          return e2;
        },
        jwo: function () {
          return e9;
        },
        jyi: function () {
          return Sprite;
        },
        jyz: function () {
          return ShaderMaterial;
        },
        k0A: function () {
          return tj;
        },
        k74: function () {
          return F;
        },
        kB5: function () {
          return InterleavedBufferAttribute;
        },
        kFz: function () {
          return WebGLMultipleRenderTargets;
        },
        kaV: function () {
          return MeshMatcapMaterial;
        },
        kqm: function () {
          return AudioAnalyser;
        },
        ksN: function () {
          return tt;
        },
        l0P: function () {
          return en;
        },
        l6D: function () {
          return eQ;
        },
        l8J: function () {
          return iw;
        },
        lCJ: function () {
          return Uint32BufferAttribute;
        },
        lDi: function () {
          return SphericalHarmonics3;
        },
        lGU: function () {
          return eC;
        },
        lLk: function () {
          return LoadingManager;
        },
        lRF: function () {
          return MeshDepthMaterial;
        },
        lRj: function () {
          return tP;
        },
        lb7: function () {
          return InstancedBufferAttribute;
        },
        lfu: function () {
          return LinearInterpolant;
        },
        lk7: function () {
          return LightProbe;
        },
        m7l: function () {
          return AnimationClip;
        },
        mSO: function () {
          return ej;
        },
        mTL: function () {
          return AudioLoader;
        },
        mXe: function () {
          return QuadraticBezierCurve3;
        },
        msZ: function () {
          return tf;
        },
        mzJ: function () {
          return AnimationObjectGroup;
        },
        nls: function () {
          return LineBasicMaterial;
        },
        ntZ: function () {
          return g;
        },
        o8S: function () {
          return RingGeometry;
        },
        oAp: function () {
          return WebGLCubeRenderTarget;
        },
        oDz: function () {
          return getUnlitUniformColorSpace;
        },
        oa8: function () {
          return ShapeGeometry;
        },
        oqc: function () {
          return e4;
        },
        p3g: function () {
          return DataArrayTexture;
        },
        p7y: function () {
          return LatheGeometry;
        },
        pBf: function () {
          return EventDispatcher;
        },
        pIN: function () {
          return eL;
        },
        pKu: function () {
          return ef;
        },
        pQR: function () {
          return OctahedronGeometry;
        },
        ptH: function () {
          return eo;
        },
        qVC: function () {
          return CompressedCubeTexture;
        },
        qhX: function () {
          return ts;
        },
        qkB: function () {
          return tK;
        },
        qlB: function () {
          return Uint16BufferAttribute;
        },
        qyh: function () {
          return tV;
        },
        rAo: function () {
          return Uint8ClampedBufferAttribute;
        },
        rDY: function () {
          return si;
        },
        rOj: function () {
          return V;
        },
        r_: function () {
          return P;
        },
        rpg: function () {
          return tw;
        },
        s4_: function () {
          return BufferGeometryLoader;
        },
        sYA: function () {
          return AnimationLoader;
        },
        tEQ: function () {
          return nx;
        },
        tGC: function () {
          return ArrowHelper;
        },
        tJx: function () {
          return PlaneHelper;
        },
        tNt: function () {
          return toNormalizedProjectionMatrix;
        },
        tQZ: function () {
          return tq;
        },
        tUh: function () {
          return KeyframeTrack;
        },
        tf: function () {
          return PropertyMixer;
        },
        tm_: function () {
          return d;
        },
        u37: function () {
          return StereoCamera;
        },
        u7G: function () {
          return MaterialLoader;
        },
        u9r: function () {
          return BufferGeometry;
        },
        uEv: function () {
          return eI;
        },
        uL9: function () {
          return ta;
        },
        uWy: function () {
          return tS;
        },
        uXU: function () {
          return e8;
        },
        v3W: function () {
          return t8;
        },
        v9Y: function () {
          return iA;
        },
        vBJ: function () {
          return MeshBasicMaterial;
        },
        vCF: function () {
          return K;
        },
        vCx: function () {
          return ee;
        },
        vZf: function () {
          return tB;
        },
        vmT: function () {
          return HemisphereLight;
        },
        vpT: function () {
          return InterleavedBuffer;
        },
        vuL: function () {
          return e_;
        },
        vxC: function () {
          return tx;
        },
        w$m: function () {
          return te;
        },
        wJv: function () {
          return tH;
        },
        wem: function () {
          return tI;
        },
        wk1: function () {
          return tX;
        },
        woe: function () {
          return Points;
        },
        wuA: function () {
          return t6;
        },
        x12: function () {
          return Line;
        },
        x5V: function () {
          return e0;
        },
        xEZ: function () {
          return Texture;
        },
        xG9: function () {
          return PointLightHelper;
        },
        xJs: function () {
          return em;
        },
        xWb: function () {
          return Uniform;
        },
        xeV: function () {
          return SpriteMaterial;
        },
        xfE: function () {
          return ty;
        },
        xo$: function () {
          return SphereGeometry;
        },
        xoQ: function () {
          return ia;
        },
        xoR: function () {
          return MeshPhongMaterial;
        },
        xsS: function () {
          return Scene;
        },
        y$t: function () {
          return Path;
        },
        y2t: function () {
          return el;
        },
        y8_: function () {
          return AxesHelper;
        },
        yC1: function () {
          return VectorKeyframeTrack;
        },
        yGw: function () {
          return Matrix4;
        },
        yHo: function () {
          return toReversedProjectionMatrix;
        },
        ybr: function () {
          return Fog;
        },
        yj7: function () {
          return CubicBezierCurve3;
        },
        ylh: function () {
          return GLBufferAttribute;
        },
        yo9: function () {
          return FogExp2;
        },
        yt0: function () {
          return it;
        },
        ywz: function () {
          return tR;
        },
        yxD: function () {
          return DataTextureLoader;
        },
        z$h: function () {
          return eU;
        },
        z81: function () {
          return eG;
        },
        z8B: function () {
          return LOD;
        },
        zHn: function () {
          return Ray;
        },
        zbs: function () {
          return QuaternionLinearInterpolant;
        },
        zf8: function () {
          return CircleGeometry;
        },
        zwN: function () {
          return BatchedMesh;
        },
      });
      /**
       * @license
       * Copyright 2010-2024 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ let h = "171",
        l = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
        u = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        c = 0,
        d = 1,
        p = 2,
        m = 3,
        f = 0,
        y = 1,
        g = 2,
        x = 3,
        b = 0,
        M = 1,
        w = 2,
        S = 0,
        A = 1,
        _ = 2,
        T = 3,
        C = 4,
        z = 5,
        B = 100,
        I = 101,
        V = 102,
        P = 103,
        L = 104,
        k = 200,
        R = 201,
        E = 202,
        O = 203,
        F = 204,
        N = 205,
        D = 206,
        U = 207,
        G = 208,
        j = 209,
        W = 210,
        H = 211,
        q = 212,
        J = 213,
        Z = 214,
        X = 0,
        Y = 1,
        Q = 2,
        K = 3,
        $ = 4,
        tt = 5,
        te = 6,
        ti = 7,
        tr = 0,
        ts = 1,
        tn = 2,
        ta = 0,
        to = 1,
        th = 2,
        tl = 3,
        tu = 4,
        tc = 5,
        td = 6,
        tp = 7,
        tm = "attached",
        tf = "detached",
        ty = 300,
        tg = 301,
        tx = 302,
        tb = 303,
        tv = 304,
        tM = 306,
        tw = 1e3,
        tS = 1001,
        tA = 1002,
        t_ = 1003,
        tT = 1004,
        tC = 1004,
        tz = 1005,
        tB = 1005,
        tI = 1006,
        tV = 1007,
        tP = 1007,
        tL = 1008,
        tk = 1008,
        tR = 1009,
        tE = 1010,
        tO = 1011,
        tF = 1012,
        tN = 1013,
        tD = 1014,
        tU = 1015,
        tG = 1016,
        tj = 1017,
        tW = 1018,
        tH = 1020,
        tq = 35902,
        tJ = 1021,
        tZ = 1022,
        tX = 1023,
        tY = 1024,
        tQ = 1025,
        tK = 1026,
        t$ = 1027,
        t0 = 1028,
        t1 = 1029,
        t3 = 1030,
        t2 = 1031,
        t4 = 1032,
        t5 = 1033,
        t6 = 33776,
        t7 = 33777,
        t8 = 33778,
        t9 = 33779,
        et = 35840,
        ee = 35841,
        ei = 35842,
        er = 35843,
        es = 36196,
        en = 37492,
        ea = 37496,
        eo = 37808,
        eh = 37809,
        el = 37810,
        eu = 37811,
        ec = 37812,
        ed = 37813,
        ep = 37814,
        em = 37815,
        ef = 37816,
        ey = 37817,
        eg = 37818,
        ex = 37819,
        eb = 37820,
        ev = 37821,
        eM = 36492,
        ew = 36494,
        eS = 36495,
        eA = 36283,
        e_ = 36284,
        eT = 36285,
        eC = 36286,
        ez = 2200,
        eB = 2201,
        eI = 2202,
        eV = 2300,
        eP = 2301,
        eL = 2302,
        ek = 2400,
        eR = 2401,
        eE = 2402,
        eO = 2500,
        eF = 2501,
        eN = 0,
        eD = 1,
        eU = 2,
        eG = 3200,
        ej = 3201,
        eW = 3202,
        eH = 3203,
        eq = 0,
        eJ = 1,
        eZ = "",
        eX = "srgb",
        eY = "srgb-linear",
        eQ = "linear",
        eK = "srgb",
        e$ = 0,
        e0 = 7680,
        e1 = 7681,
        e3 = 7682,
        e2 = 7683,
        e4 = 34055,
        e5 = 34056,
        e6 = 5386,
        e7 = 512,
        e8 = 513,
        e9 = 514,
        it = 515,
        ie = 516,
        ii = 517,
        ir = 518,
        is = 519,
        ia = 512,
        io = 513,
        ih = 514,
        il = 515,
        iu = 516,
        ic = 517,
        id = 518,
        ip = 519,
        im = 35044,
        iy = 35048,
        ig = 35040,
        ix = 35045,
        ib = 35049,
        iv = 35041,
        iM = 35046,
        iw = 35050,
        iS = 35042,
        iA = "100",
        i_ = "300 es",
        iT = 2e3,
        iC = 2001;
      let EventDispatcher = class EventDispatcher {
        addEventListener(t, e) {
          void 0 === this._listeners && (this._listeners = {});
          let i = this._listeners;
          void 0 === i[t] && (i[t] = []),
            -1 === i[t].indexOf(e) && i[t].push(e);
        }
        hasEventListener(t, e) {
          if (void 0 === this._listeners) return !1;
          let i = this._listeners;
          return void 0 !== i[t] && -1 !== i[t].indexOf(e);
        }
        removeEventListener(t, e) {
          if (void 0 === this._listeners) return;
          let i = this._listeners,
            r = i[t];
          if (void 0 !== r) {
            let t = r.indexOf(e);
            -1 !== t && r.splice(t, 1);
          }
        }
        dispatchEvent(t) {
          if (void 0 === this._listeners) return;
          let e = this._listeners,
            i = e[t.type];
          if (void 0 !== i) {
            t.target = this;
            let e = i.slice(0);
            for (let i = 0, r = e.length; i < r; i++) e[i].call(this, t);
            t.target = null;
          }
        }
      };
      let iz = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ],
        iB = 1234567,
        iI = Math.PI / 180,
        iV = 180 / Math.PI;
      function generateUUID() {
        let t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0,
          r = (4294967295 * Math.random()) | 0,
          s =
            iz[255 & t] +
            iz[(t >> 8) & 255] +
            iz[(t >> 16) & 255] +
            iz[(t >> 24) & 255] +
            "-" +
            iz[255 & e] +
            iz[(e >> 8) & 255] +
            "-" +
            iz[((e >> 16) & 15) | 64] +
            iz[(e >> 24) & 255] +
            "-" +
            iz[(63 & i) | 128] +
            iz[(i >> 8) & 255] +
            "-" +
            iz[(i >> 16) & 255] +
            iz[(i >> 24) & 255] +
            iz[255 & r] +
            iz[(r >> 8) & 255] +
            iz[(r >> 16) & 255] +
            iz[(r >> 24) & 255];
        return s.toLowerCase();
      }
      function clamp(t, e, i) {
        return Math.max(e, Math.min(i, t));
      }
      function euclideanModulo(t, e) {
        return ((t % e) + e) % e;
      }
      function lerp(t, e, i) {
        return (1 - i) * t + i * e;
      }
      function denormalize(t, e) {
        switch (e.constructor) {
          case Float32Array:
            return t;
          case Uint32Array:
            return t / 4294967295;
          case Uint16Array:
            return t / 65535;
          case Uint8Array:
            return t / 255;
          case Int32Array:
            return Math.max(t / 2147483647, -1);
          case Int16Array:
            return Math.max(t / 32767, -1);
          case Int8Array:
            return Math.max(t / 127, -1);
          default:
            throw Error("Invalid component type.");
        }
      }
      function normalize(t, e) {
        switch (e.constructor) {
          case Float32Array:
            return t;
          case Uint32Array:
            return Math.round(4294967295 * t);
          case Uint16Array:
            return Math.round(65535 * t);
          case Uint8Array:
            return Math.round(255 * t);
          case Int32Array:
            return Math.round(2147483647 * t);
          case Int16Array:
            return Math.round(32767 * t);
          case Int8Array:
            return Math.round(127 * t);
          default:
            throw Error("Invalid component type.");
        }
      }
      let iP = {
        DEG2RAD: iI,
        RAD2DEG: iV,
        generateUUID: generateUUID,
        clamp: clamp,
        euclideanModulo: euclideanModulo,
        mapLinear: function (t, e, i, r, s) {
          return r + ((t - e) * (s - r)) / (i - e);
        },
        inverseLerp: function (t, e, i) {
          return t !== e ? (i - t) / (e - t) : 0;
        },
        lerp: lerp,
        damp: function (t, e, i, r) {
          return lerp(t, e, 1 - Math.exp(-i * r));
        },
        pingpong: function (t, e = 1) {
          return e - Math.abs(euclideanModulo(t, 2 * e) - e);
        },
        smoothstep: function (t, e, i) {
          return t <= e
            ? 0
            : t >= i
            ? 1
            : (t = (t - e) / (i - e)) * t * (3 - 2 * t);
        },
        smootherstep: function (t, e, i) {
          return t <= e
            ? 0
            : t >= i
            ? 1
            : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10);
        },
        randInt: function (t, e) {
          return t + Math.floor(Math.random() * (e - t + 1));
        },
        randFloat: function (t, e) {
          return t + Math.random() * (e - t);
        },
        randFloatSpread: function (t) {
          return t * (0.5 - Math.random());
        },
        seededRandom: function (t) {
          void 0 !== t && (iB = t);
          let e = (iB += 1831565813);
          return (
            (e = Math.imul(e ^ (e >>> 15), 1 | e)),
            (((e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)) ^ (e >>> 14)) >>> 0) /
              4294967296
          );
        },
        degToRad: function (t) {
          return t * iI;
        },
        radToDeg: function (t) {
          return t * iV;
        },
        isPowerOfTwo: function (t) {
          return (t & (t - 1)) == 0 && 0 !== t;
        },
        ceilPowerOfTwo: function (t) {
          return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        },
        floorPowerOfTwo: function (t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        },
        setQuaternionFromProperEuler: function (t, e, i, r, s) {
          let n = Math.cos,
            a = Math.sin,
            o = n(i / 2),
            h = a(i / 2),
            l = n((e + r) / 2),
            u = a((e + r) / 2),
            c = n((e - r) / 2),
            d = a((e - r) / 2),
            p = n((r - e) / 2),
            m = a((r - e) / 2);
          switch (s) {
            case "XYX":
              t.set(o * u, h * c, h * d, o * l);
              break;
            case "YZY":
              t.set(h * d, o * u, h * c, o * l);
              break;
            case "ZXZ":
              t.set(h * c, h * d, o * u, o * l);
              break;
            case "XZX":
              t.set(o * u, h * m, h * p, o * l);
              break;
            case "YXY":
              t.set(h * p, o * u, h * m, o * l);
              break;
            case "ZYZ":
              t.set(h * m, h * p, o * u, o * l);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                  s
              );
          }
        },
        normalize: normalize,
        denormalize: denormalize,
      };
      let Vector2 = class Vector2 {
        constructor(t = 0, e = 0) {
          (Vector2.prototype.isVector2 = !0), (this.x = t), (this.y = e);
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, e) {
          return (this.x = t), (this.y = e), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), this;
        }
        add(t) {
          return (this.x += t.x), (this.y += t.y), this;
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), this;
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        }
        sub(t) {
          return (this.x -= t.x), (this.y -= t.y), this;
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), this;
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), this;
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          let e = this.x,
            i = this.y,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[3] * i + r[6]),
            (this.y = r[1] * e + r[4] * i + r[7]),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = clamp(this.x, t.x, e.x)),
            (this.y = clamp(this.y, t.y, e.y)),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = clamp(this.x, t, e)), (this.y = clamp(this.y, t, e)), this
          );
        }
        clampLength(t, e) {
          let i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(clamp(i, t, e));
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          let t = Math.atan2(-this.y, -this.x) + Math.PI;
          return t;
        }
        angleTo(t) {
          let e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (0 === e) return Math.PI / 2;
          let i = this.dot(t) / e;
          return Math.acos(clamp(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          let e = this.x - t.x,
            i = this.y - t.y;
          return e * e + i * i;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        }
        lerpVectors(t, e, i) {
          return (
            (this.x = t.x + (e.x - t.x) * i),
            (this.y = t.y + (e.y - t.y) * i),
            this
          );
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), this;
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), t;
        }
        fromBufferAttribute(t, e) {
          return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
        }
        rotateAround(t, e) {
          let i = Math.cos(e),
            r = Math.sin(e),
            s = this.x - t.x,
            n = this.y - t.y;
          return (
            (this.x = s * i - n * r + t.x), (this.y = s * r + n * i + t.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      };
      let Matrix3 = class Matrix3 {
        constructor(t, e, i, r, s, n, a, o, h) {
          (Matrix3.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            void 0 !== t && this.set(t, e, i, r, s, n, a, o, h);
        }
        set(t, e, i, r, s, n, a, o, h) {
          let l = this.elements;
          return (
            (l[0] = t),
            (l[1] = r),
            (l[2] = a),
            (l[3] = e),
            (l[4] = s),
            (l[5] = o),
            (l[6] = i),
            (l[7] = n),
            (l[8] = h),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          let e = this.elements,
            i = t.elements;
          return (
            (e[0] = i[0]),
            (e[1] = i[1]),
            (e[2] = i[2]),
            (e[3] = i[3]),
            (e[4] = i[4]),
            (e[5] = i[5]),
            (e[6] = i[6]),
            (e[7] = i[7]),
            (e[8] = i[8]),
            this
          );
        }
        extractBasis(t, e, i) {
          return (
            t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            i.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(t) {
          let e = t.elements;
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          let i = t.elements,
            r = e.elements,
            s = this.elements,
            n = i[0],
            a = i[3],
            o = i[6],
            h = i[1],
            l = i[4],
            u = i[7],
            c = i[2],
            d = i[5],
            p = i[8],
            m = r[0],
            f = r[3],
            y = r[6],
            g = r[1],
            x = r[4],
            b = r[7],
            M = r[2],
            w = r[5],
            S = r[8];
          return (
            (s[0] = n * m + a * g + o * M),
            (s[3] = n * f + a * x + o * w),
            (s[6] = n * y + a * b + o * S),
            (s[1] = h * m + l * g + u * M),
            (s[4] = h * f + l * x + u * w),
            (s[7] = h * y + l * b + u * S),
            (s[2] = c * m + d * g + p * M),
            (s[5] = c * f + d * x + p * w),
            (s[8] = c * y + d * b + p * S),
            this
          );
        }
        multiplyScalar(t) {
          let e = this.elements;
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          );
        }
        determinant() {
          let t = this.elements,
            e = t[0],
            i = t[1],
            r = t[2],
            s = t[3],
            n = t[4],
            a = t[5],
            o = t[6],
            h = t[7],
            l = t[8];
          return (
            e * n * l -
            e * a * h -
            i * s * l +
            i * a * o +
            r * s * h -
            r * n * o
          );
        }
        invert() {
          let t = this.elements,
            e = t[0],
            i = t[1],
            r = t[2],
            s = t[3],
            n = t[4],
            a = t[5],
            o = t[6],
            h = t[7],
            l = t[8],
            u = l * n - a * h,
            c = a * o - l * s,
            d = h * s - n * o,
            p = e * u + i * c + r * d;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          let m = 1 / p;
          return (
            (t[0] = u * m),
            (t[1] = (r * h - l * i) * m),
            (t[2] = (a * i - r * n) * m),
            (t[3] = c * m),
            (t[4] = (l * e - r * o) * m),
            (t[5] = (r * s - a * e) * m),
            (t[6] = d * m),
            (t[7] = (i * o - h * e) * m),
            (t[8] = (n * e - i * s) * m),
            this
          );
        }
        transpose() {
          let t;
          let e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          );
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          let e = this.elements;
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          );
        }
        setUvTransform(t, e, i, r, s, n, a) {
          let o = Math.cos(s),
            h = Math.sin(s);
          return (
            this.set(
              i * o,
              i * h,
              -i * (o * n + h * a) + n + t,
              -r * h,
              r * o,
              -r * (-h * n + o * a) + a + e,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(t, e) {
          return this.premultiply(iL.makeScale(t, e)), this;
        }
        rotate(t) {
          return this.premultiply(iL.makeRotation(-t)), this;
        }
        translate(t, e) {
          return this.premultiply(iL.makeTranslation(t, e)), this;
        }
        makeTranslation(t, e) {
          return (
            t.isVector2
              ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
              : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
            this
          );
        }
        makeRotation(t) {
          let e = Math.cos(t),
            i = Math.sin(t);
          return this.set(e, -i, 0, i, e, 0, 0, 0, 1), this;
        }
        makeScale(t, e) {
          return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
        }
        equals(t) {
          let e = this.elements,
            i = t.elements;
          for (let t = 0; t < 9; t++) if (e[t] !== i[t]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
          return this;
        }
        toArray(t = [], e = 0) {
          let i = this.elements;
          return (
            (t[e] = i[0]),
            (t[e + 1] = i[1]),
            (t[e + 2] = i[2]),
            (t[e + 3] = i[3]),
            (t[e + 4] = i[4]),
            (t[e + 5] = i[5]),
            (t[e + 6] = i[6]),
            (t[e + 7] = i[7]),
            (t[e + 8] = i[8]),
            t
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      };
      let iL = new Matrix3();
      function arrayNeedsUint32(t) {
        for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
        return !1;
      }
      let ik = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array,
      };
      function getTypedArray(t, e) {
        return new ik[t](e);
      }
      function createElementNS(t) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", t);
      }
      function createCanvasElement() {
        let t = createElementNS("canvas");
        return (t.style.display = "block"), t;
      }
      let iR = {};
      function warnOnce(t) {
        t in iR || ((iR[t] = !0), console.warn(t));
      }
      function probeAsync(t, e, i) {
        return new Promise(function (r, s) {
          setTimeout(function probe() {
            switch (t.clientWaitSync(e, t.SYNC_FLUSH_COMMANDS_BIT, 0)) {
              case t.WAIT_FAILED:
                s();
                break;
              case t.TIMEOUT_EXPIRED:
                setTimeout(probe, i);
                break;
              default:
                r();
            }
          }, i);
        });
      }
      function toNormalizedProjectionMatrix(t) {
        let e = t.elements;
        (e[2] = 0.5 * e[2] + 0.5 * e[3]),
          (e[6] = 0.5 * e[6] + 0.5 * e[7]),
          (e[10] = 0.5 * e[10] + 0.5 * e[11]),
          (e[14] = 0.5 * e[14] + 0.5 * e[15]);
      }
      function toReversedProjectionMatrix(t) {
        let e = t.elements,
          i = -1 === e[11];
        i
          ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
          : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
      }
      let iE = new Matrix3().set(
          0.4123908,
          0.3575843,
          0.1804808,
          0.212639,
          0.7151687,
          0.0721923,
          0.0193308,
          0.1191948,
          0.9505322
        ),
        iO = new Matrix3().set(
          3.2409699,
          -1.5373832,
          -0.4986108,
          -0.9692436,
          1.8759675,
          0.0415551,
          0.0556301,
          -0.203977,
          1.0569715
        ),
        iF = (function () {
          let t = {
              enabled: !0,
              workingColorSpace: eY,
              spaces: {},
              convert: function (t, e, i) {
                return (
                  !1 !== this.enabled &&
                    e !== i &&
                    e &&
                    i &&
                    (this.spaces[e].transfer === eK &&
                      ((t.r = SRGBToLinear(t.r)),
                      (t.g = SRGBToLinear(t.g)),
                      (t.b = SRGBToLinear(t.b))),
                    this.spaces[e].primaries !== this.spaces[i].primaries &&
                      (t.applyMatrix3(this.spaces[e].toXYZ),
                      t.applyMatrix3(this.spaces[i].fromXYZ)),
                    this.spaces[i].transfer === eK &&
                      ((t.r = LinearToSRGB(t.r)),
                      (t.g = LinearToSRGB(t.g)),
                      (t.b = LinearToSRGB(t.b)))),
                  t
                );
              },
              fromWorkingColorSpace: function (t, e) {
                return this.convert(t, this.workingColorSpace, e);
              },
              toWorkingColorSpace: function (t, e) {
                return this.convert(t, e, this.workingColorSpace);
              },
              getPrimaries: function (t) {
                return this.spaces[t].primaries;
              },
              getTransfer: function (t) {
                return t === eZ ? eQ : this.spaces[t].transfer;
              },
              getLuminanceCoefficients: function (
                t,
                e = this.workingColorSpace
              ) {
                return t.fromArray(this.spaces[e].luminanceCoefficients);
              },
              define: function (t) {
                Object.assign(this.spaces, t);
              },
              _getMatrix: function (t, e, i) {
                return t
                  .copy(this.spaces[e].toXYZ)
                  .multiply(this.spaces[i].fromXYZ);
              },
              _getDrawingBufferColorSpace: function (t) {
                return this.spaces[t].outputColorSpaceConfig
                  .drawingBufferColorSpace;
              },
              _getUnpackColorSpace: function (t = this.workingColorSpace) {
                return this.spaces[t].workingColorSpaceConfig.unpackColorSpace;
              },
            },
            e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
            i = [0.2126, 0.7152, 0.0722],
            r = [0.3127, 0.329];
          return (
            t.define({
              [eY]: {
                primaries: e,
                whitePoint: r,
                transfer: eQ,
                toXYZ: iE,
                fromXYZ: iO,
                luminanceCoefficients: i,
                workingColorSpaceConfig: { unpackColorSpace: eX },
                outputColorSpaceConfig: { drawingBufferColorSpace: eX },
              },
              [eX]: {
                primaries: e,
                whitePoint: r,
                transfer: eK,
                toXYZ: iE,
                fromXYZ: iO,
                luminanceCoefficients: i,
                outputColorSpaceConfig: { drawingBufferColorSpace: eX },
              },
            }),
            t
          );
        })();
      function SRGBToLinear(t) {
        return t < 0.04045
          ? 0.0773993808 * t
          : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
      }
      function LinearToSRGB(t) {
        return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
      }
      let ImageUtils = class ImageUtils {
        static getDataURL(t) {
          let e;
          if (/^data:/i.test(t.src) || "undefined" == typeof HTMLCanvasElement)
            return t.src;
          if (t instanceof HTMLCanvasElement) e = t;
          else {
            void 0 === r && (r = createElementNS("canvas")),
              (r.width = t.width),
              (r.height = t.height);
            let i = r.getContext("2d");
            t instanceof ImageData
              ? i.putImageData(t, 0, 0)
              : i.drawImage(t, 0, 0, t.width, t.height),
              (e = r);
          }
          return e.width > 2048 || e.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                t
              ),
              e.toDataURL("image/jpeg", 0.6))
            : e.toDataURL("image/png");
        }
        static sRGBToLinear(t) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            let e = createElementNS("canvas");
            (e.width = t.width), (e.height = t.height);
            let i = e.getContext("2d");
            i.drawImage(t, 0, 0, t.width, t.height);
            let r = i.getImageData(0, 0, t.width, t.height),
              s = r.data;
            for (let t = 0; t < s.length; t++)
              s[t] = 255 * SRGBToLinear(s[t] / 255);
            return i.putImageData(r, 0, 0), e;
          }
          if (!t.data)
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              t
            );
          {
            let e = t.data.slice(0);
            for (let t = 0; t < e.length; t++)
              e instanceof Uint8Array || e instanceof Uint8ClampedArray
                ? (e[t] = Math.floor(255 * SRGBToLinear(e[t] / 255)))
                : (e[t] = SRGBToLinear(e[t]));
            return { data: e, width: t.width, height: t.height };
          }
        }
      };
      let iN = 0;
      let Source = class Source {
        constructor(t = null) {
          (this.isSource = !0),
            Object.defineProperty(this, "id", { value: iN++ }),
            (this.uuid = generateUUID()),
            (this.data = t),
            (this.dataReady = !0),
            (this.version = 0);
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        toJSON(t) {
          let e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
          let i = { uuid: this.uuid, url: "" },
            r = this.data;
          if (null !== r) {
            let t;
            if (Array.isArray(r)) {
              t = [];
              for (let e = 0, i = r.length; e < i; e++)
                r[e].isDataTexture
                  ? t.push(serializeImage(r[e].image))
                  : t.push(serializeImage(r[e]));
            } else t = serializeImage(r);
            i.url = t;
          }
          return e || (t.images[this.uuid] = i), i;
        }
      };
      function serializeImage(t) {
        return ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ? ImageUtils.getDataURL(t)
          : t.data
          ? {
              data: Array.from(t.data),
              width: t.width,
              height: t.height,
              type: t.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let iD = 0;
      let Texture = class Texture extends EventDispatcher {
        constructor(
          t = Texture.DEFAULT_IMAGE,
          e = Texture.DEFAULT_MAPPING,
          i = tS,
          r = tS,
          s = tI,
          n = tL,
          a = tX,
          o = tR,
          h = Texture.DEFAULT_ANISOTROPY,
          l = eZ
        ) {
          super(),
            (this.isTexture = !0),
            Object.defineProperty(this, "id", { value: iD++ }),
            (this.uuid = generateUUID()),
            (this.name = ""),
            (this.source = new Source(t)),
            (this.mipmaps = []),
            (this.mapping = e),
            (this.channel = 0),
            (this.wrapS = i),
            (this.wrapT = r),
            (this.magFilter = s),
            (this.minFilter = n),
            (this.anisotropy = h),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = o),
            (this.offset = new Vector2(0, 0)),
            (this.repeat = new Vector2(1, 1)),
            (this.center = new Vector2(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Matrix3()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.colorSpace = l),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.pmremVersion = 0);
        }
        get image() {
          return this.source.data;
        }
        set image(t = null) {
          this.source.data = t;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.source = t.source),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.channel = t.channel),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.colorSpace = t.colorSpace),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(t) {
          let e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          let i = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            Object.keys(this.userData).length > 0 &&
              (i.userData = this.userData),
            e || (t.textures[this.uuid] = i),
            i
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(t) {
          if (this.mapping !== ty) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case tw:
                t.x = t.x - Math.floor(t.x);
                break;
              case tS:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case tA:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case tw:
                t.y = t.y - Math.floor(t.y);
                break;
              case tS:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case tA:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
            }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          !0 === t && (this.version++, (this.source.needsUpdate = !0));
        }
        set needsPMREMUpdate(t) {
          !0 === t && this.pmremVersion++;
        }
      };
      (Texture.DEFAULT_IMAGE = null),
        (Texture.DEFAULT_MAPPING = ty),
        (Texture.DEFAULT_ANISOTROPY = 1);
      let Vector4 = class Vector4 {
        constructor(t = 0, e = 0, i = 0, r = 1) {
          (Vector4.prototype.isVector4 = !0),
            (this.x = t),
            (this.y = e),
            (this.z = i),
            (this.w = r);
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, e, i, r) {
          return (this.x = t), (this.y = e), (this.z = i), (this.w = r), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setW(t) {
          return (this.w = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        }
        add(t) {
          return (
            (this.x += t.x),
            (this.y += t.y),
            (this.z += t.z),
            (this.w += t.w),
            this
          );
        }
        addScalar(t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        }
        sub(t) {
          return (
            (this.x -= t.x),
            (this.y -= t.y),
            (this.z -= t.z),
            (this.w -= t.w),
            this
          );
        }
        subScalar(t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        }
        multiply(t) {
          return (
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            (this.w *= t.w),
            this
          );
        }
        multiplyScalar(t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        }
        applyMatrix4(t) {
          let e = this.x,
            i = this.y,
            r = this.z,
            s = this.w,
            n = t.elements;
          return (
            (this.x = n[0] * e + n[4] * i + n[8] * r + n[12] * s),
            (this.y = n[1] * e + n[5] * i + n[9] * r + n[13] * s),
            (this.z = n[2] * e + n[6] * i + n[10] * r + n[14] * s),
            (this.w = n[3] * e + n[7] * i + n[11] * r + n[15] * s),
            this
          );
        }
        divide(t) {
          return (
            (this.x /= t.x),
            (this.y /= t.y),
            (this.z /= t.z),
            (this.w /= t.w),
            this
          );
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          let e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, i, r;
          let s = t.elements,
            n = s[0],
            a = s[4],
            o = s[8],
            h = s[1],
            l = s[5],
            u = s[9],
            c = s[2],
            d = s[6],
            p = s[10];
          if (
            0.01 > Math.abs(a - h) &&
            0.01 > Math.abs(o - c) &&
            0.01 > Math.abs(u - d)
          ) {
            if (
              0.1 > Math.abs(a + h) &&
              0.1 > Math.abs(o + c) &&
              0.1 > Math.abs(u + d) &&
              0.1 > Math.abs(n + l + p - 3)
            )
              return this.set(1, 0, 0, 0), this;
            let t = (n + 1) / 2,
              s = (l + 1) / 2,
              m = (p + 1) / 2,
              f = (a + h) / 4,
              y = (o + c) / 4,
              g = (u + d) / 4;
            return (
              t > s && t > m
                ? t < 0.01
                  ? ((e = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((i = f / (e = Math.sqrt(t))), (r = y / e))
                : s > m
                ? s < 0.01
                  ? ((e = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((e = f / (i = Math.sqrt(s))), (r = g / i))
                : m < 0.01
                ? ((e = 0.707106781), (i = 0.707106781), (r = 0))
                : ((e = y / (r = Math.sqrt(m))), (i = g / r)),
              this.set(e, i, r, Math.PI),
              this
            );
          }
          let m = Math.sqrt(
            (d - u) * (d - u) + (o - c) * (o - c) + (h - a) * (h - a)
          );
          return (
            0.001 > Math.abs(m) && (m = 1),
            (this.x = (d - u) / m),
            (this.y = (o - c) / m),
            (this.z = (h - a) / m),
            (this.w = Math.acos((n + l + p - 1) / 2)),
            this
          );
        }
        setFromMatrixPosition(t) {
          let e = t.elements;
          return (
            (this.x = e[12]),
            (this.y = e[13]),
            (this.z = e[14]),
            (this.w = e[15]),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = clamp(this.x, t.x, e.x)),
            (this.y = clamp(this.y, t.y, e.y)),
            (this.z = clamp(this.z, t.z, e.z)),
            (this.w = clamp(this.w, t.w, e.w)),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = clamp(this.x, t, e)),
            (this.y = clamp(this.y, t, e)),
            (this.z = clamp(this.z, t, e)),
            (this.w = clamp(this.w, t, e)),
            this
          );
        }
        clampLength(t, e) {
          let i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(clamp(i, t, e));
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            (this.w = Math.trunc(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        }
        lerpVectors(t, e, i) {
          return (
            (this.x = t.x + (e.x - t.x) * i),
            (this.y = t.y + (e.y - t.y) * i),
            (this.z = t.z + (e.z - t.z) * i),
            (this.w = t.w + (e.w - t.w) * i),
            this
          );
        }
        equals(t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      };
      let RenderTarget = class RenderTarget extends EventDispatcher {
        constructor(t = 1, e = 1, i = {}) {
          super(),
            (this.isRenderTarget = !0),
            (this.width = t),
            (this.height = e),
            (this.depth = 1),
            (this.scissor = new Vector4(0, 0, t, e)),
            (this.scissorTest = !1),
            (this.viewport = new Vector4(0, 0, t, e)),
            (i = Object.assign(
              {
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: tI,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1,
              },
              i
            ));
          let r = new Texture(
            { width: t, height: e, depth: 1 },
            i.mapping,
            i.wrapS,
            i.wrapT,
            i.magFilter,
            i.minFilter,
            i.format,
            i.type,
            i.anisotropy,
            i.colorSpace
          );
          (r.flipY = !1),
            (r.generateMipmaps = i.generateMipmaps),
            (r.internalFormat = i.internalFormat),
            (this.textures = []);
          let s = i.count;
          for (let t = 0; t < s; t++)
            (this.textures[t] = r.clone()),
              (this.textures[t].isRenderTargetTexture = !0);
          (this.depthBuffer = i.depthBuffer),
            (this.stencilBuffer = i.stencilBuffer),
            (this.resolveDepthBuffer = i.resolveDepthBuffer),
            (this.resolveStencilBuffer = i.resolveStencilBuffer),
            (this.depthTexture = i.depthTexture),
            (this.samples = i.samples);
        }
        get texture() {
          return this.textures[0];
        }
        set texture(t) {
          this.textures[0] = t;
        }
        setSize(t, e, i = 1) {
          if (this.width !== t || this.height !== e || this.depth !== i) {
            (this.width = t), (this.height = e), (this.depth = i);
            for (let r = 0, s = this.textures.length; r < s; r++)
              (this.textures[r].image.width = t),
                (this.textures[r].image.height = e),
                (this.textures[r].image.depth = i);
            this.dispose();
          }
          this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.scissor.copy(t.scissor),
            (this.scissorTest = t.scissorTest),
            this.viewport.copy(t.viewport),
            (this.textures.length = 0);
          for (let e = 0, i = t.textures.length; e < i; e++)
            (this.textures[e] = t.textures[e].clone()),
              (this.textures[e].isRenderTargetTexture = !0);
          let e = Object.assign({}, t.texture.image);
          return (
            (this.texture.source = new Source(e)),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.resolveDepthBuffer = t.resolveDepthBuffer),
            (this.resolveStencilBuffer = t.resolveStencilBuffer),
            null !== t.depthTexture &&
              (this.depthTexture = t.depthTexture.clone()),
            (this.samples = t.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      let WebGLRenderTarget = class WebGLRenderTarget extends RenderTarget {
        constructor(t = 1, e = 1, i = {}) {
          super(t, e, i), (this.isWebGLRenderTarget = !0);
        }
      };
      let DataArrayTexture = class DataArrayTexture extends Texture {
        constructor(t = null, e = 1, i = 1, r = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: t, width: e, height: i, depth: r }),
            (this.magFilter = t_),
            (this.minFilter = t_),
            (this.wrapR = tS),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.layerUpdates = new Set());
        }
        addLayerUpdate(t) {
          this.layerUpdates.add(t);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      };
      let WebGLArrayRenderTarget = class WebGLArrayRenderTarget extends WebGLRenderTarget {
        constructor(t = 1, e = 1, i = 1, r = {}) {
          super(t, e, r),
            (this.isWebGLArrayRenderTarget = !0),
            (this.depth = i),
            (this.texture = new DataArrayTexture(null, t, e, i)),
            (this.texture.isRenderTargetTexture = !0);
        }
      };
      let Data3DTexture = class Data3DTexture extends Texture {
        constructor(t = null, e = 1, i = 1, r = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: t, width: e, height: i, depth: r }),
            (this.magFilter = t_),
            (this.minFilter = t_),
            (this.wrapR = tS),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      };
      let WebGL3DRenderTarget = class WebGL3DRenderTarget extends WebGLRenderTarget {
        constructor(t = 1, e = 1, i = 1, r = {}) {
          super(t, e, r),
            (this.isWebGL3DRenderTarget = !0),
            (this.depth = i),
            (this.texture = new Data3DTexture(null, t, e, i)),
            (this.texture.isRenderTargetTexture = !0);
        }
      };
      let Quaternion = class Quaternion {
        constructor(t = 0, e = 0, i = 0, r = 1) {
          (this.isQuaternion = !0),
            (this._x = t),
            (this._y = e),
            (this._z = i),
            (this._w = r);
        }
        static slerpFlat(t, e, i, r, s, n, a) {
          let o = i[r + 0],
            h = i[r + 1],
            l = i[r + 2],
            u = i[r + 3],
            c = s[n + 0],
            d = s[n + 1],
            p = s[n + 2],
            m = s[n + 3];
          if (0 === a) {
            (t[e + 0] = o), (t[e + 1] = h), (t[e + 2] = l), (t[e + 3] = u);
            return;
          }
          if (1 === a) {
            (t[e + 0] = c), (t[e + 1] = d), (t[e + 2] = p), (t[e + 3] = m);
            return;
          }
          if (u !== m || o !== c || h !== d || l !== p) {
            let t = 1 - a,
              e = o * c + h * d + l * p + u * m,
              i = e >= 0 ? 1 : -1,
              r = 1 - e * e;
            if (r > Number.EPSILON) {
              let s = Math.sqrt(r),
                n = Math.atan2(s, e * i);
              (t = Math.sin(t * n) / s), (a = Math.sin(a * n) / s);
            }
            let s = a * i;
            if (
              ((o = o * t + c * s),
              (h = h * t + d * s),
              (l = l * t + p * s),
              (u = u * t + m * s),
              t === 1 - a)
            ) {
              let t = 1 / Math.sqrt(o * o + h * h + l * l + u * u);
              (o *= t), (h *= t), (l *= t), (u *= t);
            }
          }
          (t[e] = o), (t[e + 1] = h), (t[e + 2] = l), (t[e + 3] = u);
        }
        static multiplyQuaternionsFlat(t, e, i, r, s, n) {
          let a = i[r],
            o = i[r + 1],
            h = i[r + 2],
            l = i[r + 3],
            u = s[n],
            c = s[n + 1],
            d = s[n + 2],
            p = s[n + 3];
          return (
            (t[e] = a * p + l * u + o * d - h * c),
            (t[e + 1] = o * p + l * c + h * u - a * d),
            (t[e + 2] = h * p + l * d + a * c - o * u),
            (t[e + 3] = l * p - a * u - o * c - h * d),
            t
          );
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          (this._w = t), this._onChangeCallback();
        }
        set(t, e, i, r) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = i),
            (this._w = r),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(t, e = !0) {
          let i = t._x,
            r = t._y,
            s = t._z,
            n = t._order,
            a = Math.cos,
            o = Math.sin,
            h = a(i / 2),
            l = a(r / 2),
            u = a(s / 2),
            c = o(i / 2),
            d = o(r / 2),
            p = o(s / 2);
          switch (n) {
            case "XYZ":
              (this._x = c * l * u + h * d * p),
                (this._y = h * d * u - c * l * p),
                (this._z = h * l * p + c * d * u),
                (this._w = h * l * u - c * d * p);
              break;
            case "YXZ":
              (this._x = c * l * u + h * d * p),
                (this._y = h * d * u - c * l * p),
                (this._z = h * l * p - c * d * u),
                (this._w = h * l * u + c * d * p);
              break;
            case "ZXY":
              (this._x = c * l * u - h * d * p),
                (this._y = h * d * u + c * l * p),
                (this._z = h * l * p + c * d * u),
                (this._w = h * l * u - c * d * p);
              break;
            case "ZYX":
              (this._x = c * l * u - h * d * p),
                (this._y = h * d * u + c * l * p),
                (this._z = h * l * p - c * d * u),
                (this._w = h * l * u + c * d * p);
              break;
            case "YZX":
              (this._x = c * l * u + h * d * p),
                (this._y = h * d * u + c * l * p),
                (this._z = h * l * p - c * d * u),
                (this._w = h * l * u - c * d * p);
              break;
            case "XZY":
              (this._x = c * l * u - h * d * p),
                (this._y = h * d * u - c * l * p),
                (this._z = h * l * p + c * d * u),
                (this._w = h * l * u + c * d * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  n
              );
          }
          return !0 === e && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
          let i = e / 2,
            r = Math.sin(i);
          return (
            (this._x = t.x * r),
            (this._y = t.y * r),
            (this._z = t.z * r),
            (this._w = Math.cos(i)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t) {
          let e = t.elements,
            i = e[0],
            r = e[4],
            s = e[8],
            n = e[1],
            a = e[5],
            o = e[9],
            h = e[2],
            l = e[6],
            u = e[10],
            c = i + a + u;
          if (c > 0) {
            let t = 0.5 / Math.sqrt(c + 1);
            (this._w = 0.25 / t),
              (this._x = (l - o) * t),
              (this._y = (s - h) * t),
              (this._z = (n - r) * t);
          } else if (i > a && i > u) {
            let t = 2 * Math.sqrt(1 + i - a - u);
            (this._w = (l - o) / t),
              (this._x = 0.25 * t),
              (this._y = (r + n) / t),
              (this._z = (s + h) / t);
          } else if (a > u) {
            let t = 2 * Math.sqrt(1 + a - i - u);
            (this._w = (s - h) / t),
              (this._x = (r + n) / t),
              (this._y = 0.25 * t),
              (this._z = (o + l) / t);
          } else {
            let t = 2 * Math.sqrt(1 + u - i - a);
            (this._w = (n - r) / t),
              (this._x = (s + h) / t),
              (this._y = (o + l) / t),
              (this._z = 0.25 * t);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
          let i = t.dot(e) + 1;
          return (
            i < Number.EPSILON
              ? ((i = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y), (this._y = t.x), (this._z = 0))
                  : ((this._x = 0), (this._y = -t.z), (this._z = t.y)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x)),
            (this._w = i),
            this.normalize()
          );
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(clamp(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
          let i = this.angleTo(t);
          return 0 === i || this.slerp(t, Math.min(1, e / i)), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(t) {
          return this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
          let i = t._x,
            r = t._y,
            s = t._z,
            n = t._w,
            a = e._x,
            o = e._y,
            h = e._z,
            l = e._w;
          return (
            (this._x = i * l + n * a + r * h - s * o),
            (this._y = r * l + n * o + s * a - i * h),
            (this._z = s * l + n * h + i * o - r * a),
            (this._w = n * l - i * a - r * o - s * h),
            this._onChangeCallback(),
            this
          );
        }
        slerp(t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          let i = this._x,
            r = this._y,
            s = this._z,
            n = this._w,
            a = n * t._w + i * t._x + r * t._y + s * t._z;
          if (
            (a < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (a = -a))
              : this.copy(t),
            a >= 1)
          )
            return (
              (this._w = n), (this._x = i), (this._y = r), (this._z = s), this
            );
          let o = 1 - a * a;
          if (o <= Number.EPSILON) {
            let t = 1 - e;
            return (
              (this._w = t * n + e * this._w),
              (this._x = t * i + e * this._x),
              (this._y = t * r + e * this._y),
              (this._z = t * s + e * this._z),
              this.normalize(),
              this
            );
          }
          let h = Math.sqrt(o),
            l = Math.atan2(h, a),
            u = Math.sin((1 - e) * l) / h,
            c = Math.sin(e * l) / h;
          return (
            (this._w = n * u + this._w * c),
            (this._x = i * u + this._x * c),
            (this._y = r * u + this._y * c),
            (this._z = s * u + this._z * c),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(t, e, i) {
          return this.copy(t).slerp(e, i);
        }
        random() {
          let t = 2 * Math.PI * Math.random(),
            e = 2 * Math.PI * Math.random(),
            i = Math.random(),
            r = Math.sqrt(1 - i),
            s = Math.sqrt(i);
          return this.set(
            r * Math.sin(t),
            r * Math.cos(t),
            s * Math.sin(e),
            s * Math.cos(e)
          );
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this._x = t.getX(e)),
            (this._y = t.getY(e)),
            (this._z = t.getZ(e)),
            (this._w = t.getW(e)),
            this._onChangeCallback(),
            this
          );
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      };
      let Vector3 = class Vector3 {
        constructor(t = 0, e = 0, i = 0) {
          (Vector3.prototype.isVector3 = !0),
            (this.x = t),
            (this.y = e),
            (this.z = i);
        }
        set(t, e, i) {
          return (
            void 0 === i && (i = this.z),
            (this.x = t),
            (this.y = e),
            (this.z = i),
            this
          );
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        }
        add(t) {
          return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), this;
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          );
        }
        sub(t) {
          return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this;
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            this
          );
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this;
        }
        multiplyVectors(t, e) {
          return (
            (this.x = t.x * e.x),
            (this.y = t.y * e.y),
            (this.z = t.z * e.z),
            this
          );
        }
        applyEuler(t) {
          return this.applyQuaternion(iG.setFromEuler(t));
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(iG.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
          let e = this.x,
            i = this.y,
            r = this.z,
            s = t.elements;
          return (
            (this.x = s[0] * e + s[3] * i + s[6] * r),
            (this.y = s[1] * e + s[4] * i + s[7] * r),
            (this.z = s[2] * e + s[5] * i + s[8] * r),
            this
          );
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          let e = this.x,
            i = this.y,
            r = this.z,
            s = t.elements,
            n = 1 / (s[3] * e + s[7] * i + s[11] * r + s[15]);
          return (
            (this.x = (s[0] * e + s[4] * i + s[8] * r + s[12]) * n),
            (this.y = (s[1] * e + s[5] * i + s[9] * r + s[13]) * n),
            (this.z = (s[2] * e + s[6] * i + s[10] * r + s[14]) * n),
            this
          );
        }
        applyQuaternion(t) {
          let e = this.x,
            i = this.y,
            r = this.z,
            s = t.x,
            n = t.y,
            a = t.z,
            o = t.w,
            h = 2 * (n * r - a * i),
            l = 2 * (a * e - s * r),
            u = 2 * (s * i - n * e);
          return (
            (this.x = e + o * h + n * u - a * l),
            (this.y = i + o * l + a * h - s * u),
            (this.z = r + o * u + s * l - n * h),
            this
          );
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
            t.projectionMatrix
          );
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
            t.matrixWorld
          );
        }
        transformDirection(t) {
          let e = this.x,
            i = this.y,
            r = this.z,
            s = t.elements;
          return (
            (this.x = s[0] * e + s[4] * i + s[8] * r),
            (this.y = s[1] * e + s[5] * i + s[9] * r),
            (this.z = s[2] * e + s[6] * i + s[10] * r),
            this.normalize()
          );
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = clamp(this.x, t.x, e.x)),
            (this.y = clamp(this.y, t.y, e.y)),
            (this.z = clamp(this.z, t.z, e.z)),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = clamp(this.x, t, e)),
            (this.y = clamp(this.y, t, e)),
            (this.z = clamp(this.z, t, e)),
            this
          );
        }
        clampLength(t, e) {
          let i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(clamp(i, t, e));
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            this
          );
        }
        lerpVectors(t, e, i) {
          return (
            (this.x = t.x + (e.x - t.x) * i),
            (this.y = t.y + (e.y - t.y) * i),
            (this.z = t.z + (e.z - t.z) * i),
            this
          );
        }
        cross(t) {
          return this.crossVectors(this, t);
        }
        crossVectors(t, e) {
          let i = t.x,
            r = t.y,
            s = t.z,
            n = e.x,
            a = e.y,
            o = e.z;
          return (
            (this.x = r * o - s * a),
            (this.y = s * n - i * o),
            (this.z = i * a - r * n),
            this
          );
        }
        projectOnVector(t) {
          let e = t.lengthSq();
          if (0 === e) return this.set(0, 0, 0);
          let i = t.dot(this) / e;
          return this.copy(t).multiplyScalar(i);
        }
        projectOnPlane(t) {
          return iU.copy(this).projectOnVector(t), this.sub(iU);
        }
        reflect(t) {
          return this.sub(iU.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          let e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (0 === e) return Math.PI / 2;
          let i = this.dot(t) / e;
          return Math.acos(clamp(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          let e = this.x - t.x,
            i = this.y - t.y,
            r = this.z - t.z;
          return e * e + i * i + r * r;
        }
        manhattanDistanceTo(t) {
          return (
            Math.abs(this.x - t.x) +
            Math.abs(this.y - t.y) +
            Math.abs(this.z - t.z)
          );
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, i) {
          let r = Math.sin(e) * t;
          return (
            (this.x = r * Math.sin(i)),
            (this.y = Math.cos(e) * t),
            (this.z = r * Math.cos(i)),
            this
          );
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, i) {
          return (
            (this.x = t * Math.sin(e)),
            (this.y = i),
            (this.z = t * Math.cos(e)),
            this
          );
        }
        setFromMatrixPosition(t) {
          let e = t.elements;
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
        }
        setFromMatrixScale(t) {
          let e = this.setFromMatrixColumn(t, 0).length(),
            i = this.setFromMatrixColumn(t, 1).length(),
            r = this.setFromMatrixColumn(t, 2).length();
          return (this.x = e), (this.y = i), (this.z = r), this;
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, 4 * e);
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, 3 * e);
        }
        setFromEuler(t) {
          return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
        }
        setFromColor(t) {
          return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          let t = Math.random() * Math.PI * 2,
            e = 2 * Math.random() - 1,
            i = Math.sqrt(1 - e * e);
          return (
            (this.x = i * Math.cos(t)),
            (this.y = e),
            (this.z = i * Math.sin(t)),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      };
      let iU = new Vector3(),
        iG = new Quaternion();
      let Box3 = class Box3 {
        constructor(
          t = new Vector3(Infinity, Infinity, Infinity),
          e = new Vector3(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.isBox3 = !0), (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e += 3)
            this.expandByPoint(iW.fromArray(t, e));
          return this;
        }
        setFromBufferAttribute(t) {
          this.makeEmpty();
          for (let e = 0, i = t.count; e < i; e++)
            this.expandByPoint(iW.fromBufferAttribute(t, e));
          return this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          let i = iW.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }
        setFromObject(t, e = !1) {
          return this.makeEmpty(), this.expandByObject(t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = Infinity),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, e = !1) {
          t.updateWorldMatrix(!1, !1);
          let i = t.geometry;
          if (void 0 !== i) {
            let r = i.getAttribute("position");
            if (!0 === e && void 0 !== r && !0 !== t.isInstancedMesh)
              for (let e = 0, i = r.count; e < i; e++)
                !0 === t.isMesh
                  ? t.getVertexPosition(e, iW)
                  : iW.fromBufferAttribute(r, e),
                  iW.applyMatrix4(t.matrixWorld),
                  this.expandByPoint(iW);
            else
              void 0 !== t.boundingBox
                ? (null === t.boundingBox && t.computeBoundingBox(),
                  iH.copy(t.boundingBox))
                : (null === i.boundingBox && i.computeBoundingBox(),
                  iH.copy(i.boundingBox)),
                iH.applyMatrix4(t.matrixWorld),
                this.union(iH);
          }
          let r = t.children;
          for (let t = 0, i = r.length; t < i; t++)
            this.expandByObject(r[t], e);
          return this;
        }
        containsPoint(t) {
          return (
            t.x >= this.min.x &&
            t.x <= this.max.x &&
            t.y >= this.min.y &&
            t.y <= this.max.y &&
            t.z >= this.min.z &&
            t.z <= this.max.z
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(t) {
          return (
            t.max.x >= this.min.x &&
            t.min.x <= this.max.x &&
            t.max.y >= this.min.y &&
            t.min.y <= this.max.y &&
            t.max.z >= this.min.z &&
            t.min.z <= this.max.z
          );
        }
        intersectsSphere(t) {
          return (
            this.clampPoint(t.center, iW),
            iW.distanceToSquared(t.center) <= t.radius * t.radius
          );
        }
        intersectsPlane(t) {
          let e, i;
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (i = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (i = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y),
                (i += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z),
                (i += t.normal.z * this.min.z)),
            e <= -t.constant && i >= -t.constant
          );
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return !1;
          this.getCenter(iK),
            i$.subVectors(this.max, iK),
            iq.subVectors(t.a, iK),
            iJ.subVectors(t.b, iK),
            iZ.subVectors(t.c, iK),
            iX.subVectors(iJ, iq),
            iY.subVectors(iZ, iJ),
            iQ.subVectors(iq, iZ);
          let e = [
            0,
            -iX.z,
            iX.y,
            0,
            -iY.z,
            iY.y,
            0,
            -iQ.z,
            iQ.y,
            iX.z,
            0,
            -iX.x,
            iY.z,
            0,
            -iY.x,
            iQ.z,
            0,
            -iQ.x,
            -iX.y,
            iX.x,
            0,
            -iY.y,
            iY.x,
            0,
            -iQ.y,
            iQ.x,
            0,
          ];
          return (
            !!(
              satForAxes(e, iq, iJ, iZ, i$) &&
              satForAxes((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), iq, iJ, iZ, i$)
            ) &&
            (i0.crossVectors(iX, iY),
            satForAxes((e = [i0.x, i0.y, i0.z]), iq, iJ, iZ, i$))
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return this.clampPoint(t, iW).distanceTo(t);
        }
        getBoundingSphere(t) {
          return (
            this.isEmpty()
              ? t.makeEmpty()
              : (this.getCenter(t.center),
                (t.radius = 0.5 * this.getSize(iW).length())),
            t
          );
        }
        intersect(t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return (
            this.isEmpty() ||
              (ij[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              ij[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              ij[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              ij[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              ij[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              ij[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              ij[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              ij[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints(ij)),
            this
          );
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      };
      let ij = [
          new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector3(),
        ],
        iW = new Vector3(),
        iH = new Box3(),
        iq = new Vector3(),
        iJ = new Vector3(),
        iZ = new Vector3(),
        iX = new Vector3(),
        iY = new Vector3(),
        iQ = new Vector3(),
        iK = new Vector3(),
        i$ = new Vector3(),
        i0 = new Vector3(),
        i1 = new Vector3();
      function satForAxes(t, e, i, r, s) {
        for (let n = 0, a = t.length - 3; n <= a; n += 3) {
          i1.fromArray(t, n);
          let a =
              s.x * Math.abs(i1.x) +
              s.y * Math.abs(i1.y) +
              s.z * Math.abs(i1.z),
            o = e.dot(i1),
            h = i.dot(i1),
            l = r.dot(i1);
          if (Math.max(-Math.max(o, h, l), Math.min(o, h, l)) > a) return !1;
        }
        return !0;
      }
      let i3 = new Box3(),
        i2 = new Vector3(),
        i4 = new Vector3();
      let Sphere = class Sphere {
        constructor(t = new Vector3(), e = -1) {
          (this.isSphere = !0), (this.center = t), (this.radius = e);
        }
        set(t, e) {
          return this.center.copy(t), (this.radius = e), this;
        }
        setFromPoints(t, e) {
          let i = this.center;
          void 0 !== e ? i.copy(e) : i3.setFromPoints(t).getCenter(i);
          let r = 0;
          for (let e = 0, s = t.length; e < s; e++)
            r = Math.max(r, i.distanceToSquared(t[e]));
          return (this.radius = Math.sqrt(r)), this;
        }
        copy(t) {
          return this.center.copy(t.center), (this.radius = t.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          let e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
          let i = this.center.distanceToSquared(t);
          return (
            e.copy(t),
            i > this.radius * this.radius &&
              (e.sub(this.center).normalize(),
              e.multiplyScalar(this.radius).add(this.center)),
            e
          );
        }
        getBoundingBox(t) {
          return (
            this.isEmpty()
              ? t.makeEmpty()
              : (t.set(this.center, this.center),
                t.expandByScalar(this.radius)),
            t
          );
        }
        applyMatrix4(t) {
          return (
            this.center.applyMatrix4(t),
            (this.radius = this.radius * t.getMaxScaleOnAxis()),
            this
          );
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          if (this.isEmpty())
            return this.center.copy(t), (this.radius = 0), this;
          i2.subVectors(t, this.center);
          let e = i2.lengthSq();
          if (e > this.radius * this.radius) {
            let t = Math.sqrt(e),
              i = (t - this.radius) * 0.5;
            this.center.addScaledVector(i2, i / t), (this.radius += i);
          }
          return this;
        }
        union(t) {
          return (
            t.isEmpty() ||
              (this.isEmpty()
                ? this.copy(t)
                : !0 === this.center.equals(t.center)
                ? (this.radius = Math.max(this.radius, t.radius))
                : (i4.subVectors(t.center, this.center).setLength(t.radius),
                  this.expandByPoint(i2.copy(t.center).add(i4)),
                  this.expandByPoint(i2.copy(t.center).sub(i4)))),
            this
          );
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      let i5 = new Vector3(),
        i6 = new Vector3(),
        i7 = new Vector3(),
        i8 = new Vector3(),
        i9 = new Vector3(),
        rt = new Vector3(),
        re = new Vector3();
      let Ray = class Ray {
        constructor(t = new Vector3(), e = new Vector3(0, 0, -1)) {
          (this.origin = t), (this.direction = e);
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          );
        }
        at(t, e) {
          return e.copy(this.origin).addScaledVector(this.direction, t);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, i5)), this;
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin);
          let i = e.dot(this.direction);
          return i < 0
            ? e.copy(this.origin)
            : e.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          let e = i5.subVectors(t, this.origin).dot(this.direction);
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (i5.copy(this.origin).addScaledVector(this.direction, e),
              i5.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, i, r) {
          let s, n, a, o;
          i6.copy(t).add(e).multiplyScalar(0.5),
            i7.copy(e).sub(t).normalize(),
            i8.copy(this.origin).sub(i6);
          let h = 0.5 * t.distanceTo(e),
            l = -this.direction.dot(i7),
            u = i8.dot(this.direction),
            c = -i8.dot(i7),
            d = i8.lengthSq(),
            p = Math.abs(1 - l * l);
          if (p > 0) {
            if (((s = l * c - u), (n = l * u - c), (o = h * p), s >= 0)) {
              if (n >= -o) {
                if (n <= o) {
                  let t = 1 / p;
                  (s *= t),
                    (n *= t),
                    (a = s * (s + l * n + 2 * u) + n * (l * s + n + 2 * c) + d);
                } else
                  a =
                    -(s = Math.max(0, -(l * (n = h) + u))) * s +
                    n * (n + 2 * c) +
                    d;
              } else
                a =
                  -(s = Math.max(0, -(l * (n = -h) + u))) * s +
                  n * (n + 2 * c) +
                  d;
            } else
              n <= -o
                ? ((n =
                    (s = Math.max(0, -(-l * h + u))) > 0
                      ? -h
                      : Math.min(Math.max(-h, -c), h)),
                  (a = -s * s + n * (n + 2 * c) + d))
                : n <= o
                ? ((s = 0),
                  (a = (n = Math.min(Math.max(-h, -c), h)) * (n + 2 * c) + d))
                : ((n =
                    (s = Math.max(0, -(l * h + u))) > 0
                      ? h
                      : Math.min(Math.max(-h, -c), h)),
                  (a = -s * s + n * (n + 2 * c) + d));
          } else
            (n = l > 0 ? -h : h),
              (a = -(s = Math.max(0, -(l * n + u))) * s + n * (n + 2 * c) + d);
          return (
            i && i.copy(this.origin).addScaledVector(this.direction, s),
            r && r.copy(i6).addScaledVector(i7, n),
            a
          );
        }
        intersectSphere(t, e) {
          i5.subVectors(t.center, this.origin);
          let i = i5.dot(this.direction),
            r = i5.dot(i5) - i * i,
            s = t.radius * t.radius;
          if (r > s) return null;
          let n = Math.sqrt(s - r),
            a = i - n,
            o = i + n;
          return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          let e = t.normal.dot(this.direction);
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
          let i = -(this.origin.dot(t.normal) + t.constant) / e;
          return i >= 0 ? i : null;
        }
        intersectPlane(t, e) {
          let i = this.distanceToPlane(t);
          return null === i ? null : this.at(i, e);
        }
        intersectsPlane(t) {
          let e = t.distanceToPoint(this.origin);
          if (0 === e) return !0;
          let i = t.normal.dot(this.direction);
          return i * e < 0;
        }
        intersectBox(t, e) {
          let i, r, s, n, a, o;
          let h = 1 / this.direction.x,
            l = 1 / this.direction.y,
            u = 1 / this.direction.z,
            c = this.origin;
          return (h >= 0
            ? ((i = (t.min.x - c.x) * h), (r = (t.max.x - c.x) * h))
            : ((i = (t.max.x - c.x) * h), (r = (t.min.x - c.x) * h)),
          l >= 0
            ? ((s = (t.min.y - c.y) * l), (n = (t.max.y - c.y) * l))
            : ((s = (t.max.y - c.y) * l), (n = (t.min.y - c.y) * l)),
          i > n || s > r)
            ? null
            : ((s > i || isNaN(i)) && (i = s),
              (n < r || isNaN(r)) && (r = n),
              u >= 0
                ? ((a = (t.min.z - c.z) * u), (o = (t.max.z - c.z) * u))
                : ((a = (t.max.z - c.z) * u), (o = (t.min.z - c.z) * u)),
              i > o || a > r)
            ? null
            : ((a > i || i != i) && (i = a),
              (o < r || r != r) && (r = o),
              r < 0)
            ? null
            : this.at(i >= 0 ? i : r, e);
        }
        intersectsBox(t) {
          return null !== this.intersectBox(t, i5);
        }
        intersectTriangle(t, e, i, r, s) {
          let n;
          i9.subVectors(e, t), rt.subVectors(i, t), re.crossVectors(i9, rt);
          let a = this.direction.dot(re);
          if (a > 0) {
            if (r) return null;
            n = 1;
          } else {
            if (!(a < 0)) return null;
            (n = -1), (a = -a);
          }
          i8.subVectors(this.origin, t);
          let o = n * this.direction.dot(rt.crossVectors(i8, rt));
          if (o < 0) return null;
          let h = n * this.direction.dot(i9.cross(i8));
          if (h < 0 || o + h > a) return null;
          let l = -n * i8.dot(re);
          return l < 0 ? null : this.at(l / a, s);
        }
        applyMatrix4(t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          );
        }
        equals(t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      let Matrix4 = class Matrix4 {
        constructor(t, e, i, r, s, n, a, o, h, l, u, c, d, p, m, f) {
          (Matrix4.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            void 0 !== t &&
              this.set(t, e, i, r, s, n, a, o, h, l, u, c, d, p, m, f);
        }
        set(t, e, i, r, s, n, a, o, h, l, u, c, d, p, m, f) {
          let y = this.elements;
          return (
            (y[0] = t),
            (y[4] = e),
            (y[8] = i),
            (y[12] = r),
            (y[1] = s),
            (y[5] = n),
            (y[9] = a),
            (y[13] = o),
            (y[2] = h),
            (y[6] = l),
            (y[10] = u),
            (y[14] = c),
            (y[3] = d),
            (y[7] = p),
            (y[11] = m),
            (y[15] = f),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Matrix4().fromArray(this.elements);
        }
        copy(t) {
          let e = this.elements,
            i = t.elements;
          return (
            (e[0] = i[0]),
            (e[1] = i[1]),
            (e[2] = i[2]),
            (e[3] = i[3]),
            (e[4] = i[4]),
            (e[5] = i[5]),
            (e[6] = i[6]),
            (e[7] = i[7]),
            (e[8] = i[8]),
            (e[9] = i[9]),
            (e[10] = i[10]),
            (e[11] = i[11]),
            (e[12] = i[12]),
            (e[13] = i[13]),
            (e[14] = i[14]),
            (e[15] = i[15]),
            this
          );
        }
        copyPosition(t) {
          let e = this.elements,
            i = t.elements;
          return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this;
        }
        setFromMatrix3(t) {
          let e = t.elements;
          return (
            this.set(
              e[0],
              e[3],
              e[6],
              0,
              e[1],
              e[4],
              e[7],
              0,
              e[2],
              e[5],
              e[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(t, e, i) {
          return (
            t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(t, e, i) {
          return (
            this.set(
              t.x,
              e.x,
              i.x,
              0,
              t.y,
              e.y,
              i.y,
              0,
              t.z,
              e.z,
              i.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(t) {
          let e = this.elements,
            i = t.elements,
            r = 1 / ri.setFromMatrixColumn(t, 0).length(),
            s = 1 / ri.setFromMatrixColumn(t, 1).length(),
            n = 1 / ri.setFromMatrixColumn(t, 2).length();
          return (
            (e[0] = i[0] * r),
            (e[1] = i[1] * r),
            (e[2] = i[2] * r),
            (e[3] = 0),
            (e[4] = i[4] * s),
            (e[5] = i[5] * s),
            (e[6] = i[6] * s),
            (e[7] = 0),
            (e[8] = i[8] * n),
            (e[9] = i[9] * n),
            (e[10] = i[10] * n),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromEuler(t) {
          let e = this.elements,
            i = t.x,
            r = t.y,
            s = t.z,
            n = Math.cos(i),
            a = Math.sin(i),
            o = Math.cos(r),
            h = Math.sin(r),
            l = Math.cos(s),
            u = Math.sin(s);
          if ("XYZ" === t.order) {
            let t = n * l,
              i = n * u,
              r = a * l,
              s = a * u;
            (e[0] = o * l),
              (e[4] = -o * u),
              (e[8] = h),
              (e[1] = i + r * h),
              (e[5] = t - s * h),
              (e[9] = -a * o),
              (e[2] = s - t * h),
              (e[6] = r + i * h),
              (e[10] = n * o);
          } else if ("YXZ" === t.order) {
            let t = o * l,
              i = o * u,
              r = h * l,
              s = h * u;
            (e[0] = t + s * a),
              (e[4] = r * a - i),
              (e[8] = n * h),
              (e[1] = n * u),
              (e[5] = n * l),
              (e[9] = -a),
              (e[2] = i * a - r),
              (e[6] = s + t * a),
              (e[10] = n * o);
          } else if ("ZXY" === t.order) {
            let t = o * l,
              i = o * u,
              r = h * l,
              s = h * u;
            (e[0] = t - s * a),
              (e[4] = -n * u),
              (e[8] = r + i * a),
              (e[1] = i + r * a),
              (e[5] = n * l),
              (e[9] = s - t * a),
              (e[2] = -n * h),
              (e[6] = a),
              (e[10] = n * o);
          } else if ("ZYX" === t.order) {
            let t = n * l,
              i = n * u,
              r = a * l,
              s = a * u;
            (e[0] = o * l),
              (e[4] = r * h - i),
              (e[8] = t * h + s),
              (e[1] = o * u),
              (e[5] = s * h + t),
              (e[9] = i * h - r),
              (e[2] = -h),
              (e[6] = a * o),
              (e[10] = n * o);
          } else if ("YZX" === t.order) {
            let t = n * o,
              i = n * h,
              r = a * o,
              s = a * h;
            (e[0] = o * l),
              (e[4] = s - t * u),
              (e[8] = r * u + i),
              (e[1] = u),
              (e[5] = n * l),
              (e[9] = -a * l),
              (e[2] = -h * l),
              (e[6] = i * u + r),
              (e[10] = t - s * u);
          } else if ("XZY" === t.order) {
            let t = n * o,
              i = n * h,
              r = a * o,
              s = a * h;
            (e[0] = o * l),
              (e[4] = -u),
              (e[8] = h * l),
              (e[1] = t * u + s),
              (e[5] = n * l),
              (e[9] = i * u - r),
              (e[2] = r * u - i),
              (e[6] = a * l),
              (e[10] = s * u + t);
          }
          return (
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(t) {
          return this.compose(rs, t, rn);
        }
        lookAt(t, e, i) {
          let r = this.elements;
          return (
            rh.subVectors(t, e),
            0 === rh.lengthSq() && (rh.z = 1),
            rh.normalize(),
            ra.crossVectors(i, rh),
            0 === ra.lengthSq() &&
              (1 === Math.abs(i.z) ? (rh.x += 1e-4) : (rh.z += 1e-4),
              rh.normalize(),
              ra.crossVectors(i, rh)),
            ra.normalize(),
            ro.crossVectors(rh, ra),
            (r[0] = ra.x),
            (r[4] = ro.x),
            (r[8] = rh.x),
            (r[1] = ra.y),
            (r[5] = ro.y),
            (r[9] = rh.y),
            (r[2] = ra.z),
            (r[6] = ro.z),
            (r[10] = rh.z),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          let i = t.elements,
            r = e.elements,
            s = this.elements,
            n = i[0],
            a = i[4],
            o = i[8],
            h = i[12],
            l = i[1],
            u = i[5],
            c = i[9],
            d = i[13],
            p = i[2],
            m = i[6],
            f = i[10],
            y = i[14],
            g = i[3],
            x = i[7],
            b = i[11],
            M = i[15],
            w = r[0],
            S = r[4],
            A = r[8],
            _ = r[12],
            T = r[1],
            C = r[5],
            z = r[9],
            B = r[13],
            I = r[2],
            V = r[6],
            P = r[10],
            L = r[14],
            k = r[3],
            R = r[7],
            E = r[11],
            O = r[15];
          return (
            (s[0] = n * w + a * T + o * I + h * k),
            (s[4] = n * S + a * C + o * V + h * R),
            (s[8] = n * A + a * z + o * P + h * E),
            (s[12] = n * _ + a * B + o * L + h * O),
            (s[1] = l * w + u * T + c * I + d * k),
            (s[5] = l * S + u * C + c * V + d * R),
            (s[9] = l * A + u * z + c * P + d * E),
            (s[13] = l * _ + u * B + c * L + d * O),
            (s[2] = p * w + m * T + f * I + y * k),
            (s[6] = p * S + m * C + f * V + y * R),
            (s[10] = p * A + m * z + f * P + y * E),
            (s[14] = p * _ + m * B + f * L + y * O),
            (s[3] = g * w + x * T + b * I + M * k),
            (s[7] = g * S + x * C + b * V + M * R),
            (s[11] = g * A + x * z + b * P + M * E),
            (s[15] = g * _ + x * B + b * L + M * O),
            this
          );
        }
        multiplyScalar(t) {
          let e = this.elements;
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          );
        }
        determinant() {
          let t = this.elements,
            e = t[0],
            i = t[4],
            r = t[8],
            s = t[12],
            n = t[1],
            a = t[5],
            o = t[9],
            h = t[13],
            l = t[2],
            u = t[6],
            c = t[10],
            d = t[14],
            p = t[3],
            m = t[7],
            f = t[11],
            y = t[15];
          return (
            p *
              (+s * o * u -
                r * h * u -
                s * a * c +
                i * h * c +
                r * a * d -
                i * o * d) +
            m *
              (+e * o * d -
                e * h * c +
                s * n * c -
                r * n * d +
                r * h * l -
                s * o * l) +
            f *
              (+e * h * u -
                e * a * d -
                s * n * u +
                i * n * d +
                s * a * l -
                i * h * l) +
            y *
              (-r * a * l -
                e * o * u +
                e * a * c +
                r * n * u -
                i * n * c +
                i * o * l)
          );
        }
        transpose() {
          let t;
          let e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(t, e, i) {
          let r = this.elements;
          return (
            t.isVector3
              ? ((r[12] = t.x), (r[13] = t.y), (r[14] = t.z))
              : ((r[12] = t), (r[13] = e), (r[14] = i)),
            this
          );
        }
        invert() {
          let t = this.elements,
            e = t[0],
            i = t[1],
            r = t[2],
            s = t[3],
            n = t[4],
            a = t[5],
            o = t[6],
            h = t[7],
            l = t[8],
            u = t[9],
            c = t[10],
            d = t[11],
            p = t[12],
            m = t[13],
            f = t[14],
            y = t[15],
            g =
              u * f * h -
              m * c * h +
              m * o * d -
              a * f * d -
              u * o * y +
              a * c * y,
            x =
              p * c * h -
              l * f * h -
              p * o * d +
              n * f * d +
              l * o * y -
              n * c * y,
            b =
              l * m * h -
              p * u * h +
              p * a * d -
              n * m * d -
              l * a * y +
              n * u * y,
            M =
              p * u * o -
              l * m * o -
              p * a * c +
              n * m * c +
              l * a * f -
              n * u * f,
            w = e * g + i * x + r * b + s * M;
          if (0 === w)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          let S = 1 / w;
          return (
            (t[0] = g * S),
            (t[1] =
              (m * c * s -
                u * f * s -
                m * r * d +
                i * f * d +
                u * r * y -
                i * c * y) *
              S),
            (t[2] =
              (a * f * s -
                m * o * s +
                m * r * h -
                i * f * h -
                a * r * y +
                i * o * y) *
              S),
            (t[3] =
              (u * o * s -
                a * c * s -
                u * r * h +
                i * c * h +
                a * r * d -
                i * o * d) *
              S),
            (t[4] = x * S),
            (t[5] =
              (l * f * s -
                p * c * s +
                p * r * d -
                e * f * d -
                l * r * y +
                e * c * y) *
              S),
            (t[6] =
              (p * o * s -
                n * f * s -
                p * r * h +
                e * f * h +
                n * r * y -
                e * o * y) *
              S),
            (t[7] =
              (n * c * s -
                l * o * s +
                l * r * h -
                e * c * h -
                n * r * d +
                e * o * d) *
              S),
            (t[8] = b * S),
            (t[9] =
              (p * u * s -
                l * m * s -
                p * i * d +
                e * m * d +
                l * i * y -
                e * u * y) *
              S),
            (t[10] =
              (n * m * s -
                p * a * s +
                p * i * h -
                e * m * h -
                n * i * y +
                e * a * y) *
              S),
            (t[11] =
              (l * a * s -
                n * u * s -
                l * i * h +
                e * u * h +
                n * i * d -
                e * a * d) *
              S),
            (t[12] = M * S),
            (t[13] =
              (l * m * r -
                p * u * r +
                p * i * c -
                e * m * c -
                l * i * f +
                e * u * f) *
              S),
            (t[14] =
              (p * a * r -
                n * m * r -
                p * i * o +
                e * m * o +
                n * i * f -
                e * a * f) *
              S),
            (t[15] =
              (n * u * r -
                l * a * r +
                l * i * o -
                e * u * o -
                n * i * c +
                e * a * c) *
              S),
            this
          );
        }
        scale(t) {
          let e = this.elements,
            i = t.x,
            r = t.y,
            s = t.z;
          return (
            (e[0] *= i),
            (e[4] *= r),
            (e[8] *= s),
            (e[1] *= i),
            (e[5] *= r),
            (e[9] *= s),
            (e[2] *= i),
            (e[6] *= r),
            (e[10] *= s),
            (e[3] *= i),
            (e[7] *= r),
            (e[11] *= s),
            this
          );
        }
        getMaxScaleOnAxis() {
          let t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, i, r));
        }
        makeTranslation(t, e, i) {
          return (
            t.isVector3
              ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
              : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1),
            this
          );
        }
        makeRotationX(t) {
          let e = Math.cos(t),
            i = Math.sin(t);
          return (
            this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(t) {
          let e = Math.cos(t),
            i = Math.sin(t);
          return (
            this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(t) {
          let e = Math.cos(t),
            i = Math.sin(t);
          return (
            this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(t, e) {
          let i = Math.cos(e),
            r = Math.sin(e),
            s = 1 - i,
            n = t.x,
            a = t.y,
            o = t.z,
            h = s * n,
            l = s * a;
          return (
            this.set(
              h * n + i,
              h * a - r * o,
              h * o + r * a,
              0,
              h * a + r * o,
              l * a + i,
              l * o - r * n,
              0,
              h * o - r * a,
              l * o + r * n,
              s * o * o + i,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(t, e, i) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, i, r, s, n) {
          return this.set(1, i, s, 0, t, 1, n, 0, e, r, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, i) {
          let r = this.elements,
            s = e._x,
            n = e._y,
            a = e._z,
            o = e._w,
            h = s + s,
            l = n + n,
            u = a + a,
            c = s * h,
            d = s * l,
            p = s * u,
            m = n * l,
            f = n * u,
            y = a * u,
            g = o * h,
            x = o * l,
            b = o * u,
            M = i.x,
            w = i.y,
            S = i.z;
          return (
            (r[0] = (1 - (m + y)) * M),
            (r[1] = (d + b) * M),
            (r[2] = (p - x) * M),
            (r[3] = 0),
            (r[4] = (d - b) * w),
            (r[5] = (1 - (c + y)) * w),
            (r[6] = (f + g) * w),
            (r[7] = 0),
            (r[8] = (p + x) * S),
            (r[9] = (f - g) * S),
            (r[10] = (1 - (c + m)) * S),
            (r[11] = 0),
            (r[12] = t.x),
            (r[13] = t.y),
            (r[14] = t.z),
            (r[15] = 1),
            this
          );
        }
        decompose(t, e, i) {
          let r = this.elements,
            s = ri.set(r[0], r[1], r[2]).length(),
            n = ri.set(r[4], r[5], r[6]).length(),
            a = ri.set(r[8], r[9], r[10]).length(),
            o = this.determinant();
          o < 0 && (s = -s),
            (t.x = r[12]),
            (t.y = r[13]),
            (t.z = r[14]),
            rr.copy(this);
          let h = 1 / s,
            l = 1 / n,
            u = 1 / a;
          return (
            (rr.elements[0] *= h),
            (rr.elements[1] *= h),
            (rr.elements[2] *= h),
            (rr.elements[4] *= l),
            (rr.elements[5] *= l),
            (rr.elements[6] *= l),
            (rr.elements[8] *= u),
            (rr.elements[9] *= u),
            (rr.elements[10] *= u),
            e.setFromRotationMatrix(rr),
            (i.x = s),
            (i.y = n),
            (i.z = a),
            this
          );
        }
        makePerspective(t, e, i, r, s, n, a = iT) {
          let o, h;
          let l = this.elements;
          if (a === iT) (o = -(n + s) / (n - s)), (h = (-2 * n * s) / (n - s));
          else if (a === iC) (o = -n / (n - s)), (h = (-n * s) / (n - s));
          else
            throw Error(
              "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
            );
          return (
            (l[0] = (2 * s) / (e - t)),
            (l[4] = 0),
            (l[8] = (e + t) / (e - t)),
            (l[12] = 0),
            (l[1] = 0),
            (l[5] = (2 * s) / (i - r)),
            (l[9] = (i + r) / (i - r)),
            (l[13] = 0),
            (l[2] = 0),
            (l[6] = 0),
            (l[10] = o),
            (l[14] = h),
            (l[3] = 0),
            (l[7] = 0),
            (l[11] = -1),
            (l[15] = 0),
            this
          );
        }
        makeOrthographic(t, e, i, r, s, n, a = iT) {
          let o, h;
          let l = this.elements,
            u = 1 / (e - t),
            c = 1 / (i - r),
            d = 1 / (n - s);
          if (a === iT) (o = (n + s) * d), (h = -2 * d);
          else if (a === iC) (o = s * d), (h = -1 * d);
          else
            throw Error(
              "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                a
            );
          return (
            (l[0] = 2 * u),
            (l[4] = 0),
            (l[8] = 0),
            (l[12] = -((e + t) * u)),
            (l[1] = 0),
            (l[5] = 2 * c),
            (l[9] = 0),
            (l[13] = -((i + r) * c)),
            (l[2] = 0),
            (l[6] = 0),
            (l[10] = h),
            (l[14] = -o),
            (l[3] = 0),
            (l[7] = 0),
            (l[11] = 0),
            (l[15] = 1),
            this
          );
        }
        equals(t) {
          let e = this.elements,
            i = t.elements;
          for (let t = 0; t < 16; t++) if (e[t] !== i[t]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
          return this;
        }
        toArray(t = [], e = 0) {
          let i = this.elements;
          return (
            (t[e] = i[0]),
            (t[e + 1] = i[1]),
            (t[e + 2] = i[2]),
            (t[e + 3] = i[3]),
            (t[e + 4] = i[4]),
            (t[e + 5] = i[5]),
            (t[e + 6] = i[6]),
            (t[e + 7] = i[7]),
            (t[e + 8] = i[8]),
            (t[e + 9] = i[9]),
            (t[e + 10] = i[10]),
            (t[e + 11] = i[11]),
            (t[e + 12] = i[12]),
            (t[e + 13] = i[13]),
            (t[e + 14] = i[14]),
            (t[e + 15] = i[15]),
            t
          );
        }
      };
      let ri = new Vector3(),
        rr = new Matrix4(),
        rs = new Vector3(0, 0, 0),
        rn = new Vector3(1, 1, 1),
        ra = new Vector3(),
        ro = new Vector3(),
        rh = new Vector3(),
        rl = new Matrix4(),
        ru = new Quaternion();
      let Euler = class Euler {
        constructor(t = 0, e = 0, i = 0, r = Euler.DEFAULT_ORDER) {
          (this.isEuler = !0),
            (this._x = t),
            (this._y = e),
            (this._z = i),
            (this._order = r);
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          (this._order = t), this._onChangeCallback();
        }
        set(t, e, i, r = this._order) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = i),
            (this._order = r),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t, e = this._order, i = !0) {
          let r = t.elements,
            s = r[0],
            n = r[4],
            a = r[8],
            o = r[1],
            h = r[5],
            l = r[9],
            u = r[2],
            c = r[6],
            d = r[10];
          switch (e) {
            case "XYZ":
              (this._y = Math.asin(clamp(a, -1, 1))),
                0.9999999 > Math.abs(a)
                  ? ((this._x = Math.atan2(-l, d)),
                    (this._z = Math.atan2(-n, s)))
                  : ((this._x = Math.atan2(c, h)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-clamp(l, -1, 1))),
                0.9999999 > Math.abs(l)
                  ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, h)))
                  : ((this._y = Math.atan2(-u, s)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(clamp(c, -1, 1))),
                0.9999999 > Math.abs(c)
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-n, h)))
                  : ((this._y = 0), (this._z = Math.atan2(o, s)));
              break;
            case "ZYX":
              (this._y = Math.asin(-clamp(u, -1, 1))),
                0.9999999 > Math.abs(u)
                  ? ((this._x = Math.atan2(c, d)), (this._z = Math.atan2(o, s)))
                  : ((this._x = 0), (this._z = Math.atan2(-n, h)));
              break;
            case "YZX":
              (this._z = Math.asin(clamp(o, -1, 1))),
                0.9999999 > Math.abs(o)
                  ? ((this._x = Math.atan2(-l, h)),
                    (this._y = Math.atan2(-u, s)))
                  : ((this._x = 0), (this._y = Math.atan2(a, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-clamp(n, -1, 1))),
                0.9999999 > Math.abs(n)
                  ? ((this._x = Math.atan2(c, h)), (this._y = Math.atan2(a, s)))
                  : ((this._x = Math.atan2(-l, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  e
              );
          }
          return (this._order = e), !0 === i && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, i) {
          return (
            rl.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(rl, e, i)
          );
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
          return ru.setFromEuler(this), this.setFromQuaternion(ru, t);
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        }
        fromArray(t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      };
      Euler.DEFAULT_ORDER = "XYZ";
      let Layers = class Layers {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = ((1 << t) | 0) >>> 0;
        }
        enable(t) {
          this.mask |= (1 << t) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= (1 << t) | 0;
        }
        disable(t) {
          this.mask &= ~((1 << t) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return (this.mask & t.mask) != 0;
        }
        isEnabled(t) {
          return (this.mask & ((1 << t) | 0)) != 0;
        }
      };
      let rc = 0,
        rd = new Vector3(),
        rp = new Quaternion(),
        rm = new Matrix4(),
        rf = new Vector3(),
        ry = new Vector3(),
        rg = new Vector3(),
        rx = new Quaternion(),
        rb = new Vector3(1, 0, 0),
        rv = new Vector3(0, 1, 0),
        rM = new Vector3(0, 0, 1),
        rw = { type: "added" },
        rS = { type: "removed" },
        rA = { type: "childadded", child: null },
        r_ = { type: "childremoved", child: null };
      let Object3D = class Object3D extends EventDispatcher {
        constructor() {
          super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, "id", { value: rc++ }),
            (this.uuid = generateUUID()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Object3D.DEFAULT_UP.clone());
          let t = new Vector3(),
            e = new Euler(),
            i = new Quaternion(),
            r = new Vector3(1, 1, 1);
          e._onChange(function () {
            i.setFromEuler(e, !1);
          }),
            i._onChange(function () {
              e.setFromQuaternion(i, void 0, !1);
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: i },
              scale: { configurable: !0, enumerable: !0, value: r },
              modelViewMatrix: { value: new Matrix4() },
              normalMatrix: { value: new Matrix3() },
            }),
            (this.matrix = new Matrix4()),
            (this.matrixWorld = new Matrix4()),
            (this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE),
            (this.matrixWorldAutoUpdate =
              Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Layers()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, !0);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
          return rp.setFromAxisAngle(t, e), this.quaternion.multiply(rp), this;
        }
        rotateOnWorldAxis(t, e) {
          return (
            rp.setFromAxisAngle(t, e), this.quaternion.premultiply(rp), this
          );
        }
        rotateX(t) {
          return this.rotateOnAxis(rb, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(rv, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(rM, t);
        }
        translateOnAxis(t, e) {
          return (
            rd.copy(t).applyQuaternion(this.quaternion),
            this.position.add(rd.multiplyScalar(e)),
            this
          );
        }
        translateX(t) {
          return this.translateOnAxis(rb, t);
        }
        translateY(t) {
          return this.translateOnAxis(rv, t);
        }
        translateZ(t) {
          return this.translateOnAxis(rM, t);
        }
        localToWorld(t) {
          return (
            this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
          );
        }
        worldToLocal(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.applyMatrix4(rm.copy(this.matrixWorld).invert())
          );
        }
        lookAt(t, e, i) {
          t.isVector3 ? rf.copy(t) : rf.set(t, e, i);
          let r = this.parent;
          this.updateWorldMatrix(!0, !1),
            ry.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? rm.lookAt(ry, rf, this.up)
              : rm.lookAt(rf, ry, this.up),
            this.quaternion.setFromRotationMatrix(rm),
            r &&
              (rm.extractRotation(r.matrixWorld),
              rp.setFromRotationMatrix(rm),
              this.quaternion.premultiply(rp.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return (
            t === this
              ? console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t
                )
              : t && t.isObject3D
              ? (t.removeFromParent(),
                (t.parent = this),
                this.children.push(t),
                t.dispatchEvent(rw),
                (rA.child = t),
                this.dispatchEvent(rA),
                (rA.child = null))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  t
                ),
            this
          );
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
              this.remove(arguments[t]);
            return this;
          }
          let e = this.children.indexOf(t);
          return (
            -1 !== e &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(rS),
              (r_.child = t),
              this.dispatchEvent(r_),
              (r_.child = null)),
            this
          );
        }
        removeFromParent() {
          let t = this.parent;
          return null !== t && t.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            rm.copy(this.matrixWorld).invert(),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              rm.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(rm),
            t.removeFromParent(),
            (t.parent = this),
            this.children.push(t),
            t.updateWorldMatrix(!1, !0),
            t.dispatchEvent(rw),
            (rA.child = t),
            this.dispatchEvent(rA),
            (rA.child = null),
            this
          );
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this;
          for (let i = 0, r = this.children.length; i < r; i++) {
            let r = this.children[i],
              s = r.getObjectByProperty(t, e);
            if (void 0 !== s) return s;
          }
        }
        getObjectsByProperty(t, e, i = []) {
          this[t] === e && i.push(this);
          let r = this.children;
          for (let s = 0, n = r.length; s < n; s++)
            r[s].getObjectsByProperty(t, e, i);
          return i;
        }
        getWorldPosition(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(ry, t, rg),
            t
          );
        }
        getWorldScale(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(ry, rx, t),
            t
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          let e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {}
        traverse(t) {
          t(this);
          let e = this.children;
          for (let i = 0, r = e.length; i < r; i++) e[i].traverse(t);
        }
        traverseVisible(t) {
          if (!1 === this.visible) return;
          t(this);
          let e = this.children;
          for (let i = 0, r = e.length; i < r; i++) e[i].traverseVisible(t);
        }
        traverseAncestors(t) {
          let e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (!0 === this.matrixWorldAutoUpdate &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    )),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          let e = this.children;
          for (let i = 0, r = e.length; i < r; i++) {
            let r = e[i];
            r.updateMatrixWorld(t);
          }
        }
        updateWorldMatrix(t, e) {
          let i = this.parent;
          if (
            (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            !0 === this.matrixWorldAutoUpdate &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  )),
            !0 === e)
          ) {
            let t = this.children;
            for (let e = 0, i = t.length; e < i; e++) {
              let i = t[e];
              i.updateWorldMatrix(!1, !0);
            }
          }
        }
        toJSON(t) {
          let e = void 0 === t || "string" == typeof t,
            i = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (i.metadata = {
              version: 4.6,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          let r = {};
          function serialize(e, i) {
            return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid;
          }
          if (
            ((r.uuid = this.uuid),
            (r.type = this.type),
            "" !== this.name && (r.name = this.name),
            !0 === this.castShadow && (r.castShadow = !0),
            !0 === this.receiveShadow && (r.receiveShadow = !0),
            !1 === this.visible && (r.visible = !1),
            !1 === this.frustumCulled && (r.frustumCulled = !1),
            0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 &&
              (r.userData = this.userData),
            (r.layers = this.layers.mask),
            (r.matrix = this.matrix.toArray()),
            (r.up = this.up.toArray()),
            !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((r.type = "InstancedMesh"),
              (r.count = this.count),
              (r.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (r.instanceColor = this.instanceColor.toJSON())),
            this.isBatchedMesh &&
              ((r.type = "BatchedMesh"),
              (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
              (r.sortObjects = this.sortObjects),
              (r.drawRanges = this._drawRanges),
              (r.reservedRanges = this._reservedRanges),
              (r.visibility = this._visibility),
              (r.active = this._active),
              (r.bounds = this._bounds.map((t) => ({
                boxInitialized: t.boxInitialized,
                boxMin: t.box.min.toArray(),
                boxMax: t.box.max.toArray(),
                sphereInitialized: t.sphereInitialized,
                sphereRadius: t.sphere.radius,
                sphereCenter: t.sphere.center.toArray(),
              }))),
              (r.maxInstanceCount = this._maxInstanceCount),
              (r.maxVertexCount = this._maxVertexCount),
              (r.maxIndexCount = this._maxIndexCount),
              (r.geometryInitialized = this._geometryInitialized),
              (r.geometryCount = this._geometryCount),
              (r.matricesTexture = this._matricesTexture.toJSON(t)),
              null !== this._colorsTexture &&
                (r.colorsTexture = this._colorsTexture.toJSON(t)),
              null !== this.boundingSphere &&
                (r.boundingSphere = {
                  center: r.boundingSphere.center.toArray(),
                  radius: r.boundingSphere.radius,
                }),
              null !== this.boundingBox &&
                (r.boundingBox = {
                  min: r.boundingBox.min.toArray(),
                  max: r.boundingBox.max.toArray(),
                })),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (r.background = this.background.toJSON())
                : this.background.isTexture &&
                  (r.background = this.background.toJSON(t).uuid)),
              this.environment &&
                this.environment.isTexture &&
                !0 !== this.environment.isRenderTargetTexture &&
                (r.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = serialize(t.geometries, this.geometry);
            let e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
              let i = e.shapes;
              if (Array.isArray(i))
                for (let e = 0, r = i.length; e < r; e++) {
                  let r = i[e];
                  serialize(t.shapes, r);
                }
              else serialize(t.shapes, i);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((r.bindMode = this.bindMode),
              (r.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (serialize(t.skeletons, this.skeleton),
                (r.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          ) {
            if (Array.isArray(this.material)) {
              let e = [];
              for (let i = 0, r = this.material.length; i < r; i++)
                e.push(serialize(t.materials, this.material[i]));
              r.material = e;
            } else r.material = serialize(t.materials, this.material);
          }
          if (this.children.length > 0) {
            r.children = [];
            for (let e = 0; e < this.children.length; e++)
              r.children.push(this.children[e].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            r.animations = [];
            for (let e = 0; e < this.animations.length; e++) {
              let i = this.animations[e];
              r.animations.push(serialize(t.animations, i));
            }
          }
          if (e) {
            let e = extractFromCache(t.geometries),
              r = extractFromCache(t.materials),
              s = extractFromCache(t.textures),
              n = extractFromCache(t.images),
              a = extractFromCache(t.shapes),
              o = extractFromCache(t.skeletons),
              h = extractFromCache(t.animations),
              l = extractFromCache(t.nodes);
            e.length > 0 && (i.geometries = e),
              r.length > 0 && (i.materials = r),
              s.length > 0 && (i.textures = s),
              n.length > 0 && (i.images = n),
              a.length > 0 && (i.shapes = a),
              o.length > 0 && (i.skeletons = o),
              h.length > 0 && (i.animations = h),
              l.length > 0 && (i.nodes = l);
          }
          return (i.object = r), i;
          function extractFromCache(t) {
            let e = [];
            for (let i in t) {
              let r = t[i];
              delete r.metadata, e.push(r);
            }
            return e;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, e = !0) {
          if (
            ((this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.animations = t.animations.slice()),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let e = 0; e < t.children.length; e++) {
              let i = t.children[e];
              this.add(i.clone());
            }
          return this;
        }
      };
      (Object3D.DEFAULT_UP = new Vector3(0, 1, 0)),
        (Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0),
        (Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
      let rT = new Vector3(),
        rC = new Vector3(),
        rz = new Vector3(),
        rB = new Vector3(),
        rI = new Vector3(),
        rV = new Vector3(),
        rP = new Vector3(),
        rL = new Vector3(),
        rk = new Vector3(),
        rR = new Vector3(),
        rE = new Vector4(),
        rO = new Vector4(),
        rF = new Vector4();
      let Triangle = class Triangle {
        constructor(t = new Vector3(), e = new Vector3(), i = new Vector3()) {
          (this.a = t), (this.b = e), (this.c = i);
        }
        static getNormal(t, e, i, r) {
          r.subVectors(i, e), rT.subVectors(t, e), r.cross(rT);
          let s = r.lengthSq();
          return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
        }
        static getBarycoord(t, e, i, r, s) {
          rT.subVectors(r, e), rC.subVectors(i, e), rz.subVectors(t, e);
          let n = rT.dot(rT),
            a = rT.dot(rC),
            o = rT.dot(rz),
            h = rC.dot(rC),
            l = rC.dot(rz),
            u = n * h - a * a;
          if (0 === u) return s.set(0, 0, 0), null;
          let c = 1 / u,
            d = (h * o - a * l) * c,
            p = (n * l - a * o) * c;
          return s.set(1 - d - p, p, d);
        }
        static containsPoint(t, e, i, r) {
          return (
            null !== this.getBarycoord(t, e, i, r, rB) &&
            rB.x >= 0 &&
            rB.y >= 0 &&
            rB.x + rB.y <= 1
          );
        }
        static getInterpolation(t, e, i, r, s, n, a, o) {
          return null === this.getBarycoord(t, e, i, r, rB)
            ? ((o.x = 0),
              (o.y = 0),
              "z" in o && (o.z = 0),
              "w" in o && (o.w = 0),
              null)
            : (o.setScalar(0),
              o.addScaledVector(s, rB.x),
              o.addScaledVector(n, rB.y),
              o.addScaledVector(a, rB.z),
              o);
        }
        static getInterpolatedAttribute(t, e, i, r, s, n) {
          return (
            rE.setScalar(0),
            rO.setScalar(0),
            rF.setScalar(0),
            rE.fromBufferAttribute(t, e),
            rO.fromBufferAttribute(t, i),
            rF.fromBufferAttribute(t, r),
            n.setScalar(0),
            n.addScaledVector(rE, s.x),
            n.addScaledVector(rO, s.y),
            n.addScaledVector(rF, s.z),
            n
          );
        }
        static isFrontFacing(t, e, i, r) {
          return (
            rT.subVectors(i, e), rC.subVectors(t, e), 0 > rT.cross(rC).dot(r)
          );
        }
        set(t, e, i) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
        }
        setFromPointsAndIndices(t, e, i, r) {
          return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[r]), this;
        }
        setFromAttributeAndIndices(t, e, i, r) {
          return (
            this.a.fromBufferAttribute(t, e),
            this.b.fromBufferAttribute(t, i),
            this.c.fromBufferAttribute(t, r),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return (
            rT.subVectors(this.c, this.b),
            rC.subVectors(this.a, this.b),
            0.5 * rT.cross(rC).length()
          );
        }
        getMidpoint(t) {
          return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return Triangle.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
          return Triangle.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getInterpolation(t, e, i, r, s) {
          return Triangle.getInterpolation(
            t,
            this.a,
            this.b,
            this.c,
            e,
            i,
            r,
            s
          );
        }
        containsPoint(t) {
          return Triangle.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return Triangle.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
          let i, r;
          let s = this.a,
            n = this.b,
            a = this.c;
          rI.subVectors(n, s), rV.subVectors(a, s), rL.subVectors(t, s);
          let o = rI.dot(rL),
            h = rV.dot(rL);
          if (o <= 0 && h <= 0) return e.copy(s);
          rk.subVectors(t, n);
          let l = rI.dot(rk),
            u = rV.dot(rk);
          if (l >= 0 && u <= l) return e.copy(n);
          let c = o * u - l * h;
          if (c <= 0 && o >= 0 && l <= 0)
            return (i = o / (o - l)), e.copy(s).addScaledVector(rI, i);
          rR.subVectors(t, a);
          let d = rI.dot(rR),
            p = rV.dot(rR);
          if (p >= 0 && d <= p) return e.copy(a);
          let m = d * h - o * p;
          if (m <= 0 && h >= 0 && p <= 0)
            return (r = h / (h - p)), e.copy(s).addScaledVector(rV, r);
          let f = l * p - d * u;
          if (f <= 0 && u - l >= 0 && d - p >= 0)
            return (
              rP.subVectors(a, n),
              (r = (u - l) / (u - l + (d - p))),
              e.copy(n).addScaledVector(rP, r)
            );
          let y = 1 / (f + m + c);
          return (
            (i = m * y),
            (r = c * y),
            e.copy(s).addScaledVector(rI, i).addScaledVector(rV, r)
          );
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      };
      let rN = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        rD = { h: 0, s: 0, l: 0 },
        rU = { h: 0, s: 0, l: 0 };
      function hue2rgb(t, e, i) {
        return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6)
          ? t + (e - t) * 6 * i
          : i < 0.5
          ? e
          : i < 2 / 3
          ? t + (e - t) * 6 * (2 / 3 - i)
          : t;
      }
      let Color = class Color {
        constructor(t, e, i) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            this.set(t, e, i)
          );
        }
        set(t, e, i) {
          return (
            void 0 === e && void 0 === i
              ? t && t.isColor
                ? this.copy(t)
                : "number" == typeof t
                ? this.setHex(t)
                : "string" == typeof t && this.setStyle(t)
              : this.setRGB(t, e, i),
            this
          );
        }
        setScalar(t) {
          return (this.r = t), (this.g = t), (this.b = t), this;
        }
        setHex(t, e = eX) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (255 & t) / 255),
            iF.toWorkingColorSpace(this, e),
            this
          );
        }
        setRGB(t, e, i, r = iF.workingColorSpace) {
          return (
            (this.r = t),
            (this.g = e),
            (this.b = i),
            iF.toWorkingColorSpace(this, r),
            this
          );
        }
        setHSL(t, e, i, r = iF.workingColorSpace) {
          if (
            ((t = euclideanModulo(t, 1)),
            (e = clamp(e, 0, 1)),
            (i = clamp(i, 0, 1)),
            0 === e)
          )
            this.r = this.g = this.b = i;
          else {
            let r = i <= 0.5 ? i * (1 + e) : i + e - i * e,
              s = 2 * i - r;
            (this.r = hue2rgb(s, r, t + 1 / 3)),
              (this.g = hue2rgb(s, r, t)),
              (this.b = hue2rgb(s, r, t - 1 / 3));
          }
          return iF.toWorkingColorSpace(this, r), this;
        }
        setStyle(t, e = eX) {
          let i;
          function handleAlpha(e) {
            void 0 !== e &&
              1 > parseFloat(e) &&
              console.warn(
                "THREE.Color: Alpha component of " + t + " will be ignored."
              );
          }
          if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
            let r;
            let s = i[1],
              n = i[2];
            switch (s) {
              case "rgb":
              case "rgba":
                if (
                  (r =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      n
                    ))
                )
                  return (
                    handleAlpha(r[4]),
                    this.setRGB(
                      Math.min(255, parseInt(r[1], 10)) / 255,
                      Math.min(255, parseInt(r[2], 10)) / 255,
                      Math.min(255, parseInt(r[3], 10)) / 255,
                      e
                    )
                  );
                if (
                  (r =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      n
                    ))
                )
                  return (
                    handleAlpha(r[4]),
                    this.setRGB(
                      Math.min(100, parseInt(r[1], 10)) / 100,
                      Math.min(100, parseInt(r[2], 10)) / 100,
                      Math.min(100, parseInt(r[3], 10)) / 100,
                      e
                    )
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (r =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      n
                    ))
                )
                  return (
                    handleAlpha(r[4]),
                    this.setHSL(
                      parseFloat(r[1]) / 360,
                      parseFloat(r[2]) / 100,
                      parseFloat(r[3]) / 100,
                      e
                    )
                  );
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + t);
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
            let r = i[1],
              s = r.length;
            if (3 === s)
              return this.setRGB(
                parseInt(r.charAt(0), 16) / 15,
                parseInt(r.charAt(1), 16) / 15,
                parseInt(r.charAt(2), 16) / 15,
                e
              );
            if (6 === s) return this.setHex(parseInt(r, 16), e);
            console.warn("THREE.Color: Invalid hex color " + t);
          } else if (t && t.length > 0) return this.setColorName(t, e);
          return this;
        }
        setColorName(t, e = eX) {
          let i = rN[t.toLowerCase()];
          return (
            void 0 !== i
              ? this.setHex(i, e)
              : console.warn("THREE.Color: Unknown color " + t),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
        }
        copySRGBToLinear(t) {
          return (
            (this.r = SRGBToLinear(t.r)),
            (this.g = SRGBToLinear(t.g)),
            (this.b = SRGBToLinear(t.b)),
            this
          );
        }
        copyLinearToSRGB(t) {
          return (
            (this.r = LinearToSRGB(t.r)),
            (this.g = LinearToSRGB(t.g)),
            (this.b = LinearToSRGB(t.b)),
            this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(t = eX) {
          return (
            iF.fromWorkingColorSpace(rG.copy(this), t),
            65536 * Math.round(clamp(255 * rG.r, 0, 255)) +
              256 * Math.round(clamp(255 * rG.g, 0, 255)) +
              Math.round(clamp(255 * rG.b, 0, 255))
          );
        }
        getHexString(t = eX) {
          return ("000000" + this.getHex(t).toString(16)).slice(-6);
        }
        getHSL(t, e = iF.workingColorSpace) {
          let i, r;
          iF.fromWorkingColorSpace(rG.copy(this), e);
          let s = rG.r,
            n = rG.g,
            a = rG.b,
            o = Math.max(s, n, a),
            h = Math.min(s, n, a),
            l = (h + o) / 2;
          if (h === o) (i = 0), (r = 0);
          else {
            let t = o - h;
            switch (((r = l <= 0.5 ? t / (o + h) : t / (2 - o - h)), o)) {
              case s:
                i = (n - a) / t + (n < a ? 6 : 0);
                break;
              case n:
                i = (a - s) / t + 2;
                break;
              case a:
                i = (s - n) / t + 4;
            }
            i /= 6;
          }
          return (t.h = i), (t.s = r), (t.l = l), t;
        }
        getRGB(t, e = iF.workingColorSpace) {
          return (
            iF.fromWorkingColorSpace(rG.copy(this), e),
            (t.r = rG.r),
            (t.g = rG.g),
            (t.b = rG.b),
            t
          );
        }
        getStyle(t = eX) {
          iF.fromWorkingColorSpace(rG.copy(this), t);
          let e = rG.r,
            i = rG.g,
            r = rG.b;
          return t !== eX
            ? `color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
            : `rgb(${Math.round(255 * e)},${Math.round(255 * i)},${Math.round(
                255 * r
              )})`;
        }
        offsetHSL(t, e, i) {
          return this.getHSL(rD), this.setHSL(rD.h + t, rD.s + e, rD.l + i);
        }
        add(t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
        }
        addColors(t, e) {
          return (
            (this.r = t.r + e.r),
            (this.g = t.g + e.g),
            (this.b = t.b + e.b),
            this
          );
        }
        addScalar(t) {
          return (this.r += t), (this.g += t), (this.b += t), this;
        }
        sub(t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          );
        }
        multiply(t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
        }
        multiplyScalar(t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this;
        }
        lerp(t, e) {
          return (
            (this.r += (t.r - this.r) * e),
            (this.g += (t.g - this.g) * e),
            (this.b += (t.b - this.b) * e),
            this
          );
        }
        lerpColors(t, e, i) {
          return (
            (this.r = t.r + (e.r - t.r) * i),
            (this.g = t.g + (e.g - t.g) * i),
            (this.b = t.b + (e.b - t.b) * i),
            this
          );
        }
        lerpHSL(t, e) {
          this.getHSL(rD), t.getHSL(rU);
          let i = lerp(rD.h, rU.h, e),
            r = lerp(rD.s, rU.s, e),
            s = lerp(rD.l, rU.l, e);
          return this.setHSL(i, r, s), this;
        }
        setFromVector3(t) {
          return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
        }
        applyMatrix3(t) {
          let e = this.r,
            i = this.g,
            r = this.b,
            s = t.elements;
          return (
            (this.r = s[0] * e + s[3] * i + s[6] * r),
            (this.g = s[1] * e + s[4] * i + s[7] * r),
            (this.b = s[2] * e + s[5] * i + s[8] * r),
            this
          );
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
          return (
            (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.r = t.getX(e)),
            (this.g = t.getY(e)),
            (this.b = t.getZ(e)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      };
      let rG = new Color();
      Color.NAMES = rN;
      let rj = 0;
      let Material = class Material extends EventDispatcher {
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", { value: rj++ }),
            (this.uuid = generateUUID()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = A),
            (this.side = b),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = F),
            (this.blendDst = N),
            (this.blendEquation = B),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.blendColor = new Color(0, 0, 0)),
            (this.blendAlpha = 0),
            (this.depthFunc = K),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = is),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = e0),
            (this.stencilZFail = e0),
            (this.stencilZPass = e0),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t) {
          this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (void 0 !== t)
            for (let e in t) {
              let i = t[e];
              if (void 0 === i) {
                console.warn(
                  `THREE.Material: parameter '${e}' has value of undefined.`
                );
                continue;
              }
              let r = this[e];
              if (void 0 === r) {
                console.warn(
                  `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
                );
                continue;
              }
              r && r.isColor
                ? r.set(i)
                : r && r.isVector3 && i && i.isVector3
                ? r.copy(i)
                : (this[e] = i);
            }
        }
        toJSON(t) {
          let e = void 0 === t || "string" == typeof t;
          e && (t = { textures: {}, images: {} });
          let i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function extractFromCache(t) {
            let e = [];
            for (let i in t) {
              let r = t[i];
              delete r.metadata, e.push(r);
            }
            return e;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            void 0 !== this.sheen && (i.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (i.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (i.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (i.emissive = this.emissive.getHex()),
            void 0 !== this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (i.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (i.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (i.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (i.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (i.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
              (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            void 0 !== this.dispersion && (i.dispersion = this.dispersion),
            void 0 !== this.iridescence && (i.iridescence = this.iridescence),
            void 0 !== this.iridescenceIOR &&
              (i.iridescenceIOR = this.iridescenceIOR),
            void 0 !== this.iridescenceThicknessRange &&
              (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
              this.iridescenceMap.isTexture &&
              (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
            this.iridescenceThicknessMap &&
              this.iridescenceThicknessMap.isTexture &&
              (i.iridescenceThicknessMap =
                this.iridescenceThicknessMap.toJSON(t).uuid),
            void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy),
            void 0 !== this.anisotropyRotation &&
              (i.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
              this.anisotropyMap.isTexture &&
              (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (i.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (i.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((i.lightMap = this.lightMap.toJSON(t).uuid),
              (i.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((i.aoMap = this.aoMap.toJSON(t).uuid),
              (i.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((i.bumpMap = this.bumpMap.toJSON(t).uuid),
              (i.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((i.normalMap = this.normalMap.toJSON(t).uuid),
              (i.normalMapType = this.normalMapType),
              (i.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
              (i.displacementScale = this.displacementScale),
              (i.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (i.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (i.specularIntensityMap =
                this.specularIntensityMap.toJSON(t).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (i.specularColorMap = this.specularColorMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((i.envMap = this.envMap.toJSON(t).uuid),
              void 0 !== this.combine && (i.combine = this.combine)),
            void 0 !== this.envMapRotation &&
              (i.envMapRotation = this.envMapRotation.toArray()),
            void 0 !== this.envMapIntensity &&
              (i.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (i.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (i.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (i.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.transmission &&
              (i.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (i.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            void 0 !== this.thickness && (i.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (i.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            void 0 !== this.attenuationDistance &&
              this.attenuationDistance !== 1 / 0 &&
              (i.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (i.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (i.size = this.size),
            null !== this.shadowSide && (i.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (i.sizeAttenuation = this.sizeAttenuation),
            this.blending !== A && (i.blending = this.blending),
            this.side !== b && (i.side = this.side),
            !0 === this.vertexColors && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = !0),
            this.blendSrc !== F && (i.blendSrc = this.blendSrc),
            this.blendDst !== N && (i.blendDst = this.blendDst),
            this.blendEquation !== B && (i.blendEquation = this.blendEquation),
            null !== this.blendSrcAlpha &&
              (i.blendSrcAlpha = this.blendSrcAlpha),
            null !== this.blendDstAlpha &&
              (i.blendDstAlpha = this.blendDstAlpha),
            null !== this.blendEquationAlpha &&
              (i.blendEquationAlpha = this.blendEquationAlpha),
            this.blendColor &&
              this.blendColor.isColor &&
              (i.blendColor = this.blendColor.getHex()),
            0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha),
            this.depthFunc !== K && (i.depthFunc = this.depthFunc),
            !1 === this.depthTest && (i.depthTest = this.depthTest),
            !1 === this.depthWrite && (i.depthWrite = this.depthWrite),
            !1 === this.colorWrite && (i.colorWrite = this.colorWrite),
            255 !== this.stencilWriteMask &&
              (i.stencilWriteMask = this.stencilWriteMask),
            this.stencilFunc !== is && (i.stencilFunc = this.stencilFunc),
            0 !== this.stencilRef && (i.stencilRef = this.stencilRef),
            255 !== this.stencilFuncMask &&
              (i.stencilFuncMask = this.stencilFuncMask),
            this.stencilFail !== e0 && (i.stencilFail = this.stencilFail),
            this.stencilZFail !== e0 && (i.stencilZFail = this.stencilZFail),
            this.stencilZPass !== e0 && (i.stencilZPass = this.stencilZPass),
            !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite),
            void 0 !== this.rotation &&
              0 !== this.rotation &&
              (i.rotation = this.rotation),
            !0 === this.polygonOffset && (i.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (i.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (i.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth &&
              1 !== this.linewidth &&
              (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            !0 === this.alphaHash && (i.alphaHash = !0),
            !0 === this.alphaToCoverage && (i.alphaToCoverage = !0),
            !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0),
            !0 === this.forceSinglePass && (i.forceSinglePass = !0),
            !0 === this.wireframe && (i.wireframe = !0),
            this.wireframeLinewidth > 1 &&
              (i.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (i.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (i.flatShading = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.toneMapped && (i.toneMapped = !1),
            !1 === this.fog && (i.fog = !1),
            Object.keys(this.userData).length > 0 &&
              (i.userData = this.userData),
            e)
          ) {
            let e = extractFromCache(t.textures),
              r = extractFromCache(t.images);
            e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.name = t.name),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            this.blendColor.copy(t.blendColor),
            (this.blendAlpha = t.blendAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.stencilWriteMask = t.stencilWriteMask),
            (this.stencilFunc = t.stencilFunc),
            (this.stencilRef = t.stencilRef),
            (this.stencilFuncMask = t.stencilFuncMask),
            (this.stencilFail = t.stencilFail),
            (this.stencilZFail = t.stencilZFail),
            (this.stencilZPass = t.stencilZPass),
            (this.stencilWrite = t.stencilWrite);
          let e = t.clippingPlanes,
            i = null;
          if (null !== e) {
            let t = e.length;
            i = Array(t);
            for (let r = 0; r !== t; ++r) i[r] = e[r].clone();
          }
          return (
            (this.clippingPlanes = i),
            (this.clipIntersection = t.clipIntersection),
            (this.clipShadows = t.clipShadows),
            (this.shadowSide = t.shadowSide),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.alphaHash = t.alphaHash),
            (this.alphaToCoverage = t.alphaToCoverage),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.forceSinglePass = t.forceSinglePass),
            (this.visible = t.visible),
            (this.toneMapped = t.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      };
      let MeshBasicMaterial = class MeshBasicMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Color(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new Euler()),
            (this.combine = tr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            this.envMapRotation.copy(t.envMapRotation),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.fog = t.fog),
            this
          );
        }
      };
      let rW = (function () {
        let t = new ArrayBuffer(4),
          e = new Float32Array(t),
          i = new Uint32Array(t),
          r = new Uint32Array(512),
          s = new Uint32Array(512);
        for (let t = 0; t < 256; ++t) {
          let e = t - 127;
          e < -27
            ? ((r[t] = 0), (r[256 | t] = 32768), (s[t] = 24), (s[256 | t] = 24))
            : e < -14
            ? ((r[t] = 1024 >> (-e - 14)),
              (r[256 | t] = (1024 >> (-e - 14)) | 32768),
              (s[t] = -e - 1),
              (s[256 | t] = -e - 1))
            : e <= 15
            ? ((r[t] = (e + 15) << 10),
              (r[256 | t] = ((e + 15) << 10) | 32768),
              (s[t] = 13),
              (s[256 | t] = 13))
            : e < 128
            ? ((r[t] = 31744),
              (r[256 | t] = 64512),
              (s[t] = 24),
              (s[256 | t] = 24))
            : ((r[t] = 31744),
              (r[256 | t] = 64512),
              (s[t] = 13),
              (s[256 | t] = 13));
        }
        let n = new Uint32Array(2048),
          a = new Uint32Array(64),
          o = new Uint32Array(64);
        for (let t = 1; t < 1024; ++t) {
          let e = t << 13,
            i = 0;
          for (; (8388608 & e) == 0; ) (e <<= 1), (i -= 8388608);
          (e &= -8388609), (i += 947912704), (n[t] = e | i);
        }
        for (let t = 1024; t < 2048; ++t) n[t] = 939524096 + ((t - 1024) << 13);
        for (let t = 1; t < 31; ++t) a[t] = t << 23;
        (a[31] = 1199570944), (a[32] = 2147483648);
        for (let t = 33; t < 63; ++t) a[t] = 2147483648 + ((t - 32) << 23);
        a[63] = 3347054592;
        for (let t = 1; t < 64; ++t) 32 !== t && (o[t] = 1024);
        return {
          floatView: e,
          uint32View: i,
          baseTable: r,
          shiftTable: s,
          mantissaTable: n,
          exponentTable: a,
          offsetTable: o,
        };
      })();
      function toHalfFloat(t) {
        Math.abs(t) > 65504 &&
          console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
          (t = clamp(t, -65504, 65504)),
          (rW.floatView[0] = t);
        let e = rW.uint32View[0],
          i = (e >> 23) & 511;
        return rW.baseTable[i] + ((8388607 & e) >> rW.shiftTable[i]);
      }
      function fromHalfFloat(t) {
        let e = t >> 10;
        return (
          (rW.uint32View[0] =
            rW.mantissaTable[rW.offsetTable[e] + (1023 & t)] +
            rW.exponentTable[e]),
          rW.floatView[0]
        );
      }
      let rH = { toHalfFloat: toHalfFloat, fromHalfFloat: fromHalfFloat },
        rq = new Vector3(),
        rJ = new Vector2();
      let BufferAttribute = class BufferAttribute {
        constructor(t, e, i = !1) {
          if (Array.isArray(t))
            throw TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.isBufferAttribute = !0),
            (this.name = ""),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = i),
            (this.usage = im),
            (this.updateRanges = []),
            (this.gpuType = tU),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        addUpdateRange(t, e) {
          this.updateRanges.push({ start: t, count: e });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            (this.gpuType = t.gpuType),
            this
          );
        }
        copyAt(t, e, i) {
          (t *= this.itemSize), (i *= e.itemSize);
          for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[t + r] = e.array[i + r];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        applyMatrix3(t) {
          if (2 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++)
              rJ.fromBufferAttribute(this, e),
                rJ.applyMatrix3(t),
                this.setXY(e, rJ.x, rJ.y);
          else if (3 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++)
              rq.fromBufferAttribute(this, e),
                rq.applyMatrix3(t),
                this.setXYZ(e, rq.x, rq.y, rq.z);
          return this;
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.count; e < i; e++)
            rq.fromBufferAttribute(this, e),
              rq.applyMatrix4(t),
              this.setXYZ(e, rq.x, rq.y, rq.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++)
            rq.fromBufferAttribute(this, e),
              rq.applyNormalMatrix(t),
              this.setXYZ(e, rq.x, rq.y, rq.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++)
            rq.fromBufferAttribute(this, e),
              rq.transformDirection(t),
              this.setXYZ(e, rq.x, rq.y, rq.z);
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        getComponent(t, e) {
          let i = this.array[t * this.itemSize + e];
          return this.normalized && (i = denormalize(i, this.array)), i;
        }
        setComponent(t, e, i) {
          return (
            this.normalized && (i = normalize(i, this.array)),
            (this.array[t * this.itemSize + e] = i),
            this
          );
        }
        getX(t) {
          let e = this.array[t * this.itemSize];
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setX(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.array[t * this.itemSize] = e),
            this
          );
        }
        getY(t) {
          let e = this.array[t * this.itemSize + 1];
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setY(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.array[t * this.itemSize + 1] = e),
            this
          );
        }
        getZ(t) {
          let e = this.array[t * this.itemSize + 2];
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setZ(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.array[t * this.itemSize + 2] = e),
            this
          );
        }
        getW(t) {
          let e = this.array[t * this.itemSize + 3];
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setW(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.array[t * this.itemSize + 3] = e),
            this
          );
        }
        setXY(t, e, i) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = normalize(e, this.array)), (i = normalize(i, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            this
          );
        }
        setXYZ(t, e, i, r) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = normalize(e, this.array)),
              (i = normalize(i, this.array)),
              (r = normalize(r, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            (this.array[t + 2] = r),
            this
          );
        }
        setXYZW(t, e, i, r, s) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = normalize(e, this.array)),
              (i = normalize(i, this.array)),
              (r = normalize(r, this.array)),
              (s = normalize(s, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = i),
            (this.array[t + 2] = r),
            (this.array[t + 3] = s),
            this
          );
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          let t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (t.name = this.name),
            this.usage !== im && (t.usage = this.usage),
            t
          );
        }
      };
      let Int8BufferAttribute = class Int8BufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Int8Array(t), e, i);
        }
      };
      let Uint8BufferAttribute = class Uint8BufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Uint8Array(t), e, i);
        }
      };
      let Uint8ClampedBufferAttribute = class Uint8ClampedBufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Uint8ClampedArray(t), e, i);
        }
      };
      let Int16BufferAttribute = class Int16BufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Int16Array(t), e, i);
        }
      };
      let Uint16BufferAttribute = class Uint16BufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Uint16Array(t), e, i);
        }
      };
      let Int32BufferAttribute = class Int32BufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Int32Array(t), e, i);
        }
      };
      let Uint32BufferAttribute = class Uint32BufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Uint32Array(t), e, i);
        }
      };
      let Float16BufferAttribute = class Float16BufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Uint16Array(t), e, i), (this.isFloat16BufferAttribute = !0);
        }
        getX(t) {
          let e = fromHalfFloat(this.array[t * this.itemSize]);
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setX(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.array[t * this.itemSize] = toHalfFloat(e)),
            this
          );
        }
        getY(t) {
          let e = fromHalfFloat(this.array[t * this.itemSize + 1]);
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setY(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.array[t * this.itemSize + 1] = toHalfFloat(e)),
            this
          );
        }
        getZ(t) {
          let e = fromHalfFloat(this.array[t * this.itemSize + 2]);
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setZ(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.array[t * this.itemSize + 2] = toHalfFloat(e)),
            this
          );
        }
        getW(t) {
          let e = fromHalfFloat(this.array[t * this.itemSize + 3]);
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setW(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.array[t * this.itemSize + 3] = toHalfFloat(e)),
            this
          );
        }
        setXY(t, e, i) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = normalize(e, this.array)), (i = normalize(i, this.array))),
            (this.array[t + 0] = toHalfFloat(e)),
            (this.array[t + 1] = toHalfFloat(i)),
            this
          );
        }
        setXYZ(t, e, i, r) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = normalize(e, this.array)),
              (i = normalize(i, this.array)),
              (r = normalize(r, this.array))),
            (this.array[t + 0] = toHalfFloat(e)),
            (this.array[t + 1] = toHalfFloat(i)),
            (this.array[t + 2] = toHalfFloat(r)),
            this
          );
        }
        setXYZW(t, e, i, r, s) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = normalize(e, this.array)),
              (i = normalize(i, this.array)),
              (r = normalize(r, this.array)),
              (s = normalize(s, this.array))),
            (this.array[t + 0] = toHalfFloat(e)),
            (this.array[t + 1] = toHalfFloat(i)),
            (this.array[t + 2] = toHalfFloat(r)),
            (this.array[t + 3] = toHalfFloat(s)),
            this
          );
        }
      };
      let Float32BufferAttribute = class Float32BufferAttribute extends BufferAttribute {
        constructor(t, e, i) {
          super(new Float32Array(t), e, i);
        }
      };
      let rZ = 0,
        rX = new Matrix4(),
        rY = new Object3D(),
        rQ = new Vector3(),
        rK = new Box3(),
        r$ = new Box3(),
        r0 = new Vector3();
      let BufferGeometry = class BufferGeometry extends EventDispatcher {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", { value: rZ++ }),
            (this.uuid = generateUUID()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.indirect = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return (
            Array.isArray(t)
              ? (this.index = new (
                  arrayNeedsUint32(t)
                    ? Uint32BufferAttribute
                    : Uint16BufferAttribute
                )(t, 1))
              : (this.index = t),
            this
          );
        }
        setIndirect(t) {
          return (this.indirect = t), this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, e) {
          return (this.attributes[t] = e), this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return void 0 !== this.attributes[t];
        }
        addGroup(t, e, i = 0) {
          this.groups.push({ start: t, count: e, materialIndex: i });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, e) {
          (this.drawRange.start = t), (this.drawRange.count = e);
        }
        applyMatrix4(t) {
          let e = this.attributes.position;
          void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
          let i = this.attributes.normal;
          if (void 0 !== i) {
            let e = new Matrix3().getNormalMatrix(t);
            i.applyNormalMatrix(e), (i.needsUpdate = !0);
          }
          let r = this.attributes.tangent;
          return (
            void 0 !== r && (r.transformDirection(t), (r.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(t) {
          return rX.makeRotationFromQuaternion(t), this.applyMatrix4(rX), this;
        }
        rotateX(t) {
          return rX.makeRotationX(t), this.applyMatrix4(rX), this;
        }
        rotateY(t) {
          return rX.makeRotationY(t), this.applyMatrix4(rX), this;
        }
        rotateZ(t) {
          return rX.makeRotationZ(t), this.applyMatrix4(rX), this;
        }
        translate(t, e, i) {
          return rX.makeTranslation(t, e, i), this.applyMatrix4(rX), this;
        }
        scale(t, e, i) {
          return rX.makeScale(t, e, i), this.applyMatrix4(rX), this;
        }
        lookAt(t) {
          return (
            rY.lookAt(t), rY.updateMatrix(), this.applyMatrix4(rY.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(rQ).negate(),
            this.translate(rQ.x, rQ.y, rQ.z),
            this
          );
        }
        setFromPoints(t) {
          let e = this.getAttribute("position");
          if (void 0 === e) {
            let e = [];
            for (let i = 0, r = t.length; i < r; i++) {
              let r = t[i];
              e.push(r.x, r.y, r.z || 0);
            }
            this.setAttribute("position", new Float32BufferAttribute(e, 3));
          } else {
            let i = Math.min(t.length, e.count);
            for (let r = 0; r < i; r++) {
              let i = t[r];
              e.setXYZ(r, i.x, i.y, i.z || 0);
            }
            t.length > e.count &&
              console.warn(
                "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
              ),
              (e.needsUpdate = !0);
          }
          return this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Box3());
          let t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error(
              "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
              this
            ),
              this.boundingBox.set(
                new Vector3(-1 / 0, -1 / 0, -1 / 0),
                new Vector3(Infinity, Infinity, Infinity)
              );
            return;
          }
          if (void 0 !== t) {
            if ((this.boundingBox.setFromBufferAttribute(t), e))
              for (let t = 0, i = e.length; t < i; t++) {
                let i = e[t];
                rK.setFromBufferAttribute(i),
                  this.morphTargetsRelative
                    ? (r0.addVectors(this.boundingBox.min, rK.min),
                      this.boundingBox.expandByPoint(r0),
                      r0.addVectors(this.boundingBox.max, rK.max),
                      this.boundingBox.expandByPoint(r0))
                    : (this.boundingBox.expandByPoint(rK.min),
                      this.boundingBox.expandByPoint(rK.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Sphere());
          let t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error(
              "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
              this
            ),
              this.boundingSphere.set(new Vector3(), 1 / 0);
            return;
          }
          if (t) {
            let i = this.boundingSphere.center;
            if ((rK.setFromBufferAttribute(t), e))
              for (let t = 0, i = e.length; t < i; t++) {
                let i = e[t];
                r$.setFromBufferAttribute(i),
                  this.morphTargetsRelative
                    ? (r0.addVectors(rK.min, r$.min),
                      rK.expandByPoint(r0),
                      r0.addVectors(rK.max, r$.max),
                      rK.expandByPoint(r0))
                    : (rK.expandByPoint(r$.min), rK.expandByPoint(r$.max));
              }
            rK.getCenter(i);
            let r = 0;
            for (let e = 0, s = t.count; e < s; e++)
              r0.fromBufferAttribute(t, e),
                (r = Math.max(r, i.distanceToSquared(r0)));
            if (e)
              for (let s = 0, n = e.length; s < n; s++) {
                let n = e[s],
                  a = this.morphTargetsRelative;
                for (let e = 0, s = n.count; e < s; e++)
                  r0.fromBufferAttribute(n, e),
                    a && (rQ.fromBufferAttribute(t, e), r0.add(rQ)),
                    (r = Math.max(r, i.distanceToSquared(r0)));
              }
            (this.boundingSphere.radius = Math.sqrt(r)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          let t = this.index,
            e = this.attributes;
          if (
            null === t ||
            void 0 === e.position ||
            void 0 === e.normal ||
            void 0 === e.uv
          ) {
            console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
            return;
          }
          let i = e.position,
            r = e.normal,
            s = e.uv;
          !1 === this.hasAttribute("tangent") &&
            this.setAttribute(
              "tangent",
              new BufferAttribute(new Float32Array(4 * i.count), 4)
            );
          let n = this.getAttribute("tangent"),
            a = [],
            o = [];
          for (let t = 0; t < i.count; t++)
            (a[t] = new Vector3()), (o[t] = new Vector3());
          let h = new Vector3(),
            l = new Vector3(),
            u = new Vector3(),
            c = new Vector2(),
            d = new Vector2(),
            p = new Vector2(),
            m = new Vector3(),
            f = new Vector3(),
            y = this.groups;
          0 === y.length && (y = [{ start: 0, count: t.count }]);
          for (let e = 0, r = y.length; e < r; ++e) {
            let r = y[e],
              n = r.start,
              g = r.count;
            for (let e = n, r = n + g; e < r; e += 3)
              !(function (t, e, r) {
                h.fromBufferAttribute(i, t),
                  l.fromBufferAttribute(i, e),
                  u.fromBufferAttribute(i, r),
                  c.fromBufferAttribute(s, t),
                  d.fromBufferAttribute(s, e),
                  p.fromBufferAttribute(s, r),
                  l.sub(h),
                  u.sub(h),
                  d.sub(c),
                  p.sub(c);
                let n = 1 / (d.x * p.y - p.x * d.y);
                isFinite(n) &&
                  (m
                    .copy(l)
                    .multiplyScalar(p.y)
                    .addScaledVector(u, -d.y)
                    .multiplyScalar(n),
                  f
                    .copy(u)
                    .multiplyScalar(d.x)
                    .addScaledVector(l, -p.x)
                    .multiplyScalar(n),
                  a[t].add(m),
                  a[e].add(m),
                  a[r].add(m),
                  o[t].add(f),
                  o[e].add(f),
                  o[r].add(f));
              })(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2));
          }
          let g = new Vector3(),
            x = new Vector3(),
            b = new Vector3(),
            M = new Vector3();
          function handleVertex(t) {
            b.fromBufferAttribute(r, t), M.copy(b);
            let e = a[t];
            g.copy(e),
              g.sub(b.multiplyScalar(b.dot(e))).normalize(),
              x.crossVectors(M, e);
            let i = x.dot(o[t]);
            n.setXYZW(t, g.x, g.y, g.z, i < 0 ? -1 : 1);
          }
          for (let e = 0, i = y.length; e < i; ++e) {
            let i = y[e],
              r = i.start,
              s = i.count;
            for (let e = r, i = r + s; e < i; e += 3)
              handleVertex(t.getX(e + 0)),
                handleVertex(t.getX(e + 1)),
                handleVertex(t.getX(e + 2));
          }
        }
        computeVertexNormals() {
          let t = this.index,
            e = this.getAttribute("position");
          if (void 0 !== e) {
            let i = this.getAttribute("normal");
            if (void 0 === i)
              (i = new BufferAttribute(new Float32Array(3 * e.count), 3)),
                this.setAttribute("normal", i);
            else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
            let r = new Vector3(),
              s = new Vector3(),
              n = new Vector3(),
              a = new Vector3(),
              o = new Vector3(),
              h = new Vector3(),
              l = new Vector3(),
              u = new Vector3();
            if (t)
              for (let c = 0, d = t.count; c < d; c += 3) {
                let d = t.getX(c + 0),
                  p = t.getX(c + 1),
                  m = t.getX(c + 2);
                r.fromBufferAttribute(e, d),
                  s.fromBufferAttribute(e, p),
                  n.fromBufferAttribute(e, m),
                  l.subVectors(n, s),
                  u.subVectors(r, s),
                  l.cross(u),
                  a.fromBufferAttribute(i, d),
                  o.fromBufferAttribute(i, p),
                  h.fromBufferAttribute(i, m),
                  a.add(l),
                  o.add(l),
                  h.add(l),
                  i.setXYZ(d, a.x, a.y, a.z),
                  i.setXYZ(p, o.x, o.y, o.z),
                  i.setXYZ(m, h.x, h.y, h.z);
              }
            else
              for (let t = 0, a = e.count; t < a; t += 3)
                r.fromBufferAttribute(e, t + 0),
                  s.fromBufferAttribute(e, t + 1),
                  n.fromBufferAttribute(e, t + 2),
                  l.subVectors(n, s),
                  u.subVectors(r, s),
                  l.cross(u),
                  i.setXYZ(t + 0, l.x, l.y, l.z),
                  i.setXYZ(t + 1, l.x, l.y, l.z),
                  i.setXYZ(t + 2, l.x, l.y, l.z);
            this.normalizeNormals(), (i.needsUpdate = !0);
          }
        }
        normalizeNormals() {
          let t = this.attributes.normal;
          for (let e = 0, i = t.count; e < i; e++)
            r0.fromBufferAttribute(t, e),
              r0.normalize(),
              t.setXYZ(e, r0.x, r0.y, r0.z);
        }
        toNonIndexed() {
          function convertBufferAttribute(t, e) {
            let i = t.array,
              r = t.itemSize,
              s = t.normalized,
              n = new i.constructor(e.length * r),
              a = 0,
              o = 0;
            for (let s = 0, h = e.length; s < h; s++) {
              a = t.isInterleavedBufferAttribute
                ? e[s] * t.data.stride + t.offset
                : e[s] * r;
              for (let t = 0; t < r; t++) n[o++] = i[a++];
            }
            return new BufferAttribute(n, r, s);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          let t = new BufferGeometry(),
            e = this.index.array,
            i = this.attributes;
          for (let r in i) {
            let s = i[r],
              n = convertBufferAttribute(s, e);
            t.setAttribute(r, n);
          }
          let r = this.morphAttributes;
          for (let i in r) {
            let s = [],
              n = r[i];
            for (let t = 0, i = n.length; t < i; t++) {
              let i = n[t],
                r = convertBufferAttribute(i, e);
              s.push(r);
            }
            t.morphAttributes[i] = s;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          let s = this.groups;
          for (let e = 0, i = s.length; e < i; e++) {
            let i = s[e];
            t.addGroup(i.start, i.count, i.materialIndex);
          }
          return t;
        }
        toJSON() {
          let t = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (t.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            let e = this.parameters;
            for (let i in e) void 0 !== e[i] && (t[i] = e[i]);
            return t;
          }
          t.data = { attributes: {} };
          let e = this.index;
          null !== e &&
            (t.data.index = {
              type: e.array.constructor.name,
              array: Array.prototype.slice.call(e.array),
            });
          let i = this.attributes;
          for (let e in i) {
            let r = i[e];
            t.data.attributes[e] = r.toJSON(t.data);
          }
          let r = {},
            s = !1;
          for (let e in this.morphAttributes) {
            let i = this.morphAttributes[e],
              n = [];
            for (let e = 0, r = i.length; e < r; e++) {
              let r = i[e];
              n.push(r.toJSON(t.data));
            }
            n.length > 0 && ((r[e] = n), (s = !0));
          }
          s &&
            ((t.data.morphAttributes = r),
            (t.data.morphTargetsRelative = this.morphTargetsRelative));
          let n = this.groups;
          n.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(n)));
          let a = this.boundingSphere;
          return (
            null !== a &&
              (t.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            t
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          let e = {};
          this.name = t.name;
          let i = t.index;
          null !== i && this.setIndex(i.clone(e));
          let r = t.attributes;
          for (let t in r) {
            let i = r[t];
            this.setAttribute(t, i.clone(e));
          }
          let s = t.morphAttributes;
          for (let t in s) {
            let i = [],
              r = s[t];
            for (let t = 0, s = r.length; t < s; t++) i.push(r[t].clone(e));
            this.morphAttributes[t] = i;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          let n = t.groups;
          for (let t = 0, e = n.length; t < e; t++) {
            let e = n[t];
            this.addGroup(e.start, e.count, e.materialIndex);
          }
          let a = t.boundingBox;
          null !== a && (this.boundingBox = a.clone());
          let o = t.boundingSphere;
          return (
            null !== o && (this.boundingSphere = o.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      let r1 = new Matrix4(),
        r3 = new Ray(),
        r2 = new Sphere(),
        r4 = new Vector3(),
        r5 = new Vector3(),
        r6 = new Vector3(),
        r7 = new Vector3(),
        r8 = new Vector3(),
        r9 = new Vector3(),
        st = new Vector3(),
        se = new Vector3();
      let Mesh = class Mesh extends Object3D {
        constructor(t = new BufferGeometry(), e = new MeshBasicMaterial()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            void 0 !== t.morphTargetInfluences &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary
              )),
            (this.material = Array.isArray(t.material)
              ? t.material.slice()
              : t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        updateMorphTargets() {
          let t = this.geometry,
            e = t.morphAttributes,
            i = Object.keys(e);
          if (i.length > 0) {
            let t = e[i[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, i = t.length; e < i; e++) {
                let i = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[i] = e);
              }
            }
          }
        }
        getVertexPosition(t, e) {
          let i = this.geometry,
            r = i.attributes.position,
            s = i.morphAttributes.position,
            n = i.morphTargetsRelative;
          e.fromBufferAttribute(r, t);
          let a = this.morphTargetInfluences;
          if (s && a) {
            r9.set(0, 0, 0);
            for (let i = 0, r = s.length; i < r; i++) {
              let r = a[i],
                o = s[i];
              0 !== r &&
                (r8.fromBufferAttribute(o, t),
                n
                  ? r9.addScaledVector(r8, r)
                  : r9.addScaledVector(r8.sub(e), r));
            }
            e.add(r9);
          }
          return e;
        }
        raycast(t, e) {
          let i = this.geometry,
            r = this.material,
            s = this.matrixWorld;
          if (void 0 !== r) {
            if (
              (null === i.boundingSphere && i.computeBoundingSphere(),
              r2.copy(i.boundingSphere),
              r2.applyMatrix4(s),
              r3.copy(t.ray).recast(t.near),
              (!1 === r2.containsPoint(r3.origin) &&
                (null === r3.intersectSphere(r2, r4) ||
                  r3.origin.distanceToSquared(r4) > (t.far - t.near) ** 2)) ||
                (r1.copy(s).invert(),
                r3.copy(t.ray).applyMatrix4(r1),
                null !== i.boundingBox &&
                  !1 === r3.intersectsBox(i.boundingBox)))
            )
              return;
            this._computeIntersections(t, e, r3);
          }
        }
        _computeIntersections(t, e, i) {
          let r;
          let s = this.geometry,
            n = this.material,
            a = s.index,
            o = s.attributes.position,
            h = s.attributes.uv,
            l = s.attributes.uv1,
            u = s.attributes.normal,
            c = s.groups,
            d = s.drawRange;
          if (null !== a) {
            if (Array.isArray(n))
              for (let s = 0, o = c.length; s < o; s++) {
                let o = c[s],
                  p = n[o.materialIndex],
                  m = Math.max(o.start, d.start),
                  f = Math.min(
                    a.count,
                    Math.min(o.start + o.count, d.start + d.count)
                  );
                for (let s = m; s < f; s += 3) {
                  let n = a.getX(s),
                    c = a.getX(s + 1),
                    d = a.getX(s + 2);
                  (r = checkGeometryIntersection(
                    this,
                    p,
                    t,
                    i,
                    h,
                    l,
                    u,
                    n,
                    c,
                    d
                  )) &&
                    ((r.faceIndex = Math.floor(s / 3)),
                    (r.face.materialIndex = o.materialIndex),
                    e.push(r));
                }
              }
            else {
              let s = Math.max(0, d.start),
                o = Math.min(a.count, d.start + d.count);
              for (let c = s; c < o; c += 3) {
                let s = a.getX(c),
                  o = a.getX(c + 1),
                  d = a.getX(c + 2);
                (r = checkGeometryIntersection(
                  this,
                  n,
                  t,
                  i,
                  h,
                  l,
                  u,
                  s,
                  o,
                  d
                )) && ((r.faceIndex = Math.floor(c / 3)), e.push(r));
              }
            }
          } else if (void 0 !== o) {
            if (Array.isArray(n))
              for (let s = 0, a = c.length; s < a; s++) {
                let a = c[s],
                  p = n[a.materialIndex],
                  m = Math.max(a.start, d.start),
                  f = Math.min(
                    o.count,
                    Math.min(a.start + a.count, d.start + d.count)
                  );
                for (let s = m; s < f; s += 3) {
                  let n = s,
                    o = s + 1,
                    c = s + 2;
                  (r = checkGeometryIntersection(
                    this,
                    p,
                    t,
                    i,
                    h,
                    l,
                    u,
                    n,
                    o,
                    c
                  )) &&
                    ((r.faceIndex = Math.floor(s / 3)),
                    (r.face.materialIndex = a.materialIndex),
                    e.push(r));
                }
              }
            else {
              let s = Math.max(0, d.start),
                a = Math.min(o.count, d.start + d.count);
              for (let o = s; o < a; o += 3) {
                let s = o,
                  a = o + 1,
                  c = o + 2;
                (r = checkGeometryIntersection(
                  this,
                  n,
                  t,
                  i,
                  h,
                  l,
                  u,
                  s,
                  a,
                  c
                )) && ((r.faceIndex = Math.floor(o / 3)), e.push(r));
              }
            }
          }
        }
      };
      function checkGeometryIntersection(t, e, i, r, s, n, a, o, h, l) {
        t.getVertexPosition(o, r5),
          t.getVertexPosition(h, r6),
          t.getVertexPosition(l, r7);
        let u = (function (t, e, i, r, s, n, a, o) {
          if (
            null ===
            (e.side === M
              ? r.intersectTriangle(a, n, s, !0, o)
              : r.intersectTriangle(s, n, a, e.side === b, o))
          )
            return null;
          se.copy(o), se.applyMatrix4(t.matrixWorld);
          let h = i.ray.origin.distanceTo(se);
          return h < i.near || h > i.far
            ? null
            : { distance: h, point: se.clone(), object: t };
        })(t, e, i, r, r5, r6, r7, st);
        if (u) {
          let t = new Vector3();
          Triangle.getBarycoord(st, r5, r6, r7, t),
            s &&
              (u.uv = Triangle.getInterpolatedAttribute(
                s,
                o,
                h,
                l,
                t,
                new Vector2()
              )),
            n &&
              (u.uv1 = Triangle.getInterpolatedAttribute(
                n,
                o,
                h,
                l,
                t,
                new Vector2()
              )),
            a &&
              ((u.normal = Triangle.getInterpolatedAttribute(
                a,
                o,
                h,
                l,
                t,
                new Vector3()
              )),
              u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
          let e = { a: o, b: h, c: l, normal: new Vector3(), materialIndex: 0 };
          Triangle.getNormal(r5, r6, r7, e.normal),
            (u.face = e),
            (u.barycoord = t);
        }
        return u;
      }
      let BoxGeometry = class BoxGeometry extends BufferGeometry {
        constructor(t = 1, e = 1, i = 1, r = 1, s = 1, n = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: i,
              widthSegments: r,
              heightSegments: s,
              depthSegments: n,
            });
          let a = this;
          (r = Math.floor(r)), (s = Math.floor(s)), (n = Math.floor(n));
          let o = [],
            h = [],
            l = [],
            u = [],
            c = 0,
            d = 0;
          function buildPlane(t, e, i, r, s, n, p, m, f, y, g) {
            let x = n / f,
              b = p / y,
              M = n / 2,
              w = p / 2,
              S = m / 2,
              A = f + 1,
              _ = y + 1,
              T = 0,
              C = 0,
              z = new Vector3();
            for (let n = 0; n < _; n++) {
              let a = n * b - w;
              for (let o = 0; o < A; o++) {
                let c = o * x - M;
                (z[t] = c * r),
                  (z[e] = a * s),
                  (z[i] = S),
                  h.push(z.x, z.y, z.z),
                  (z[t] = 0),
                  (z[e] = 0),
                  (z[i] = m > 0 ? 1 : -1),
                  l.push(z.x, z.y, z.z),
                  u.push(o / f),
                  u.push(1 - n / y),
                  (T += 1);
              }
            }
            for (let t = 0; t < y; t++)
              for (let e = 0; e < f; e++) {
                let i = c + e + A * t,
                  r = c + e + A * (t + 1),
                  s = c + (e + 1) + A * (t + 1),
                  n = c + (e + 1) + A * t;
                o.push(i, r, n), o.push(r, s, n), (C += 6);
              }
            a.addGroup(d, C, g), (d += C), (c += T);
          }
          buildPlane("z", "y", "x", -1, -1, i, e, t, n, s, 0),
            buildPlane("z", "y", "x", 1, -1, i, e, -t, n, s, 1),
            buildPlane("x", "z", "y", 1, 1, t, i, e, r, n, 2),
            buildPlane("x", "z", "y", 1, -1, t, i, -e, r, n, 3),
            buildPlane("x", "y", "z", 1, -1, t, e, i, r, s, 4),
            buildPlane("x", "y", "z", -1, -1, t, e, -i, r, s, 5),
            this.setIndex(o),
            this.setAttribute("position", new Float32BufferAttribute(h, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(l, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(u, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new BoxGeometry(
            t.width,
            t.height,
            t.depth,
            t.widthSegments,
            t.heightSegments,
            t.depthSegments
          );
        }
      };
      function cloneUniforms(t) {
        let e = {};
        for (let i in t)
          for (let r in ((e[i] = {}), t[i])) {
            let s = t[i][r];
            s &&
            (s.isColor ||
              s.isMatrix3 ||
              s.isMatrix4 ||
              s.isVector2 ||
              s.isVector3 ||
              s.isVector4 ||
              s.isTexture ||
              s.isQuaternion)
              ? s.isRenderTargetTexture
                ? (console.warn(
                    "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                  ),
                  (e[i][r] = null))
                : (e[i][r] = s.clone())
              : Array.isArray(s)
              ? (e[i][r] = s.slice())
              : (e[i][r] = s);
          }
        return e;
      }
      function mergeUniforms(t) {
        let e = {};
        for (let i = 0; i < t.length; i++) {
          let r = cloneUniforms(t[i]);
          for (let t in r) e[t] = r[t];
        }
        return e;
      }
      function getUnlitUniformColorSpace(t) {
        let e = t.getRenderTarget();
        return null === e
          ? t.outputColorSpace
          : !0 === e.isXRRenderTarget
          ? e.texture.colorSpace
          : iF.workingColorSpace;
      }
      let si = { clone: cloneUniforms, merge: mergeUniforms };
      let ShaderMaterial = class ShaderMaterial extends Material {
        constructor(t) {
          super(),
            (this.isShaderMaterial = !0),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader =
              "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv1: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t && this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = cloneUniforms(t.uniforms)),
            (this.uniformsGroups = (function (t) {
              let e = [];
              for (let i = 0; i < t.length; i++) e.push(t[i].clone());
              return e;
            })(t.uniformsGroups)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.fog = t.fog),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.extensions = Object.assign({}, t.extensions)),
            (this.glslVersion = t.glslVersion),
            this
          );
        }
        toJSON(t) {
          let e = super.toJSON(t);
          for (let i in ((e.glslVersion = this.glslVersion),
          (e.uniforms = {}),
          this.uniforms)) {
            let r = this.uniforms[i],
              s = r.value;
            s && s.isTexture
              ? (e.uniforms[i] = { type: "t", value: s.toJSON(t).uuid })
              : s && s.isColor
              ? (e.uniforms[i] = { type: "c", value: s.getHex() })
              : s && s.isVector2
              ? (e.uniforms[i] = { type: "v2", value: s.toArray() })
              : s && s.isVector3
              ? (e.uniforms[i] = { type: "v3", value: s.toArray() })
              : s && s.isVector4
              ? (e.uniforms[i] = { type: "v4", value: s.toArray() })
              : s && s.isMatrix3
              ? (e.uniforms[i] = { type: "m3", value: s.toArray() })
              : s && s.isMatrix4
              ? (e.uniforms[i] = { type: "m4", value: s.toArray() })
              : (e.uniforms[i] = { value: s });
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader),
            (e.lights = this.lights),
            (e.clipping = this.clipping);
          let i = {};
          for (let t in this.extensions)
            !0 === this.extensions[t] && (i[t] = !0);
          return Object.keys(i).length > 0 && (e.extensions = i), e;
        }
      };
      let Camera = class Camera extends Object3D {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new Matrix4()),
            (this.projectionMatrix = new Matrix4()),
            (this.projectionMatrixInverse = new Matrix4()),
            (this.coordinateSystem = iT);
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            (this.coordinateSystem = t.coordinateSystem),
            this
          );
        }
        getWorldDirection(t) {
          return super.getWorldDirection(t).negate();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      let sr = new Vector3(),
        ss = new Vector2(),
        sn = new Vector2();
      let PerspectiveCamera = class PerspectiveCamera extends Camera {
        constructor(t = 50, e = 1, i = 0.1, r = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = i),
            (this.far = r),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        }
        setFocalLength(t) {
          let e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * iV * Math.atan(e)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          let t = Math.tan(0.5 * iI * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        }
        getEffectiveFOV() {
          return 2 * iV * Math.atan(Math.tan(0.5 * iI * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(t, e, i) {
          sr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            e.set(sr.x, sr.y).multiplyScalar(-t / sr.z),
            sr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            i.set(sr.x, sr.y).multiplyScalar(-t / sr.z);
        }
        getViewSize(t, e) {
          return this.getViewBounds(t, ss, sn), e.subVectors(sn, ss);
        }
        setViewOffset(t, e, i, r, s, n) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = n),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          let t = this.near,
            e = (t * Math.tan(0.5 * iI * this.fov)) / this.zoom,
            i = 2 * e,
            r = this.aspect * i,
            s = -0.5 * r,
            n = this.view;
          if (null !== this.view && this.view.enabled) {
            let t = n.fullWidth,
              a = n.fullHeight;
            (s += (n.offsetX * r) / t),
              (e -= (n.offsetY * i) / a),
              (r *= n.width / t),
              (i *= n.height / a);
          }
          let a = this.filmOffset;
          0 !== a && (s += (t * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              s,
              s + r,
              e,
              e - i,
              t,
              this.far,
              this.coordinateSystem
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          let e = super.toJSON(t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        }
      };
      let CubeCamera = class CubeCamera extends Object3D {
        constructor(t, e, i) {
          super(),
            (this.type = "CubeCamera"),
            (this.renderTarget = i),
            (this.coordinateSystem = null),
            (this.activeMipmapLevel = 0);
          let r = new PerspectiveCamera(-90, 1, t, e);
          (r.layers = this.layers), this.add(r);
          let s = new PerspectiveCamera(-90, 1, t, e);
          (s.layers = this.layers), this.add(s);
          let n = new PerspectiveCamera(-90, 1, t, e);
          (n.layers = this.layers), this.add(n);
          let a = new PerspectiveCamera(-90, 1, t, e);
          (a.layers = this.layers), this.add(a);
          let o = new PerspectiveCamera(-90, 1, t, e);
          (o.layers = this.layers), this.add(o);
          let h = new PerspectiveCamera(-90, 1, t, e);
          (h.layers = this.layers), this.add(h);
        }
        updateCoordinateSystem() {
          let t = this.coordinateSystem,
            e = this.children.concat(),
            [i, r, s, n, a, o] = e;
          for (let t of e) this.remove(t);
          if (t === iT)
            i.up.set(0, 1, 0),
              i.lookAt(1, 0, 0),
              r.up.set(0, 1, 0),
              r.lookAt(-1, 0, 0),
              s.up.set(0, 0, -1),
              s.lookAt(0, 1, 0),
              n.up.set(0, 0, 1),
              n.lookAt(0, -1, 0),
              a.up.set(0, 1, 0),
              a.lookAt(0, 0, 1),
              o.up.set(0, 1, 0),
              o.lookAt(0, 0, -1);
          else if (t === iC)
            i.up.set(0, -1, 0),
              i.lookAt(-1, 0, 0),
              r.up.set(0, -1, 0),
              r.lookAt(1, 0, 0),
              s.up.set(0, 0, 1),
              s.lookAt(0, 1, 0),
              n.up.set(0, 0, -1),
              n.lookAt(0, -1, 0),
              a.up.set(0, -1, 0),
              a.lookAt(0, 0, 1),
              o.up.set(0, -1, 0),
              o.lookAt(0, 0, -1);
          else
            throw Error(
              "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                t
            );
          for (let t of e) this.add(t), t.updateMatrixWorld();
        }
        update(t, e) {
          null === this.parent && this.updateMatrixWorld();
          let { renderTarget: i, activeMipmapLevel: r } = this;
          this.coordinateSystem !== t.coordinateSystem &&
            ((this.coordinateSystem = t.coordinateSystem),
            this.updateCoordinateSystem());
          let [s, n, a, o, h, l] = this.children,
            u = t.getRenderTarget(),
            c = t.getActiveCubeFace(),
            d = t.getActiveMipmapLevel(),
            p = t.xr.enabled;
          t.xr.enabled = !1;
          let m = i.texture.generateMipmaps;
          (i.texture.generateMipmaps = !1),
            t.setRenderTarget(i, 0, r),
            t.render(e, s),
            t.setRenderTarget(i, 1, r),
            t.render(e, n),
            t.setRenderTarget(i, 2, r),
            t.render(e, a),
            t.setRenderTarget(i, 3, r),
            t.render(e, o),
            t.setRenderTarget(i, 4, r),
            t.render(e, h),
            (i.texture.generateMipmaps = m),
            t.setRenderTarget(i, 5, r),
            t.render(e, l),
            t.setRenderTarget(u, c, d),
            (t.xr.enabled = p),
            (i.texture.needsPMREMUpdate = !0);
        }
      };
      let CubeTexture = class CubeTexture extends Texture {
        constructor(t, e, i, r, s, n, a, o, h, l) {
          super(
            (t = void 0 !== t ? t : []),
            (e = void 0 !== e ? e : tg),
            i,
            r,
            s,
            n,
            a,
            o,
            h,
            l
          ),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      };
      let WebGLCubeRenderTarget = class WebGLCubeRenderTarget extends WebGLRenderTarget {
        constructor(t = 1, e = {}) {
          super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
          let i = { width: t, height: t, depth: 1 },
            r = [i, i, i, i, i, i];
          (this.texture = new CubeTexture(
            r,
            e.mapping,
            e.wrapS,
            e.wrapT,
            e.magFilter,
            e.minFilter,
            e.format,
            e.type,
            e.anisotropy,
            e.colorSpace
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== e.generateMipmaps && e.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== e.minFilter ? e.minFilter : tI);
        }
        fromEquirectangularTexture(t, e) {
          (this.texture.type = e.type),
            (this.texture.colorSpace = e.colorSpace),
            (this.texture.generateMipmaps = e.generateMipmaps),
            (this.texture.minFilter = e.minFilter),
            (this.texture.magFilter = e.magFilter);
          let i = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            r = new BoxGeometry(5, 5, 5),
            s = new ShaderMaterial({
              name: "CubemapFromEquirect",
              uniforms: cloneUniforms(i.uniforms),
              vertexShader: i.vertexShader,
              fragmentShader: i.fragmentShader,
              side: M,
              blending: S,
            });
          s.uniforms.tEquirect.value = e;
          let n = new Mesh(r, s),
            a = e.minFilter;
          e.minFilter === tL && (e.minFilter = tI);
          let o = new CubeCamera(1, 10, this);
          return (
            o.update(t, n),
            (e.minFilter = a),
            n.geometry.dispose(),
            n.material.dispose(),
            this
          );
        }
        clear(t, e, i, r) {
          let s = t.getRenderTarget();
          for (let s = 0; s < 6; s++)
            t.setRenderTarget(this, s), t.clear(e, i, r);
          t.setRenderTarget(s);
        }
      };
      let FogExp2 = class FogExp2 {
        constructor(t, e = 25e-5) {
          (this.isFogExp2 = !0),
            (this.name = ""),
            (this.color = new Color(t)),
            (this.density = e);
        }
        clone() {
          return new FogExp2(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density,
          };
        }
      };
      let Fog = class Fog {
        constructor(t, e = 1, i = 1e3) {
          (this.isFog = !0),
            (this.name = ""),
            (this.color = new Color(t)),
            (this.near = e),
            (this.far = i);
        }
        clone() {
          return new Fog(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }
      };
      let Scene = class Scene extends Object3D {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.backgroundRotation = new Euler()),
            (this.environmentIntensity = 1),
            (this.environmentRotation = new Euler()),
            (this.overrideMaterial = null),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment &&
              (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            (this.backgroundBlurriness = t.backgroundBlurriness),
            (this.backgroundIntensity = t.backgroundIntensity),
            this.backgroundRotation.copy(t.backgroundRotation),
            (this.environmentIntensity = t.environmentIntensity),
            this.environmentRotation.copy(t.environmentRotation),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        }
        toJSON(t) {
          let e = super.toJSON(t);
          return (
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
              (e.object.backgroundBlurriness = this.backgroundBlurriness),
            1 !== this.backgroundIntensity &&
              (e.object.backgroundIntensity = this.backgroundIntensity),
            (e.object.backgroundRotation = this.backgroundRotation.toArray()),
            1 !== this.environmentIntensity &&
              (e.object.environmentIntensity = this.environmentIntensity),
            (e.object.environmentRotation = this.environmentRotation.toArray()),
            e
          );
        }
      };
      let InterleavedBuffer = class InterleavedBuffer {
        constructor(t, e) {
          (this.isInterleavedBuffer = !0),
            (this.array = t),
            (this.stride = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.usage = im),
            (this.updateRanges = []),
            (this.version = 0),
            (this.uuid = generateUUID());
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        addUpdateRange(t, e) {
          this.updateRanges.push({ start: t, count: e });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.usage = t.usage),
            this
          );
        }
        copyAt(t, e, i) {
          (t *= this.stride), (i *= e.stride);
          for (let r = 0, s = this.stride; r < s; r++)
            this.array[t + r] = e.array[i + r];
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        clone(t) {
          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = generateUUID()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          let e = new this.array.constructor(
              t.arrayBuffers[this.array.buffer._uuid]
            ),
            i = new this.constructor(e, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        toJSON(t) {
          return (
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = generateUUID()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
                new Uint32Array(this.array.buffer)
              )),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      };
      let sa = new Vector3();
      let InterleavedBufferAttribute = class InterleavedBufferAttribute {
        constructor(t, e, i, r = !1) {
          (this.isInterleavedBufferAttribute = !0),
            (this.name = ""),
            (this.data = t),
            (this.itemSize = e),
            (this.offset = i),
            (this.normalized = r);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(t) {
          this.data.needsUpdate = t;
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.data.count; e < i; e++)
            sa.fromBufferAttribute(this, e),
              sa.applyMatrix4(t),
              this.setXYZ(e, sa.x, sa.y, sa.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++)
            sa.fromBufferAttribute(this, e),
              sa.applyNormalMatrix(t),
              this.setXYZ(e, sa.x, sa.y, sa.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++)
            sa.fromBufferAttribute(this, e),
              sa.transformDirection(t),
              this.setXYZ(e, sa.x, sa.y, sa.z);
          return this;
        }
        getComponent(t, e) {
          let i = this.array[t * this.data.stride + this.offset + e];
          return this.normalized && (i = denormalize(i, this.array)), i;
        }
        setComponent(t, e, i) {
          return (
            this.normalized && (i = normalize(i, this.array)),
            (this.data.array[t * this.data.stride + this.offset + e] = i),
            this
          );
        }
        setX(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.data.array[t * this.data.stride + this.offset] = e),
            this
          );
        }
        setY(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.data.array[t * this.data.stride + this.offset + 1] = e),
            this
          );
        }
        setZ(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.data.array[t * this.data.stride + this.offset + 2] = e),
            this
          );
        }
        setW(t, e) {
          return (
            this.normalized && (e = normalize(e, this.array)),
            (this.data.array[t * this.data.stride + this.offset + 3] = e),
            this
          );
        }
        getX(t) {
          let e = this.data.array[t * this.data.stride + this.offset];
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        getY(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 1];
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        getZ(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 2];
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        getW(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 3];
          return this.normalized && (e = denormalize(e, this.array)), e;
        }
        setXY(t, e, i) {
          return (
            (t = t * this.data.stride + this.offset),
            this.normalized &&
              ((e = normalize(e, this.array)), (i = normalize(i, this.array))),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = i),
            this
          );
        }
        setXYZ(t, e, i, r) {
          return (
            (t = t * this.data.stride + this.offset),
            this.normalized &&
              ((e = normalize(e, this.array)),
              (i = normalize(i, this.array)),
              (r = normalize(r, this.array))),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = i),
            (this.data.array[t + 2] = r),
            this
          );
        }
        setXYZW(t, e, i, r, s) {
          return (
            (t = t * this.data.stride + this.offset),
            this.normalized &&
              ((e = normalize(e, this.array)),
              (i = normalize(i, this.array)),
              (r = normalize(r, this.array)),
              (s = normalize(s, this.array))),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = i),
            (this.data.array[t + 2] = r),
            (this.data.array[t + 3] = s),
            this
          );
        }
        clone(t) {
          if (void 0 !== t)
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
              new InterleavedBufferAttribute(
                t.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
            );
            let t = [];
            for (let e = 0; e < this.count; e++) {
              let i = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[i + e]);
            }
            return new BufferAttribute(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          }
        }
        toJSON(t) {
          if (void 0 !== t)
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
            );
            let t = [];
            for (let e = 0; e < this.count; e++) {
              let i = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[i + e]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          }
        }
      };
      let SpriteMaterial = class SpriteMaterial extends Material {
        constructor(t) {
          super(),
            (this.isSpriteMaterial = !0),
            (this.type = "SpriteMaterial"),
            (this.color = new Color(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.rotation = t.rotation),
            (this.sizeAttenuation = t.sizeAttenuation),
            (this.fog = t.fog),
            this
          );
        }
      };
      let so = new Vector3(),
        sh = new Vector3(),
        sl = new Vector3(),
        su = new Vector2(),
        sc = new Vector2(),
        sd = new Matrix4(),
        sp = new Vector3(),
        sm = new Vector3(),
        sf = new Vector3(),
        sy = new Vector2(),
        sg = new Vector2(),
        sx = new Vector2();
      let Sprite = class Sprite extends Object3D {
        constructor(t = new SpriteMaterial()) {
          if (
            (super(),
            (this.isSprite = !0),
            (this.type = "Sprite"),
            void 0 === s)
          ) {
            s = new BufferGeometry();
            let t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              e = new InterleavedBuffer(t, 5);
            s.setIndex([0, 1, 2, 0, 2, 3]),
              s.setAttribute(
                "position",
                new InterleavedBufferAttribute(e, 3, 0, !1)
              ),
              s.setAttribute("uv", new InterleavedBufferAttribute(e, 2, 3, !1));
          }
          (this.geometry = s),
            (this.material = t),
            (this.center = new Vector2(0.5, 0.5));
        }
        raycast(t, e) {
          let i, r;
          null === t.camera &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            sh.setFromMatrixScale(this.matrixWorld),
            sd.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              t.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            sl.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              sh.multiplyScalar(-sl.z);
          let s = this.material.rotation;
          0 !== s && ((r = Math.cos(s)), (i = Math.sin(s)));
          let n = this.center;
          transformVertex(sp.set(-0.5, -0.5, 0), sl, n, sh, i, r),
            transformVertex(sm.set(0.5, -0.5, 0), sl, n, sh, i, r),
            transformVertex(sf.set(0.5, 0.5, 0), sl, n, sh, i, r),
            sy.set(0, 0),
            sg.set(1, 0),
            sx.set(1, 1);
          let a = t.ray.intersectTriangle(sp, sm, sf, !1, so);
          if (
            null === a &&
            (transformVertex(sm.set(-0.5, 0.5, 0), sl, n, sh, i, r),
            sg.set(0, 1),
            null === (a = t.ray.intersectTriangle(sp, sf, sm, !1, so)))
          )
            return;
          let o = t.ray.origin.distanceTo(so);
          o < t.near ||
            o > t.far ||
            e.push({
              distance: o,
              point: so.clone(),
              uv: Triangle.getInterpolation(
                so,
                sp,
                sm,
                sf,
                sy,
                sg,
                sx,
                new Vector2()
              ),
              face: null,
              object: this,
            });
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            void 0 !== t.center && this.center.copy(t.center),
            (this.material = t.material),
            this
          );
        }
      };
      function transformVertex(t, e, i, r, s, n) {
        su.subVectors(t, i).addScalar(0.5).multiply(r),
          void 0 !== s
            ? ((sc.x = n * su.x - s * su.y), (sc.y = s * su.x + n * su.y))
            : sc.copy(su),
          t.copy(e),
          (t.x += sc.x),
          (t.y += sc.y),
          t.applyMatrix4(sd);
      }
      let sb = new Vector3(),
        sv = new Vector3();
      let LOD = class LOD extends Object3D {
        constructor() {
          super(),
            (this._currentLevel = 0),
            (this.type = "LOD"),
            Object.defineProperties(this, {
              levels: { enumerable: !0, value: [] },
              isLOD: { value: !0 },
            }),
            (this.autoUpdate = !0);
        }
        copy(t) {
          super.copy(t, !1);
          let e = t.levels;
          for (let t = 0, i = e.length; t < i; t++) {
            let i = e[t];
            this.addLevel(i.object.clone(), i.distance, i.hysteresis);
          }
          return (this.autoUpdate = t.autoUpdate), this;
        }
        addLevel(t, e = 0, i = 0) {
          let r;
          e = Math.abs(e);
          let s = this.levels;
          for (r = 0; r < s.length && !(e < s[r].distance); r++);
          return (
            s.splice(r, 0, { distance: e, hysteresis: i, object: t }),
            this.add(t),
            this
          );
        }
        removeLevel(t) {
          let e = this.levels;
          for (let i = 0; i < e.length; i++)
            if (e[i].distance === t) {
              let t = e.splice(i, 1);
              return this.remove(t[0].object), !0;
            }
          return !1;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(t) {
          let e = this.levels;
          if (e.length > 0) {
            let i, r;
            for (i = 1, r = e.length; i < r; i++) {
              let r = e[i].distance;
              if ((e[i].object.visible && (r -= r * e[i].hysteresis), t < r))
                break;
            }
            return e[i - 1].object;
          }
          return null;
        }
        raycast(t, e) {
          let i = this.levels;
          if (i.length > 0) {
            sb.setFromMatrixPosition(this.matrixWorld);
            let i = t.ray.origin.distanceTo(sb);
            this.getObjectForDistance(i).raycast(t, e);
          }
        }
        update(t) {
          let e = this.levels;
          if (e.length > 1) {
            let i, r;
            sb.setFromMatrixPosition(t.matrixWorld),
              sv.setFromMatrixPosition(this.matrixWorld);
            let s = sb.distanceTo(sv) / t.zoom;
            for (i = 1, e[0].object.visible = !0, r = e.length; i < r; i++) {
              let t = e[i].distance;
              if ((e[i].object.visible && (t -= t * e[i].hysteresis), s >= t))
                (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
              else break;
            }
            for (this._currentLevel = i - 1; i < r; i++)
              e[i].object.visible = !1;
          }
        }
        toJSON(t) {
          let e = super.toJSON(t);
          !1 === this.autoUpdate && (e.object.autoUpdate = !1),
            (e.object.levels = []);
          let i = this.levels;
          for (let t = 0, r = i.length; t < r; t++) {
            let r = i[t];
            e.object.levels.push({
              object: r.object.uuid,
              distance: r.distance,
              hysteresis: r.hysteresis,
            });
          }
          return e;
        }
      };
      let sM = new Vector3(),
        sw = new Vector4(),
        sS = new Vector4(),
        sA = new Vector3(),
        s_ = new Matrix4(),
        sT = new Vector3(),
        sC = new Sphere(),
        sz = new Matrix4(),
        sB = new Ray();
      let SkinnedMesh = class SkinnedMesh extends Mesh {
        constructor(t, e) {
          super(t, e),
            (this.isSkinnedMesh = !0),
            (this.type = "SkinnedMesh"),
            (this.bindMode = tm),
            (this.bindMatrix = new Matrix4()),
            (this.bindMatrixInverse = new Matrix4()),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        }
        computeBoundingBox() {
          let t = this.geometry;
          null === this.boundingBox && (this.boundingBox = new Box3()),
            this.boundingBox.makeEmpty();
          let e = t.getAttribute("position");
          for (let t = 0; t < e.count; t++)
            this.getVertexPosition(t, sT), this.boundingBox.expandByPoint(sT);
        }
        computeBoundingSphere() {
          let t = this.geometry;
          null === this.boundingSphere && (this.boundingSphere = new Sphere()),
            this.boundingSphere.makeEmpty();
          let e = t.getAttribute("position");
          for (let t = 0; t < e.count; t++)
            this.getVertexPosition(t, sT),
              this.boundingSphere.expandByPoint(sT);
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.bindMode = t.bindMode),
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            (this.skeleton = t.skeleton),
            null !== t.boundingBox &&
              (this.boundingBox = t.boundingBox.clone()),
            null !== t.boundingSphere &&
              (this.boundingSphere = t.boundingSphere.clone()),
            this
          );
        }
        raycast(t, e) {
          let i = this.material,
            r = this.matrixWorld;
          if (
            void 0 !== i &&
            (null === this.boundingSphere && this.computeBoundingSphere(),
            sC.copy(this.boundingSphere),
            sC.applyMatrix4(r),
            !1 !== t.ray.intersectsSphere(sC))
          ) {
            if (
              (sz.copy(r).invert(),
              sB.copy(t.ray).applyMatrix4(sz),
              null !== this.boundingBox &&
                !1 === sB.intersectsBox(this.boundingBox))
            )
              return;
            this._computeIntersections(t, e, sB);
          }
        }
        getVertexPosition(t, e) {
          return (
            super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
          );
        }
        bind(t, e) {
          (this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          let t = new Vector4(),
            e = this.geometry.attributes.skinWeight;
          for (let i = 0, r = e.count; i < r; i++) {
            t.fromBufferAttribute(e, i);
            let r = 1 / t.manhattanLength();
            r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
              e.setXYZW(i, t.x, t.y, t.z, t.w);
          }
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            this.bindMode === tm
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : this.bindMode === tf
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        applyBoneTransform(t, e) {
          let i = this.skeleton,
            r = this.geometry;
          sw.fromBufferAttribute(r.attributes.skinIndex, t),
            sS.fromBufferAttribute(r.attributes.skinWeight, t),
            sM.copy(e).applyMatrix4(this.bindMatrix),
            e.set(0, 0, 0);
          for (let t = 0; t < 4; t++) {
            let r = sS.getComponent(t);
            if (0 !== r) {
              let s = sw.getComponent(t);
              s_.multiplyMatrices(i.bones[s].matrixWorld, i.boneInverses[s]),
                e.addScaledVector(sA.copy(sM).applyMatrix4(s_), r);
            }
          }
          return e.applyMatrix4(this.bindMatrixInverse);
        }
      };
      let Bone = class Bone extends Object3D {
        constructor() {
          super(), (this.isBone = !0), (this.type = "Bone");
        }
      };
      let DataTexture = class DataTexture extends Texture {
        constructor(
          t = null,
          e = 1,
          i = 1,
          r,
          s,
          n,
          a,
          o,
          h = t_,
          l = t_,
          u,
          c
        ) {
          super(null, n, a, o, h, l, r, s, u, c),
            (this.isDataTexture = !0),
            (this.image = { data: t, width: e, height: i }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      };
      let sI = new Matrix4(),
        sV = new Matrix4();
      let Skeleton = class Skeleton {
        constructor(t = [], e = []) {
          (this.uuid = generateUUID()),
            (this.bones = t.slice(0)),
            (this.boneInverses = e),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            this.init();
        }
        init() {
          let t = this.bones,
            e = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(16 * t.length)),
            0 === e.length)
          )
            this.calculateInverses();
          else if (t.length !== e.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let t = 0, e = this.bones.length; t < e; t++)
              this.boneInverses.push(new Matrix4());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let t = 0, e = this.bones.length; t < e; t++) {
            let e = new Matrix4();
            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
              this.boneInverses.push(e);
          }
        }
        pose() {
          for (let t = 0, e = this.bones.length; t < e; t++) {
            let e = this.bones[t];
            e && e.matrixWorld.copy(this.boneInverses[t]).invert();
          }
          for (let t = 0, e = this.bones.length; t < e; t++) {
            let e = this.bones[t];
            e &&
              (e.parent && e.parent.isBone
                ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                  e.matrix.multiply(e.matrixWorld))
                : e.matrix.copy(e.matrixWorld),
              e.matrix.decompose(e.position, e.quaternion, e.scale));
          }
        }
        update() {
          let t = this.bones,
            e = this.boneInverses,
            i = this.boneMatrices,
            r = this.boneTexture;
          for (let r = 0, s = t.length; r < s; r++) {
            let s = t[r] ? t[r].matrixWorld : sV;
            sI.multiplyMatrices(s, e[r]), sI.toArray(i, 16 * r);
          }
          null !== r && (r.needsUpdate = !0);
        }
        clone() {
          return new Skeleton(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let t = Math.sqrt(4 * this.bones.length);
          t = Math.max((t = 4 * Math.ceil(t / 4)), 4);
          let e = new Float32Array(t * t * 4);
          e.set(this.boneMatrices);
          let i = new DataTexture(e, t, t, tX, tU);
          return (
            (i.needsUpdate = !0),
            (this.boneMatrices = e),
            (this.boneTexture = i),
            this
          );
        }
        getBoneByName(t) {
          for (let e = 0, i = this.bones.length; e < i; e++) {
            let i = this.bones[e];
            if (i.name === t) return i;
          }
        }
        dispose() {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(t, e) {
          this.uuid = t.uuid;
          for (let i = 0, r = t.bones.length; i < r; i++) {
            let r = t.bones[i],
              s = e[r];
            void 0 === s &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", r),
              (s = new Bone())),
              this.bones.push(s),
              this.boneInverses.push(
                new Matrix4().fromArray(t.boneInverses[i])
              );
          }
          return this.init(), this;
        }
        toJSON() {
          let t = {
            metadata: {
              version: 4.6,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          t.uuid = this.uuid;
          let e = this.bones,
            i = this.boneInverses;
          for (let r = 0, s = e.length; r < s; r++) {
            let s = e[r];
            t.bones.push(s.uuid);
            let n = i[r];
            t.boneInverses.push(n.toArray());
          }
          return t;
        }
      };
      let InstancedBufferAttribute = class InstancedBufferAttribute extends BufferAttribute {
        constructor(t, e, i, r = 1) {
          super(t, e, i),
            (this.isInstancedBufferAttribute = !0),
            (this.meshPerAttribute = r);
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          );
        }
        toJSON() {
          let t = super.toJSON();
          return (
            (t.meshPerAttribute = this.meshPerAttribute),
            (t.isInstancedBufferAttribute = !0),
            t
          );
        }
      };
      let sP = new Matrix4(),
        sL = new Matrix4(),
        sk = [],
        sR = new Box3(),
        sE = new Matrix4(),
        sO = new Mesh(),
        sF = new Sphere();
      let InstancedMesh = class InstancedMesh extends Mesh {
        constructor(t, e, i) {
          super(t, e),
            (this.isInstancedMesh = !0),
            (this.instanceMatrix = new InstancedBufferAttribute(
              new Float32Array(16 * i),
              16
            )),
            (this.instanceColor = null),
            (this.morphTexture = null),
            (this.count = i),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          for (let t = 0; t < i; t++) this.setMatrixAt(t, sE);
        }
        computeBoundingBox() {
          let t = this.geometry,
            e = this.count;
          null === this.boundingBox && (this.boundingBox = new Box3()),
            null === t.boundingBox && t.computeBoundingBox(),
            this.boundingBox.makeEmpty();
          for (let i = 0; i < e; i++)
            this.getMatrixAt(i, sP),
              sR.copy(t.boundingBox).applyMatrix4(sP),
              this.boundingBox.union(sR);
        }
        computeBoundingSphere() {
          let t = this.geometry,
            e = this.count;
          null === this.boundingSphere && (this.boundingSphere = new Sphere()),
            null === t.boundingSphere && t.computeBoundingSphere(),
            this.boundingSphere.makeEmpty();
          for (let i = 0; i < e; i++)
            this.getMatrixAt(i, sP),
              sF.copy(t.boundingSphere).applyMatrix4(sP),
              this.boundingSphere.union(sF);
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.instanceMatrix.copy(t.instanceMatrix),
            null !== t.morphTexture &&
              (this.morphTexture = t.morphTexture.clone()),
            null !== t.instanceColor &&
              (this.instanceColor = t.instanceColor.clone()),
            (this.count = t.count),
            null !== t.boundingBox &&
              (this.boundingBox = t.boundingBox.clone()),
            null !== t.boundingSphere &&
              (this.boundingSphere = t.boundingSphere.clone()),
            this
          );
        }
        getColorAt(t, e) {
          e.fromArray(this.instanceColor.array, 3 * t);
        }
        getMatrixAt(t, e) {
          e.fromArray(this.instanceMatrix.array, 16 * t);
        }
        getMorphAt(t, e) {
          let i = e.morphTargetInfluences,
            r = this.morphTexture.source.data.data,
            s = i.length + 1,
            n = t * s + 1;
          for (let t = 0; t < i.length; t++) i[t] = r[n + t];
        }
        raycast(t, e) {
          let i = this.matrixWorld,
            r = this.count;
          if (
            ((sO.geometry = this.geometry),
            (sO.material = this.material),
            void 0 !== sO.material &&
              (null === this.boundingSphere && this.computeBoundingSphere(),
              sF.copy(this.boundingSphere),
              sF.applyMatrix4(i),
              !1 !== t.ray.intersectsSphere(sF)))
          )
            for (let s = 0; s < r; s++) {
              this.getMatrixAt(s, sP),
                sL.multiplyMatrices(i, sP),
                (sO.matrixWorld = sL),
                sO.raycast(t, sk);
              for (let t = 0, i = sk.length; t < i; t++) {
                let i = sk[t];
                (i.instanceId = s), (i.object = this), e.push(i);
              }
              sk.length = 0;
            }
        }
        setColorAt(t, e) {
          null === this.instanceColor &&
            (this.instanceColor = new InstancedBufferAttribute(
              new Float32Array(3 * this.instanceMatrix.count).fill(1),
              3
            )),
            e.toArray(this.instanceColor.array, 3 * t);
        }
        setMatrixAt(t, e) {
          e.toArray(this.instanceMatrix.array, 16 * t);
        }
        setMorphAt(t, e) {
          let i = e.morphTargetInfluences,
            r = i.length + 1;
          null === this.morphTexture &&
            (this.morphTexture = new DataTexture(
              new Float32Array(r * this.count),
              r,
              this.count,
              t0,
              tU
            ));
          let s = this.morphTexture.source.data.data,
            n = 0;
          for (let t = 0; t < i.length; t++) n += i[t];
          let a = this.geometry.morphTargetsRelative ? 1 : 1 - n,
            o = r * t;
          (s[o] = a), s.set(i, o + 1);
        }
        updateMorphTargets() {}
        dispose() {
          return (
            this.dispatchEvent({ type: "dispose" }),
            null !== this.morphTexture &&
              (this.morphTexture.dispose(), (this.morphTexture = null)),
            this
          );
        }
      };
      let sN = new Vector3(),
        sD = new Vector3(),
        sU = new Matrix3();
      let Plane = class Plane {
        constructor(t = new Vector3(1, 0, 0), e = 0) {
          (this.isPlane = !0), (this.normal = t), (this.constant = e);
        }
        set(t, e) {
          return this.normal.copy(t), (this.constant = e), this;
        }
        setComponents(t, e, i, r) {
          return this.normal.set(t, e, i), (this.constant = r), this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return (
            this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(t, e, i) {
          let r = sN.subVectors(i, e).cross(sD.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(r, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this;
        }
        normalize() {
          let t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), (this.constant *= t), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
          return e
            .copy(t)
            .addScaledVector(this.normal, -this.distanceToPoint(t));
        }
        intersectLine(t, e) {
          let i = t.delta(sN),
            r = this.normal.dot(i);
          if (0 === r)
            return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
          let s = -(t.start.dot(this.normal) + this.constant) / r;
          return s < 0 || s > 1 ? null : e.copy(t.start).addScaledVector(i, s);
        }
        intersectsLine(t) {
          let e = this.distanceToPoint(t.start),
            i = this.distanceToPoint(t.end);
          return (e < 0 && i > 0) || (i < 0 && e > 0);
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
          let i = e || sU.getNormalMatrix(t),
            r = this.coplanarPoint(sN).applyMatrix4(t),
            s = this.normal.applyMatrix3(i).normalize();
          return (this.constant = -r.dot(s)), this;
        }
        translate(t) {
          return (this.constant -= t.dot(this.normal)), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      let sG = new Sphere(),
        sj = new Vector3();
      let Frustum = class Frustum {
        constructor(
          t = new Plane(),
          e = new Plane(),
          i = new Plane(),
          r = new Plane(),
          s = new Plane(),
          n = new Plane()
        ) {
          this.planes = [t, e, i, r, s, n];
        }
        set(t, e, i, r, s, n) {
          let a = this.planes;
          return (
            a[0].copy(t),
            a[1].copy(e),
            a[2].copy(i),
            a[3].copy(r),
            a[4].copy(s),
            a[5].copy(n),
            this
          );
        }
        copy(t) {
          let e = this.planes;
          for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
          return this;
        }
        setFromProjectionMatrix(t, e = iT) {
          let i = this.planes,
            r = t.elements,
            s = r[0],
            n = r[1],
            a = r[2],
            o = r[3],
            h = r[4],
            l = r[5],
            u = r[6],
            c = r[7],
            d = r[8],
            p = r[9],
            m = r[10],
            f = r[11],
            y = r[12],
            g = r[13],
            x = r[14],
            b = r[15];
          if (
            (i[0].setComponents(o - s, c - h, f - d, b - y).normalize(),
            i[1].setComponents(o + s, c + h, f + d, b + y).normalize(),
            i[2].setComponents(o + n, c + l, f + p, b + g).normalize(),
            i[3].setComponents(o - n, c - l, f - p, b - g).normalize(),
            i[4].setComponents(o - a, c - u, f - m, b - x).normalize(),
            e === iT)
          )
            i[5].setComponents(o + a, c + u, f + m, b + x).normalize();
          else if (e === iC) i[5].setComponents(a, u, m, x).normalize();
          else
            throw Error(
              "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                e
            );
          return this;
        }
        intersectsObject(t) {
          if (void 0 !== t.boundingSphere)
            null === t.boundingSphere && t.computeBoundingSphere(),
              sG.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
          else {
            let e = t.geometry;
            null === e.boundingSphere && e.computeBoundingSphere(),
              sG.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
          }
          return this.intersectsSphere(sG);
        }
        intersectsSprite(t) {
          return (
            sG.center.set(0, 0, 0),
            (sG.radius = 0.7071067811865476),
            sG.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(sG)
          );
        }
        intersectsSphere(t) {
          let e = this.planes,
            i = t.center,
            r = -t.radius;
          for (let t = 0; t < 6; t++) {
            let s = e[t].distanceToPoint(i);
            if (s < r) return !1;
          }
          return !0;
        }
        intersectsBox(t) {
          let e = this.planes;
          for (let i = 0; i < 6; i++) {
            let r = e[i];
            if (
              ((sj.x = r.normal.x > 0 ? t.max.x : t.min.x),
              (sj.y = r.normal.y > 0 ? t.max.y : t.min.y),
              (sj.z = r.normal.z > 0 ? t.max.z : t.min.z),
              0 > r.distanceToPoint(sj))
            )
              return !1;
          }
          return !0;
        }
        containsPoint(t) {
          let e = this.planes;
          for (let i = 0; i < 6; i++)
            if (0 > e[i].distanceToPoint(t)) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      function ascIdSort(t, e) {
        return t - e;
      }
      function sortOpaque(t, e) {
        return t.z - e.z;
      }
      function sortTransparent(t, e) {
        return e.z - t.z;
      }
      let sW = new Matrix4(),
        sH = new Color(1, 1, 1),
        sq = new Frustum(),
        sJ = new Box3(),
        sZ = new Sphere(),
        sX = new Vector3(),
        sY = new Vector3(),
        sQ = new Vector3(),
        sK = new (class {
          constructor() {
            (this.index = 0), (this.pool = []), (this.list = []);
          }
          push(t, e, i, r) {
            let s = this.pool,
              n = this.list;
            this.index >= s.length &&
              s.push({ start: -1, count: -1, z: -1, index: -1 });
            let a = s[this.index];
            n.push(a),
              this.index++,
              (a.start = t),
              (a.count = e),
              (a.z = i),
              (a.index = r);
          }
          reset() {
            (this.list.length = 0), (this.index = 0);
          }
        })(),
        s$ = new Mesh(),
        s0 = [];
      function copyArrayContents(t, e) {
        if (t.constructor !== e.constructor) {
          let i = Math.min(t.length, e.length);
          for (let r = 0; r < i; r++) e[r] = t[r];
        } else {
          let i = Math.min(t.length, e.length);
          e.set(new t.constructor(t.buffer, 0, i));
        }
      }
      let BatchedMesh = class BatchedMesh extends Mesh {
        get maxInstanceCount() {
          return this._maxInstanceCount;
        }
        get instanceCount() {
          return this._instanceInfo.length - this._availableInstanceIds.length;
        }
        get unusedVertexCount() {
          return this._maxVertexCount - this._nextVertexStart;
        }
        get unusedIndexCount() {
          return this._maxIndexCount - this._nextIndexStart;
        }
        constructor(t, e, i = 2 * e, r) {
          super(new BufferGeometry(), r),
            (this.isBatchedMesh = !0),
            (this.perObjectFrustumCulled = !0),
            (this.sortObjects = !0),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.customSort = null),
            (this._instanceInfo = []),
            (this._geometryInfo = []),
            (this._availableInstanceIds = []),
            (this._availableGeometryIds = []),
            (this._nextIndexStart = 0),
            (this._nextVertexStart = 0),
            (this._geometryCount = 0),
            (this._visibilityChanged = !0),
            (this._geometryInitialized = !1),
            (this._maxInstanceCount = t),
            (this._maxVertexCount = e),
            (this._maxIndexCount = i),
            (this._multiDrawCounts = new Int32Array(t)),
            (this._multiDrawStarts = new Int32Array(t)),
            (this._multiDrawCount = 0),
            (this._multiDrawInstances = null),
            (this._matricesTexture = null),
            (this._indirectTexture = null),
            (this._colorsTexture = null),
            this._initMatricesTexture(),
            this._initIndirectTexture();
        }
        _initMatricesTexture() {
          let t = Math.sqrt(4 * this._maxInstanceCount);
          t = Math.max((t = 4 * Math.ceil(t / 4)), 4);
          let e = new Float32Array(t * t * 4),
            i = new DataTexture(e, t, t, tX, tU);
          this._matricesTexture = i;
        }
        _initIndirectTexture() {
          let t = Math.sqrt(this._maxInstanceCount);
          t = Math.ceil(t);
          let e = new Uint32Array(t * t),
            i = new DataTexture(e, t, t, t1, tD);
          this._indirectTexture = i;
        }
        _initColorsTexture() {
          let t = Math.sqrt(this._maxInstanceCount);
          t = Math.ceil(t);
          let e = new Float32Array(t * t * 4).fill(1),
            i = new DataTexture(e, t, t, tX, tU);
          (i.colorSpace = iF.workingColorSpace), (this._colorsTexture = i);
        }
        _initializeGeometry(t) {
          let e = this.geometry,
            i = this._maxVertexCount,
            r = this._maxIndexCount;
          if (!1 === this._geometryInitialized) {
            for (let r in t.attributes) {
              let s = t.getAttribute(r),
                { array: n, itemSize: a, normalized: o } = s,
                h = new n.constructor(i * a),
                l = new BufferAttribute(h, a, o);
              e.setAttribute(r, l);
            }
            if (null !== t.getIndex()) {
              let t = i > 65535 ? new Uint32Array(r) : new Uint16Array(r);
              e.setIndex(new BufferAttribute(t, 1));
            }
            this._geometryInitialized = !0;
          }
        }
        _validateGeometry(t) {
          let e = this.geometry;
          if (!!t.getIndex() != !!e.getIndex())
            throw Error(
              'THREE.BatchedMesh: All geometries must consistently have "index".'
            );
          for (let i in e.attributes) {
            if (!t.hasAttribute(i))
              throw Error(
                `THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`
              );
            let r = t.getAttribute(i),
              s = e.getAttribute(i);
            if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
              throw Error(
                "THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value."
              );
          }
        }
        validateInstanceId(t) {
          let e = this._instanceInfo;
          if (t < 0 || t >= e.length || !1 === e[t].active)
            throw Error(
              `THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`
            );
        }
        validateGeometryId(t) {
          let e = this._geometryInfo;
          if (t < 0 || t >= e.length || !1 === e[t].active)
            throw Error(
              `THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`
            );
        }
        setCustomSort(t) {
          return (this.customSort = t), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Box3());
          let t = this.boundingBox,
            e = this._instanceInfo;
          t.makeEmpty();
          for (let i = 0, r = e.length; i < r; i++) {
            if (!1 === e[i].active) continue;
            let r = e[i].geometryIndex;
            this.getMatrixAt(i, sW),
              this.getBoundingBoxAt(r, sJ).applyMatrix4(sW),
              t.union(sJ);
          }
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Sphere());
          let t = this.boundingSphere,
            e = this._instanceInfo;
          t.makeEmpty();
          for (let i = 0, r = e.length; i < r; i++) {
            if (!1 === e[i].active) continue;
            let r = e[i].geometryIndex;
            this.getMatrixAt(i, sW),
              this.getBoundingSphereAt(r, sZ).applyMatrix4(sW),
              t.union(sZ);
          }
        }
        addInstance(t) {
          let e = this._instanceInfo.length >= this.maxInstanceCount;
          if (e && 0 === this._availableInstanceIds.length)
            throw Error("THREE.BatchedMesh: Maximum item count reached.");
          let i = { visible: !0, active: !0, geometryIndex: t },
            r = null;
          this._availableInstanceIds.length > 0
            ? (this._availableInstanceIds.sort(ascIdSort),
              (r = this._availableInstanceIds.shift()),
              (this._instanceInfo[r] = i))
            : ((r = this._instanceInfo.length), this._instanceInfo.push(i));
          let s = this._matricesTexture;
          sW.identity().toArray(s.image.data, 16 * r), (s.needsUpdate = !0);
          let n = this._colorsTexture;
          return (
            n && (sH.toArray(n.image.data, 4 * r), (n.needsUpdate = !0)),
            (this._visibilityChanged = !0),
            r
          );
        }
        addGeometry(t, e = -1, i = -1) {
          let r;
          this._initializeGeometry(t), this._validateGeometry(t);
          let s = {
              vertexStart: -1,
              vertexCount: -1,
              reservedVertexCount: -1,
              indexStart: -1,
              indexCount: -1,
              reservedIndexCount: -1,
              start: -1,
              count: -1,
              boundingBox: null,
              boundingSphere: null,
              active: !0,
            },
            n = this._geometryInfo;
          (s.vertexStart = this._nextVertexStart),
            (s.reservedVertexCount =
              -1 === e ? t.getAttribute("position").count : e);
          let a = t.getIndex();
          if (
            (null !== a &&
              ((s.indexStart = this._nextIndexStart),
              (s.reservedIndexCount = -1 === i ? a.count : i)),
            (-1 !== s.indexStart &&
              s.indexStart + s.reservedIndexCount > this._maxIndexCount) ||
              s.vertexStart + s.reservedVertexCount > this._maxVertexCount)
          )
            throw Error(
              "THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."
            );
          return (
            this._availableGeometryIds.length > 0
              ? (this._availableGeometryIds.sort(ascIdSort),
                (n[(r = this._availableGeometryIds.shift())] = s))
              : ((r = this._geometryCount), this._geometryCount++, n.push(s)),
            this.setGeometryAt(r, t),
            (this._nextIndexStart = s.indexStart + s.reservedIndexCount),
            (this._nextVertexStart = s.vertexStart + s.reservedVertexCount),
            r
          );
        }
        setGeometryAt(t, e) {
          if (t >= this._geometryCount)
            throw Error("THREE.BatchedMesh: Maximum geometry count reached.");
          this._validateGeometry(e);
          let i = this.geometry,
            r = null !== i.getIndex(),
            s = i.getIndex(),
            n = e.getIndex(),
            a = this._geometryInfo[t];
          if (
            (r && n.count > a.reservedIndexCount) ||
            e.attributes.position.count > a.reservedVertexCount
          )
            throw Error(
              "THREE.BatchedMesh: Reserved space not large enough for provided geometry."
            );
          let o = a.vertexStart,
            h = a.reservedVertexCount;
          for (let t in ((a.vertexCount = e.getAttribute("position").count),
          i.attributes)) {
            let r = e.getAttribute(t),
              s = i.getAttribute(t);
            !(function (t, e, i = 0) {
              let r = e.itemSize;
              if (
                t.isInterleavedBufferAttribute ||
                t.array.constructor !== e.array.constructor
              ) {
                let s = t.count;
                for (let n = 0; n < s; n++)
                  for (let s = 0; s < r; s++)
                    e.setComponent(n + i, s, t.getComponent(n, s));
              } else e.array.set(t.array, i * r);
              e.needsUpdate = !0;
            })(r, s, o);
            let n = r.itemSize;
            for (let t = r.count; t < h; t++) {
              let e = o + t;
              for (let t = 0; t < n; t++) s.setComponent(e, t, 0);
            }
            (s.needsUpdate = !0), s.addUpdateRange(o * n, h * n);
          }
          if (r) {
            let t = a.indexStart,
              i = a.reservedIndexCount;
            a.indexCount = e.getIndex().count;
            for (let e = 0; e < n.count; e++) s.setX(t + e, o + n.getX(e));
            for (let e = n.count; e < i; e++) s.setX(t + e, o);
            (s.needsUpdate = !0), s.addUpdateRange(t, a.reservedIndexCount);
          }
          return (
            (a.start = r ? a.indexStart : a.vertexStart),
            (a.count = r ? a.indexCount : a.vertexCount),
            (a.boundingBox = null),
            null !== e.boundingBox && (a.boundingBox = e.boundingBox.clone()),
            (a.boundingSphere = null),
            null !== e.boundingSphere &&
              (a.boundingSphere = e.boundingSphere.clone()),
            (this._visibilityChanged = !0),
            t
          );
        }
        deleteGeometry(t) {
          let e = this._geometryInfo;
          if (t >= e.length || !1 === e[t].active) return this;
          let i = this._instanceInfo;
          for (let e = 0, r = i.length; e < r; e++)
            i[e].geometryIndex === t && this.deleteInstance(e);
          return (
            (e[t].active = !1),
            this._availableGeometryIds.push(t),
            (this._visibilityChanged = !0),
            this
          );
        }
        deleteInstance(t) {
          return (
            this.validateInstanceId(t),
            (this._instanceInfo[t].active = !1),
            this._availableInstanceIds.push(t),
            (this._visibilityChanged = !0),
            this
          );
        }
        optimize() {
          let t = 0,
            e = 0,
            i = this._geometryInfo,
            r = i
              .map((t, e) => e)
              .sort((t, e) => i[t].vertexStart - i[e].vertexStart),
            s = this.geometry;
          for (let n = 0, a = i.length; n < a; n++) {
            let a = r[n],
              o = i[a];
            if (!1 !== o.active) {
              if (null !== s.index) {
                if (o.indexStart !== e) {
                  let {
                      indexStart: i,
                      vertexStart: r,
                      reservedIndexCount: n,
                    } = o,
                    a = s.index,
                    h = a.array,
                    l = t - r;
                  for (let t = i; t < i + n; t++) h[t] = h[t] + l;
                  a.array.copyWithin(e, i, i + n),
                    a.addUpdateRange(e, n),
                    (o.indexStart = e);
                }
                e += o.reservedIndexCount;
              }
              if (o.vertexStart !== t) {
                let { vertexStart: e, reservedVertexCount: i } = o,
                  r = s.attributes;
                for (let s in r) {
                  let n = r[s],
                    { array: a, itemSize: o } = n;
                  a.copyWithin(t * o, e * o, (e + i) * o),
                    n.addUpdateRange(t * o, i * o);
                }
                o.vertexStart = t;
              }
              (t += o.reservedVertexCount),
                (o.start = s.index ? o.indexStart : o.vertexStart),
                (this._nextIndexStart = s.index
                  ? o.indexStart + o.reservedIndexCount
                  : 0),
                (this._nextVertexStart = o.vertexStart + o.reservedVertexCount);
            }
          }
          return this;
        }
        getBoundingBoxAt(t, e) {
          if (t >= this._geometryCount) return null;
          let i = this.geometry,
            r = this._geometryInfo[t];
          if (null === r.boundingBox) {
            let t = new Box3(),
              e = i.index,
              s = i.attributes.position;
            for (let i = r.start, n = r.start + r.count; i < n; i++) {
              let r = i;
              e && (r = e.getX(r)),
                t.expandByPoint(sX.fromBufferAttribute(s, r));
            }
            r.boundingBox = t;
          }
          return e.copy(r.boundingBox), e;
        }
        getBoundingSphereAt(t, e) {
          if (t >= this._geometryCount) return null;
          let i = this.geometry,
            r = this._geometryInfo[t];
          if (null === r.boundingSphere) {
            let e = new Sphere();
            this.getBoundingBoxAt(t, sJ), sJ.getCenter(e.center);
            let s = i.index,
              n = i.attributes.position,
              a = 0;
            for (let t = r.start, i = r.start + r.count; t < i; t++) {
              let i = t;
              s && (i = s.getX(i)),
                sX.fromBufferAttribute(n, i),
                (a = Math.max(a, e.center.distanceToSquared(sX)));
            }
            (e.radius = Math.sqrt(a)), (r.boundingSphere = e);
          }
          return e.copy(r.boundingSphere), e;
        }
        setMatrixAt(t, e) {
          this.validateInstanceId(t);
          let i = this._matricesTexture,
            r = this._matricesTexture.image.data;
          return e.toArray(r, 16 * t), (i.needsUpdate = !0), this;
        }
        getMatrixAt(t, e) {
          return (
            this.validateInstanceId(t),
            e.fromArray(this._matricesTexture.image.data, 16 * t)
          );
        }
        setColorAt(t, e) {
          return (
            this.validateInstanceId(t),
            null === this._colorsTexture && this._initColorsTexture(),
            e.toArray(this._colorsTexture.image.data, 4 * t),
            (this._colorsTexture.needsUpdate = !0),
            this
          );
        }
        getColorAt(t, e) {
          return (
            this.validateInstanceId(t),
            e.fromArray(this._colorsTexture.image.data, 4 * t)
          );
        }
        setVisibleAt(t, e) {
          return (
            this.validateInstanceId(t),
            this._instanceInfo[t].visible === e ||
              ((this._instanceInfo[t].visible = e),
              (this._visibilityChanged = !0)),
            this
          );
        }
        getVisibleAt(t) {
          return this.validateInstanceId(t), this._instanceInfo[t].visible;
        }
        setGeometryIdAt(t, e) {
          return (
            this.validateInstanceId(t),
            this.validateGeometryId(e),
            (this._instanceInfo[t].geometryIndex = e),
            this
          );
        }
        getGeometryIdAt(t) {
          return (
            this.validateInstanceId(t), this._instanceInfo[t].geometryIndex
          );
        }
        getGeometryRangeAt(t, e = {}) {
          this.validateGeometryId(t);
          let i = this._geometryInfo[t];
          return (
            (e.vertexStart = i.vertexStart),
            (e.vertexCount = i.vertexCount),
            (e.reservedVertexCount = i.reservedVertexCount),
            (e.indexStart = i.indexStart),
            (e.indexCount = i.indexCount),
            (e.reservedIndexCount = i.reservedIndexCount),
            (e.start = i.start),
            (e.count = i.count),
            e
          );
        }
        setInstanceCount(t) {
          let e = this._availableInstanceIds,
            i = this._instanceInfo;
          for (e.sort(ascIdSort); e[e.length - 1] === i.length; )
            i.pop(), e.pop();
          if (t < i.length)
            throw Error(
              `BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`
            );
          let r = new Int32Array(t),
            s = new Int32Array(t);
          copyArrayContents(this._multiDrawCounts, r),
            copyArrayContents(this._multiDrawStarts, s),
            (this._multiDrawCounts = r),
            (this._multiDrawStarts = s),
            (this._maxInstanceCount = t);
          let n = this._indirectTexture,
            a = this._matricesTexture,
            o = this._colorsTexture;
          n.dispose(),
            this._initIndirectTexture(),
            copyArrayContents(n.image.data, this._indirectTexture.image.data),
            a.dispose(),
            this._initMatricesTexture(),
            copyArrayContents(a.image.data, this._matricesTexture.image.data),
            o &&
              (o.dispose(),
              this._initColorsTexture(),
              copyArrayContents(o.image.data, this._colorsTexture.image.data));
        }
        setGeometrySize(t, e) {
          let i = [...this._geometryInfo].filter((t) => t.active),
            r = Math.max(
              ...i.map((t) => t.vertexStart + t.reservedVertexCount)
            );
          if (r > t)
            throw Error(
              `BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`
            );
          if (this.geometry.index) {
            let t = Math.max(
              ...i.map((t) => t.indexStart + t.reservedIndexCount)
            );
            if (t > e)
              throw Error(
                `BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`
              );
          }
          let s = this.geometry;
          s.dispose(),
            (this._maxVertexCount = t),
            (this._maxIndexCount = e),
            this._geometryInitialized &&
              ((this._geometryInitialized = !1),
              (this.geometry = new BufferGeometry()),
              this._initializeGeometry(s));
          let n = this.geometry;
          for (let t in (s.index &&
            copyArrayContents(s.index.array, n.index.array),
          s.attributes))
            copyArrayContents(s.attributes[t].array, n.attributes[t].array);
        }
        raycast(t, e) {
          let i = this._instanceInfo,
            r = this._geometryInfo,
            s = this.matrixWorld,
            n = this.geometry;
          (s$.material = this.material),
            (s$.geometry.index = n.index),
            (s$.geometry.attributes = n.attributes),
            null === s$.geometry.boundingBox &&
              (s$.geometry.boundingBox = new Box3()),
            null === s$.geometry.boundingSphere &&
              (s$.geometry.boundingSphere = new Sphere());
          for (let n = 0, a = i.length; n < a; n++) {
            if (!i[n].visible || !i[n].active) continue;
            let a = i[n].geometryIndex,
              o = r[a];
            s$.geometry.setDrawRange(o.start, o.count),
              this.getMatrixAt(n, s$.matrixWorld).premultiply(s),
              this.getBoundingBoxAt(a, s$.geometry.boundingBox),
              this.getBoundingSphereAt(a, s$.geometry.boundingSphere),
              s$.raycast(t, s0);
            for (let t = 0, i = s0.length; t < i; t++) {
              let i = s0[t];
              (i.object = this), (i.batchId = n), e.push(i);
            }
            s0.length = 0;
          }
          (s$.material = null),
            (s$.geometry.index = null),
            (s$.geometry.attributes = {}),
            s$.geometry.setDrawRange(0, 1 / 0);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.geometry = t.geometry.clone()),
            (this.perObjectFrustumCulled = t.perObjectFrustumCulled),
            (this.sortObjects = t.sortObjects),
            (this.boundingBox =
              null !== t.boundingBox ? t.boundingBox.clone() : null),
            (this.boundingSphere =
              null !== t.boundingSphere ? t.boundingSphere.clone() : null),
            (this._geometryInfo = t._geometryInfo.map((t) => ({
              ...t,
              boundingBox:
                null !== t.boundingBox ? t.boundingBox.clone() : null,
              boundingSphere:
                null !== t.boundingSphere ? t.boundingSphere.clone() : null,
            }))),
            (this._instanceInfo = t._instanceInfo.map((t) => ({ ...t }))),
            (this._maxInstanceCount = t._maxInstanceCount),
            (this._maxVertexCount = t._maxVertexCount),
            (this._maxIndexCount = t._maxIndexCount),
            (this._geometryInitialized = t._geometryInitialized),
            (this._geometryCount = t._geometryCount),
            (this._multiDrawCounts = t._multiDrawCounts.slice()),
            (this._multiDrawStarts = t._multiDrawStarts.slice()),
            (this._matricesTexture = t._matricesTexture.clone()),
            (this._matricesTexture.image.data =
              this._matricesTexture.image.data.slice()),
            null !== this._colorsTexture &&
              ((this._colorsTexture = t._colorsTexture.clone()),
              (this._colorsTexture.image.data =
                this._colorsTexture.image.data.slice())),
            this
          );
        }
        dispose() {
          return (
            this.geometry.dispose(),
            this._matricesTexture.dispose(),
            (this._matricesTexture = null),
            this._indirectTexture.dispose(),
            (this._indirectTexture = null),
            null !== this._colorsTexture &&
              (this._colorsTexture.dispose(), (this._colorsTexture = null)),
            this
          );
        }
        onBeforeRender(t, e, i, r, s) {
          if (
            !this._visibilityChanged &&
            !this.perObjectFrustumCulled &&
            !this.sortObjects
          )
            return;
          let n = r.getIndex(),
            a = null === n ? 1 : n.array.BYTES_PER_ELEMENT,
            o = this._instanceInfo,
            h = this._multiDrawStarts,
            l = this._multiDrawCounts,
            u = this._geometryInfo,
            c = this.perObjectFrustumCulled,
            d = this._indirectTexture,
            p = d.image.data;
          c &&
            (sW
              .multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse)
              .multiply(this.matrixWorld),
            sq.setFromProjectionMatrix(sW, t.coordinateSystem));
          let m = 0;
          if (this.sortObjects) {
            sW.copy(this.matrixWorld).invert(),
              sX.setFromMatrixPosition(i.matrixWorld).applyMatrix4(sW),
              sY
                .set(0, 0, -1)
                .transformDirection(i.matrixWorld)
                .transformDirection(sW);
            for (let t = 0, e = o.length; t < e; t++)
              if (o[t].visible && o[t].active) {
                let e = o[t].geometryIndex;
                this.getMatrixAt(t, sW),
                  this.getBoundingSphereAt(e, sZ).applyMatrix4(sW);
                let i = !1;
                if ((c && (i = !sq.intersectsSphere(sZ)), !i)) {
                  let i = u[e],
                    r = sQ.subVectors(sZ.center, sX).dot(sY);
                  sK.push(i.start, i.count, r, t);
                }
              }
            let t = sK.list,
              e = this.customSort;
            null === e
              ? t.sort(s.transparent ? sortTransparent : sortOpaque)
              : e.call(this, t, i);
            for (let e = 0, i = t.length; e < i; e++) {
              let i = t[e];
              (h[m] = i.start * a), (l[m] = i.count), (p[m] = i.index), m++;
            }
            sK.reset();
          } else
            for (let t = 0, e = o.length; t < e; t++)
              if (o[t].visible && o[t].active) {
                let e = o[t].geometryIndex,
                  i = !1;
                if (
                  (c &&
                    (this.getMatrixAt(t, sW),
                    this.getBoundingSphereAt(e, sZ).applyMatrix4(sW),
                    (i = !sq.intersectsSphere(sZ))),
                  !i)
                ) {
                  let i = u[e];
                  (h[m] = i.start * a), (l[m] = i.count), (p[m] = t), m++;
                }
              }
          (d.needsUpdate = !0),
            (this._multiDrawCount = m),
            (this._visibilityChanged = !1);
        }
        onBeforeShadow(t, e, i, r, s, n) {
          this.onBeforeRender(t, null, r, s, n);
        }
      };
      let LineBasicMaterial = class LineBasicMaterial extends Material {
        constructor(t) {
          super(),
            (this.isLineBasicMaterial = !0),
            (this.type = "LineBasicMaterial"),
            (this.color = new Color(16777215)),
            (this.map = null),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.linewidth = t.linewidth),
            (this.linecap = t.linecap),
            (this.linejoin = t.linejoin),
            (this.fog = t.fog),
            this
          );
        }
      };
      let s1 = new Vector3(),
        s3 = new Vector3(),
        s2 = new Matrix4(),
        s4 = new Ray(),
        s5 = new Sphere(),
        s6 = new Vector3(),
        s7 = new Vector3();
      let Line = class Line extends Object3D {
        constructor(t = new BufferGeometry(), e = new LineBasicMaterial()) {
          super(),
            (this.isLine = !0),
            (this.type = "Line"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.material = Array.isArray(t.material)
              ? t.material.slice()
              : t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        computeLineDistances() {
          let t = this.geometry;
          if (null === t.index) {
            let e = t.attributes.position,
              i = [0];
            for (let t = 1, r = e.count; t < r; t++)
              s1.fromBufferAttribute(e, t - 1),
                s3.fromBufferAttribute(e, t),
                (i[t] = i[t - 1]),
                (i[t] += s1.distanceTo(s3));
            t.setAttribute("lineDistance", new Float32BufferAttribute(i, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
        raycast(t, e) {
          let i = this.geometry,
            r = this.matrixWorld,
            s = t.params.Line.threshold,
            n = i.drawRange;
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            s5.copy(i.boundingSphere),
            s5.applyMatrix4(r),
            (s5.radius += s),
            !1 === t.ray.intersectsSphere(s5))
          )
            return;
          s2.copy(r).invert(), s4.copy(t.ray).applyMatrix4(s2);
          let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            h = this.isLineSegments ? 2 : 1,
            l = i.index,
            u = i.attributes,
            c = u.position;
          if (null !== l) {
            let i = Math.max(0, n.start),
              r = Math.min(l.count, n.start + n.count);
            for (let s = i, n = r - 1; s < n; s += h) {
              let i = l.getX(s),
                r = l.getX(s + 1),
                n = checkIntersection(this, t, s4, o, i, r);
              n && e.push(n);
            }
            if (this.isLineLoop) {
              let s = l.getX(r - 1),
                n = l.getX(i),
                a = checkIntersection(this, t, s4, o, s, n);
              a && e.push(a);
            }
          } else {
            let i = Math.max(0, n.start),
              r = Math.min(c.count, n.start + n.count);
            for (let s = i, n = r - 1; s < n; s += h) {
              let i = checkIntersection(this, t, s4, o, s, s + 1);
              i && e.push(i);
            }
            if (this.isLineLoop) {
              let s = checkIntersection(this, t, s4, o, r - 1, i);
              s && e.push(s);
            }
          }
        }
        updateMorphTargets() {
          let t = this.geometry,
            e = t.morphAttributes,
            i = Object.keys(e);
          if (i.length > 0) {
            let t = e[i[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, i = t.length; e < i; e++) {
                let i = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[i] = e);
              }
            }
          }
        }
      };
      function checkIntersection(t, e, i, r, s, n) {
        let a = t.geometry.attributes.position;
        s1.fromBufferAttribute(a, s), s3.fromBufferAttribute(a, n);
        let o = i.distanceSqToSegment(s1, s3, s6, s7);
        if (o > r) return;
        s6.applyMatrix4(t.matrixWorld);
        let h = e.ray.origin.distanceTo(s6);
        if (!(h < e.near) && !(h > e.far))
          return {
            distance: h,
            point: s7.clone().applyMatrix4(t.matrixWorld),
            index: s,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: t,
          };
      }
      let s8 = new Vector3(),
        s9 = new Vector3();
      let LineSegments = class LineSegments extends Line {
        constructor(t, e) {
          super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
        }
        computeLineDistances() {
          let t = this.geometry;
          if (null === t.index) {
            let e = t.attributes.position,
              i = [];
            for (let t = 0, r = e.count; t < r; t += 2)
              s8.fromBufferAttribute(e, t),
                s9.fromBufferAttribute(e, t + 1),
                (i[t] = 0 === t ? 0 : i[t - 1]),
                (i[t + 1] = i[t] + s8.distanceTo(s9));
            t.setAttribute("lineDistance", new Float32BufferAttribute(i, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
      };
      let LineLoop = class LineLoop extends Line {
        constructor(t, e) {
          super(t, e), (this.isLineLoop = !0), (this.type = "LineLoop");
        }
      };
      let PointsMaterial = class PointsMaterial extends Material {
        constructor(t) {
          super(),
            (this.isPointsMaterial = !0),
            (this.type = "PointsMaterial"),
            (this.color = new Color(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.size = t.size),
            (this.sizeAttenuation = t.sizeAttenuation),
            (this.fog = t.fog),
            this
          );
        }
      };
      let nt = new Matrix4(),
        ne = new Ray(),
        ni = new Sphere(),
        nr = new Vector3();
      let Points = class Points extends Object3D {
        constructor(t = new BufferGeometry(), e = new PointsMaterial()) {
          super(),
            (this.isPoints = !0),
            (this.type = "Points"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.material = Array.isArray(t.material)
              ? t.material.slice()
              : t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        raycast(t, e) {
          let i = this.geometry,
            r = this.matrixWorld,
            s = t.params.Points.threshold,
            n = i.drawRange;
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            ni.copy(i.boundingSphere),
            ni.applyMatrix4(r),
            (ni.radius += s),
            !1 === t.ray.intersectsSphere(ni))
          )
            return;
          nt.copy(r).invert(), ne.copy(t.ray).applyMatrix4(nt);
          let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            h = i.index,
            l = i.attributes,
            u = l.position;
          if (null !== h) {
            let i = Math.max(0, n.start),
              s = Math.min(h.count, n.start + n.count);
            for (let n = i; n < s; n++) {
              let i = h.getX(n);
              nr.fromBufferAttribute(u, i), testPoint(nr, i, o, r, t, e, this);
            }
          } else {
            let i = Math.max(0, n.start),
              s = Math.min(u.count, n.start + n.count);
            for (let n = i; n < s; n++)
              nr.fromBufferAttribute(u, n), testPoint(nr, n, o, r, t, e, this);
          }
        }
        updateMorphTargets() {
          let t = this.geometry,
            e = t.morphAttributes,
            i = Object.keys(e);
          if (i.length > 0) {
            let t = e[i[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, i = t.length; e < i; e++) {
                let i = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[i] = e);
              }
            }
          }
        }
      };
      function testPoint(t, e, i, r, s, n, a) {
        let o = ne.distanceSqToPoint(t);
        if (o < i) {
          let i = new Vector3();
          ne.closestPointToPoint(t, i), i.applyMatrix4(r);
          let h = s.ray.origin.distanceTo(i);
          if (h < s.near || h > s.far) return;
          n.push({
            distance: h,
            distanceToRay: Math.sqrt(o),
            point: i,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: a,
          });
        }
      }
      let Group = class Group extends Object3D {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      };
      let VideoTexture = class VideoTexture extends Texture {
        constructor(t, e, i, r, s, n, a, o, h) {
          super(t, e, i, r, s, n, a, o, h),
            (this.isVideoTexture = !0),
            (this.minFilter = void 0 !== n ? n : tI),
            (this.magFilter = void 0 !== s ? s : tI),
            (this.generateMipmaps = !1);
          let l = this;
          "requestVideoFrameCallback" in t &&
            t.requestVideoFrameCallback(function updateVideo() {
              (l.needsUpdate = !0), t.requestVideoFrameCallback(updateVideo);
            });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          let t = this.image;
          !1 == "requestVideoFrameCallback" in t &&
            t.readyState >= t.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      };
      let FramebufferTexture = class FramebufferTexture extends Texture {
        constructor(t, e) {
          super({ width: t, height: e }),
            (this.isFramebufferTexture = !0),
            (this.magFilter = t_),
            (this.minFilter = t_),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
        }
      };
      let CompressedTexture = class CompressedTexture extends Texture {
        constructor(t, e, i, r, s, n, a, o, h, l, u, c) {
          super(null, n, a, o, h, l, r, s, u, c),
            (this.isCompressedTexture = !0),
            (this.image = { width: e, height: i }),
            (this.mipmaps = t),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      };
      let CompressedArrayTexture = class CompressedArrayTexture extends CompressedTexture {
        constructor(t, e, i, r, s, n) {
          super(t, e, i, s, n),
            (this.isCompressedArrayTexture = !0),
            (this.image.depth = r),
            (this.wrapR = tS),
            (this.layerUpdates = new Set());
        }
        addLayerUpdate(t) {
          this.layerUpdates.add(t);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      };
      let CompressedCubeTexture = class CompressedCubeTexture extends CompressedTexture {
        constructor(t, e, i) {
          super(void 0, t[0].width, t[0].height, e, i, tg),
            (this.isCompressedCubeTexture = !0),
            (this.isCubeTexture = !0),
            (this.image = t);
        }
      };
      let CanvasTexture = class CanvasTexture extends Texture {
        constructor(t, e, i, r, s, n, a, o, h) {
          super(t, e, i, r, s, n, a, o, h),
            (this.isCanvasTexture = !0),
            (this.needsUpdate = !0);
        }
      };
      let DepthTexture = class DepthTexture extends Texture {
        constructor(t, e, i, r, s, n, a, o, h, l = tK) {
          if (l !== tK && l !== t$)
            throw Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === i && l === tK && (i = tD),
            void 0 === i && l === t$ && (i = tH),
            super(null, r, s, n, a, o, l, i, h),
            (this.isDepthTexture = !0),
            (this.image = { width: t, height: e }),
            (this.magFilter = void 0 !== a ? a : t_),
            (this.minFilter = void 0 !== o ? o : t_),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
        }
        copy(t) {
          return (
            super.copy(t), (this.compareFunction = t.compareFunction), this
          );
        }
        toJSON(t) {
          let e = super.toJSON(t);
          return (
            null !== this.compareFunction &&
              (e.compareFunction = this.compareFunction),
            e
          );
        }
      };
      let Curve = class Curve {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(t, e) {
          let i = this.getUtoTmapping(t);
          return this.getPoint(i, e);
        }
        getPoints(t = 5) {
          let e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
          return e;
        }
        getSpacedPoints(t = 5) {
          let e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
          return e;
        }
        getLength() {
          let t = this.getLengths();
          return t[t.length - 1];
        }
        getLengths(t = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === t + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          let e = [],
            i,
            r = this.getPoint(0),
            s = 0;
          e.push(0);
          for (let n = 1; n <= t; n++)
            e.push((s += (i = this.getPoint(n / t)).distanceTo(r))), (r = i);
          return (this.cacheArcLengths = e), e;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(t, e) {
          let i;
          let r = this.getLengths(),
            s = 0,
            n = r.length;
          i = e || t * r[n - 1];
          let a = 0,
            o = n - 1,
            h;
          for (; a <= o; )
            if ((h = r[(s = Math.floor(a + (o - a) / 2))] - i) < 0) a = s + 1;
            else if (h > 0) o = s - 1;
            else {
              o = s;
              break;
            }
          if (r[(s = o)] === i) return s / (n - 1);
          let l = r[s],
            u = r[s + 1],
            c = (s + (i - l) / (u - l)) / (n - 1);
          return c;
        }
        getTangent(t, e) {
          let i = t - 1e-4,
            r = t + 1e-4;
          i < 0 && (i = 0), r > 1 && (r = 1);
          let s = this.getPoint(i),
            n = this.getPoint(r),
            a = e || (s.isVector2 ? new Vector2() : new Vector3());
          return a.copy(n).sub(s).normalize(), a;
        }
        getTangentAt(t, e) {
          let i = this.getUtoTmapping(t);
          return this.getTangent(i, e);
        }
        computeFrenetFrames(t, e) {
          let i = new Vector3(),
            r = [],
            s = [],
            n = [],
            a = new Vector3(),
            o = new Matrix4();
          for (let e = 0; e <= t; e++) {
            let i = e / t;
            r[e] = this.getTangentAt(i, new Vector3());
          }
          (s[0] = new Vector3()), (n[0] = new Vector3());
          let h = Number.MAX_VALUE,
            l = Math.abs(r[0].x),
            u = Math.abs(r[0].y),
            c = Math.abs(r[0].z);
          l <= h && ((h = l), i.set(1, 0, 0)),
            u <= h && ((h = u), i.set(0, 1, 0)),
            c <= h && i.set(0, 0, 1),
            a.crossVectors(r[0], i).normalize(),
            s[0].crossVectors(r[0], a),
            n[0].crossVectors(r[0], s[0]);
          for (let e = 1; e <= t; e++) {
            if (
              ((s[e] = s[e - 1].clone()),
              (n[e] = n[e - 1].clone()),
              a.crossVectors(r[e - 1], r[e]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              let t = Math.acos(clamp(r[e - 1].dot(r[e]), -1, 1));
              s[e].applyMatrix4(o.makeRotationAxis(a, t));
            }
            n[e].crossVectors(r[e], s[e]);
          }
          if (!0 === e) {
            let e = Math.acos(clamp(s[0].dot(s[t]), -1, 1));
            (e /= t), r[0].dot(a.crossVectors(s[0], s[t])) > 0 && (e = -e);
            for (let i = 1; i <= t; i++)
              s[i].applyMatrix4(o.makeRotationAxis(r[i], e * i)),
                n[i].crossVectors(r[i], s[i]);
          }
          return { tangents: r, normals: s, binormals: n };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
        toJSON() {
          let t = {
            metadata: {
              version: 4.6,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (t.arcLengthDivisions = this.arcLengthDivisions),
            (t.type = this.type),
            t
          );
        }
        fromJSON(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
      };
      let EllipseCurve = class EllipseCurve extends Curve {
        constructor(
          t = 0,
          e = 0,
          i = 1,
          r = 1,
          s = 0,
          n = 2 * Math.PI,
          a = !1,
          o = 0
        ) {
          super(),
            (this.isEllipseCurve = !0),
            (this.type = "EllipseCurve"),
            (this.aX = t),
            (this.aY = e),
            (this.xRadius = i),
            (this.yRadius = r),
            (this.aStartAngle = s),
            (this.aEndAngle = n),
            (this.aClockwise = a),
            (this.aRotation = o);
        }
        getPoint(t, e = new Vector2()) {
          let i = 2 * Math.PI,
            r = this.aEndAngle - this.aStartAngle,
            s = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (r = s ? 0 : i),
            !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
          let n = this.aStartAngle + t * r,
            a = this.aX + this.xRadius * Math.cos(n),
            o = this.aY + this.yRadius * Math.sin(n);
          if (0 !== this.aRotation) {
            let t = Math.cos(this.aRotation),
              e = Math.sin(this.aRotation),
              i = a - this.aX,
              r = o - this.aY;
            (a = i * t - r * e + this.aX), (o = i * e + r * t + this.aY);
          }
          return e.set(a, o);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }
        toJSON() {
          let t = super.toJSON();
          return (
            (t.aX = this.aX),
            (t.aY = this.aY),
            (t.xRadius = this.xRadius),
            (t.yRadius = this.yRadius),
            (t.aStartAngle = this.aStartAngle),
            (t.aEndAngle = this.aEndAngle),
            (t.aClockwise = this.aClockwise),
            (t.aRotation = this.aRotation),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }
      };
      let ArcCurve = class ArcCurve extends EllipseCurve {
        constructor(t, e, i, r, s, n) {
          super(t, e, i, i, r, s, n),
            (this.isArcCurve = !0),
            (this.type = "ArcCurve");
        }
      };
      function CubicPoly() {
        let t = 0,
          e = 0,
          i = 0,
          r = 0;
        function init(s, n, a, o) {
          (t = s),
            (e = a),
            (i = -3 * s + 3 * n - 2 * a - o),
            (r = 2 * s - 2 * n + a + o);
        }
        return {
          initCatmullRom: function (t, e, i, r, s) {
            init(e, i, s * (i - t), s * (r - e));
          },
          initNonuniformCatmullRom: function (t, e, i, r, s, n, a) {
            let o = (e - t) / s - (i - t) / (s + n) + (i - e) / n,
              h = (i - e) / n - (r - e) / (n + a) + (r - i) / a;
            init(e, i, (o *= n), (h *= n));
          },
          calc: function (s) {
            let n = s * s;
            return t + e * s + i * n + r * (n * s);
          },
        };
      }
      let ns = new Vector3(),
        nn = new CubicPoly(),
        na = new CubicPoly(),
        no = new CubicPoly();
      let CatmullRomCurve3 = class CatmullRomCurve3 extends Curve {
        constructor(t = [], e = !1, i = "centripetal", r = 0.5) {
          super(),
            (this.isCatmullRomCurve3 = !0),
            (this.type = "CatmullRomCurve3"),
            (this.points = t),
            (this.closed = e),
            (this.curveType = i),
            (this.tension = r);
        }
        getPoint(t, e = new Vector3()) {
          let i, r;
          let s = this.points,
            n = s.length,
            a = (n - (this.closed ? 0 : 1)) * t,
            o = Math.floor(a),
            h = a - o;
          this.closed
            ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n)
            : 0 === h && o === n - 1 && ((o = n - 2), (h = 1)),
            this.closed || o > 0
              ? (i = s[(o - 1) % n])
              : (ns.subVectors(s[0], s[1]).add(s[0]), (i = ns));
          let l = s[o % n],
            u = s[(o + 1) % n];
          if (
            (this.closed || o + 2 < n
              ? (r = s[(o + 2) % n])
              : (ns.subVectors(s[n - 1], s[n - 2]).add(s[n - 1]), (r = ns)),
            "centripetal" === this.curveType || "chordal" === this.curveType)
          ) {
            let t = "chordal" === this.curveType ? 0.5 : 0.25,
              e = Math.pow(i.distanceToSquared(l), t),
              s = Math.pow(l.distanceToSquared(u), t),
              n = Math.pow(u.distanceToSquared(r), t);
            s < 1e-4 && (s = 1),
              e < 1e-4 && (e = s),
              n < 1e-4 && (n = s),
              nn.initNonuniformCatmullRom(i.x, l.x, u.x, r.x, e, s, n),
              na.initNonuniformCatmullRom(i.y, l.y, u.y, r.y, e, s, n),
              no.initNonuniformCatmullRom(i.z, l.z, u.z, r.z, e, s, n);
          } else
            "catmullrom" === this.curveType &&
              (nn.initCatmullRom(i.x, l.x, u.x, r.x, this.tension),
              na.initCatmullRom(i.y, l.y, u.y, r.y, this.tension),
              no.initCatmullRom(i.z, l.z, u.z, r.z, this.tension));
          return e.set(nn.calc(h), na.calc(h), no.calc(h)), e;
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            let i = t.points[e];
            this.points.push(i.clone());
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
        toJSON() {
          let t = super.toJSON();
          t.points = [];
          for (let e = 0, i = this.points.length; e < i; e++) {
            let i = this.points[e];
            t.points.push(i.toArray());
          }
          return (
            (t.closed = this.closed),
            (t.curveType = this.curveType),
            (t.tension = this.tension),
            t
          );
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            let i = t.points[e];
            this.points.push(new Vector3().fromArray(i));
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
      };
      function CatmullRom(t, e, i, r, s) {
        let n = (r - e) * 0.5,
          a = (s - i) * 0.5,
          o = t * t;
        return (
          (2 * i - 2 * r + n + a) * (t * o) +
          (-3 * i + 3 * r - 2 * n - a) * o +
          n * t +
          i
        );
      }
      function QuadraticBezier(t, e, i, r) {
        return (
          (function (t, e) {
            let i = 1 - t;
            return i * i * e;
          })(t, e) +
          2 * (1 - t) * t * i +
          t * t * r
        );
      }
      function CubicBezier(t, e, i, r, s) {
        return (
          (function (t, e) {
            let i = 1 - t;
            return i * i * i * e;
          })(t, e) +
          (function (t, e) {
            let i = 1 - t;
            return 3 * i * i * t * e;
          })(t, i) +
          3 * (1 - t) * t * t * r +
          t * t * t * s
        );
      }
      let CubicBezierCurve = class CubicBezierCurve extends Curve {
        constructor(
          t = new Vector2(),
          e = new Vector2(),
          i = new Vector2(),
          r = new Vector2()
        ) {
          super(),
            (this.isCubicBezierCurve = !0),
            (this.type = "CubicBezierCurve"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i),
            (this.v3 = r);
        }
        getPoint(t, e = new Vector2()) {
          let i = this.v0,
            r = this.v1,
            s = this.v2,
            n = this.v3;
          return (
            e.set(
              CubicBezier(t, i.x, r.x, s.x, n.x),
              CubicBezier(t, i.y, r.y, s.y, n.y)
            ),
            e
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }
        toJSON() {
          let t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }
      };
      let CubicBezierCurve3 = class CubicBezierCurve3 extends Curve {
        constructor(
          t = new Vector3(),
          e = new Vector3(),
          i = new Vector3(),
          r = new Vector3()
        ) {
          super(),
            (this.isCubicBezierCurve3 = !0),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i),
            (this.v3 = r);
        }
        getPoint(t, e = new Vector3()) {
          let i = this.v0,
            r = this.v1,
            s = this.v2,
            n = this.v3;
          return (
            e.set(
              CubicBezier(t, i.x, r.x, s.x, n.x),
              CubicBezier(t, i.y, r.y, s.y, n.y),
              CubicBezier(t, i.z, r.z, s.z, n.z)
            ),
            e
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }
        toJSON() {
          let t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }
      };
      let LineCurve = class LineCurve extends Curve {
        constructor(t = new Vector2(), e = new Vector2()) {
          super(),
            (this.isLineCurve = !0),
            (this.type = "LineCurve"),
            (this.v1 = t),
            (this.v2 = e);
        }
        getPoint(t, e = new Vector2()) {
          return (
            1 === t
              ? e.copy(this.v2)
              : (e.copy(this.v2).sub(this.v1),
                e.multiplyScalar(t).add(this.v1)),
            e
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        getTangent(t, e = new Vector2()) {
          return e.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(t, e) {
          return this.getTangent(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          let t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      };
      let LineCurve3 = class LineCurve3 extends Curve {
        constructor(t = new Vector3(), e = new Vector3()) {
          super(),
            (this.isLineCurve3 = !0),
            (this.type = "LineCurve3"),
            (this.v1 = t),
            (this.v2 = e);
        }
        getPoint(t, e = new Vector3()) {
          return (
            1 === t
              ? e.copy(this.v2)
              : (e.copy(this.v2).sub(this.v1),
                e.multiplyScalar(t).add(this.v1)),
            e
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        getTangent(t, e = new Vector3()) {
          return e.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(t, e) {
          return this.getTangent(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          let t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      };
      let QuadraticBezierCurve = class QuadraticBezierCurve extends Curve {
        constructor(t = new Vector2(), e = new Vector2(), i = new Vector2()) {
          super(),
            (this.isQuadraticBezierCurve = !0),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i);
        }
        getPoint(t, e = new Vector2()) {
          let i = this.v0,
            r = this.v1,
            s = this.v2;
          return (
            e.set(
              QuadraticBezier(t, i.x, r.x, s.x),
              QuadraticBezier(t, i.y, r.y, s.y)
            ),
            e
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          let t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      };
      let QuadraticBezierCurve3 = class QuadraticBezierCurve3 extends Curve {
        constructor(t = new Vector3(), e = new Vector3(), i = new Vector3()) {
          super(),
            (this.isQuadraticBezierCurve3 = !0),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = i);
        }
        getPoint(t, e = new Vector3()) {
          let i = this.v0,
            r = this.v1,
            s = this.v2;
          return (
            e.set(
              QuadraticBezier(t, i.x, r.x, s.x),
              QuadraticBezier(t, i.y, r.y, s.y),
              QuadraticBezier(t, i.z, r.z, s.z)
            ),
            e
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          let t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      };
      let SplineCurve = class SplineCurve extends Curve {
        constructor(t = []) {
          super(),
            (this.isSplineCurve = !0),
            (this.type = "SplineCurve"),
            (this.points = t);
        }
        getPoint(t, e = new Vector2()) {
          let i = this.points,
            r = (i.length - 1) * t,
            s = Math.floor(r),
            n = r - s,
            a = i[0 === s ? s : s - 1],
            o = i[s],
            h = i[s > i.length - 2 ? i.length - 1 : s + 1],
            l = i[s > i.length - 3 ? i.length - 1 : s + 2];
          return (
            e.set(
              CatmullRom(n, a.x, o.x, h.x, l.x),
              CatmullRom(n, a.y, o.y, h.y, l.y)
            ),
            e
          );
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            let i = t.points[e];
            this.points.push(i.clone());
          }
          return this;
        }
        toJSON() {
          let t = super.toJSON();
          t.points = [];
          for (let e = 0, i = this.points.length; e < i; e++) {
            let i = this.points[e];
            t.points.push(i.toArray());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, i = t.points.length; e < i; e++) {
            let i = t.points[e];
            this.points.push(new Vector2().fromArray(i));
          }
          return this;
        }
      };
      var nh = Object.freeze({
        __proto__: null,
        ArcCurve: ArcCurve,
        CatmullRomCurve3: CatmullRomCurve3,
        CubicBezierCurve: CubicBezierCurve,
        CubicBezierCurve3: CubicBezierCurve3,
        EllipseCurve: EllipseCurve,
        LineCurve: LineCurve,
        LineCurve3: LineCurve3,
        QuadraticBezierCurve: QuadraticBezierCurve,
        QuadraticBezierCurve3: QuadraticBezierCurve3,
        SplineCurve: SplineCurve,
      });
      let CurvePath = class CurvePath extends Curve {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(t) {
          this.curves.push(t);
        }
        closePath() {
          let t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
          if (!t.equals(e)) {
            let i = !0 === t.isVector2 ? "LineCurve" : "LineCurve3";
            this.curves.push(new nh[i](e, t));
          }
          return this;
        }
        getPoint(t, e) {
          let i = t * this.getLength(),
            r = this.getCurveLengths(),
            s = 0;
          for (; s < r.length; ) {
            if (r[s] >= i) {
              let t = r[s] - i,
                n = this.curves[s],
                a = n.getLength(),
                o = 0 === a ? 0 : 1 - t / a;
              return n.getPointAt(o, e);
            }
            s++;
          }
          return null;
        }
        getLength() {
          let t = this.getCurveLengths();
          return t[t.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          let t = [],
            e = 0;
          for (let i = 0, r = this.curves.length; i < r; i++)
            t.push((e += this.curves[i].getLength()));
          return (this.cacheLengths = t), t;
        }
        getSpacedPoints(t = 40) {
          let e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
          return this.autoClose && e.push(e[0]), e;
        }
        getPoints(t = 12) {
          let e;
          let i = [];
          for (let r = 0, s = this.curves; r < s.length; r++) {
            let n = s[r],
              a = n.isEllipseCurve
                ? 2 * t
                : n.isLineCurve || n.isLineCurve3
                ? 1
                : n.isSplineCurve
                ? t * n.points.length
                : t,
              o = n.getPoints(a);
            for (let t = 0; t < o.length; t++) {
              let r = o[t];
              (e && e.equals(r)) || (i.push(r), (e = r));
            }
          }
          return (
            this.autoClose &&
              i.length > 1 &&
              !i[i.length - 1].equals(i[0]) &&
              i.push(i[0]),
            i
          );
        }
        copy(t) {
          super.copy(t), (this.curves = []);
          for (let e = 0, i = t.curves.length; e < i; e++) {
            let i = t.curves[e];
            this.curves.push(i.clone());
          }
          return (this.autoClose = t.autoClose), this;
        }
        toJSON() {
          let t = super.toJSON();
          (t.autoClose = this.autoClose), (t.curves = []);
          for (let e = 0, i = this.curves.length; e < i; e++) {
            let i = this.curves[e];
            t.curves.push(i.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
          for (let e = 0, i = t.curves.length; e < i; e++) {
            let i = t.curves[e];
            this.curves.push(new nh[i.type]().fromJSON(i));
          }
          return this;
        }
      };
      let Path = class Path extends CurvePath {
        constructor(t) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new Vector2()),
            t && this.setFromPoints(t);
        }
        setFromPoints(t) {
          this.moveTo(t[0].x, t[0].y);
          for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
          return this;
        }
        moveTo(t, e) {
          return this.currentPoint.set(t, e), this;
        }
        lineTo(t, e) {
          let i = new LineCurve(this.currentPoint.clone(), new Vector2(t, e));
          return this.curves.push(i), this.currentPoint.set(t, e), this;
        }
        quadraticCurveTo(t, e, i, r) {
          let s = new QuadraticBezierCurve(
            this.currentPoint.clone(),
            new Vector2(t, e),
            new Vector2(i, r)
          );
          return this.curves.push(s), this.currentPoint.set(i, r), this;
        }
        bezierCurveTo(t, e, i, r, s, n) {
          let a = new CubicBezierCurve(
            this.currentPoint.clone(),
            new Vector2(t, e),
            new Vector2(i, r),
            new Vector2(s, n)
          );
          return this.curves.push(a), this.currentPoint.set(s, n), this;
        }
        splineThru(t) {
          let e = [this.currentPoint.clone()].concat(t),
            i = new SplineCurve(e);
          return (
            this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this
          );
        }
        arc(t, e, i, r, s, n) {
          let a = this.currentPoint.x,
            o = this.currentPoint.y;
          return this.absarc(t + a, e + o, i, r, s, n), this;
        }
        absarc(t, e, i, r, s, n) {
          return this.absellipse(t, e, i, i, r, s, n), this;
        }
        ellipse(t, e, i, r, s, n, a, o) {
          let h = this.currentPoint.x,
            l = this.currentPoint.y;
          return this.absellipse(t + h, e + l, i, r, s, n, a, o), this;
        }
        absellipse(t, e, i, r, s, n, a, o) {
          let h = new EllipseCurve(t, e, i, r, s, n, a, o);
          if (this.curves.length > 0) {
            let t = h.getPoint(0);
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
          }
          this.curves.push(h);
          let l = h.getPoint(1);
          return this.currentPoint.copy(l), this;
        }
        copy(t) {
          return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
        }
        toJSON() {
          let t = super.toJSON();
          return (t.currentPoint = this.currentPoint.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
          );
        }
      };
      let LatheGeometry = class LatheGeometry extends BufferGeometry {
        constructor(
          t = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)],
          e = 12,
          i = 0,
          r = 2 * Math.PI
        ) {
          super(),
            (this.type = "LatheGeometry"),
            (this.parameters = {
              points: t,
              segments: e,
              phiStart: i,
              phiLength: r,
            }),
            (e = Math.floor(e)),
            (r = clamp(r, 0, 2 * Math.PI));
          let s = [],
            n = [],
            a = [],
            o = [],
            h = [],
            l = 1 / e,
            u = new Vector3(),
            c = new Vector2(),
            d = new Vector3(),
            p = new Vector3(),
            m = new Vector3(),
            f = 0,
            y = 0;
          for (let e = 0; e <= t.length - 1; e++)
            switch (e) {
              case 0:
                (f = t[e + 1].x - t[e].x),
                  (y = t[e + 1].y - t[e].y),
                  (d.x = 1 * y),
                  (d.y = -f),
                  (d.z = 0 * y),
                  m.copy(d),
                  d.normalize(),
                  o.push(d.x, d.y, d.z);
                break;
              case t.length - 1:
                o.push(m.x, m.y, m.z);
                break;
              default:
                (f = t[e + 1].x - t[e].x),
                  (y = t[e + 1].y - t[e].y),
                  (d.x = 1 * y),
                  (d.y = -f),
                  (d.z = 0 * y),
                  p.copy(d),
                  (d.x += m.x),
                  (d.y += m.y),
                  (d.z += m.z),
                  d.normalize(),
                  o.push(d.x, d.y, d.z),
                  m.copy(p);
            }
          for (let s = 0; s <= e; s++) {
            let d = i + s * l * r,
              p = Math.sin(d),
              m = Math.cos(d);
            for (let i = 0; i <= t.length - 1; i++) {
              (u.x = t[i].x * p),
                (u.y = t[i].y),
                (u.z = t[i].x * m),
                n.push(u.x, u.y, u.z),
                (c.x = s / e),
                (c.y = i / (t.length - 1)),
                a.push(c.x, c.y);
              let r = o[3 * i + 0] * p,
                l = o[3 * i + 1],
                d = o[3 * i + 0] * m;
              h.push(r, l, d);
            }
          }
          for (let i = 0; i < e; i++)
            for (let e = 0; e < t.length - 1; e++) {
              let r = e + i * t.length,
                n = r + t.length,
                a = r + t.length + 1,
                o = r + 1;
              s.push(r, n, o), s.push(a, o, n);
            }
          this.setIndex(s),
            this.setAttribute("position", new Float32BufferAttribute(n, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(a, 2)),
            this.setAttribute("normal", new Float32BufferAttribute(h, 3));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new LatheGeometry(
            t.points,
            t.segments,
            t.phiStart,
            t.phiLength
          );
        }
      };
      let CapsuleGeometry = class CapsuleGeometry extends LatheGeometry {
        constructor(t = 1, e = 1, i = 4, r = 8) {
          let s = new Path();
          s.absarc(0, -e / 2, t, 1.5 * Math.PI, 0),
            s.absarc(0, e / 2, t, 0, 0.5 * Math.PI),
            super(s.getPoints(i), r),
            (this.type = "CapsuleGeometry"),
            (this.parameters = {
              radius: t,
              length: e,
              capSegments: i,
              radialSegments: r,
            });
        }
        static fromJSON(t) {
          return new CapsuleGeometry(
            t.radius,
            t.length,
            t.capSegments,
            t.radialSegments
          );
        }
      };
      let CircleGeometry = class CircleGeometry extends BufferGeometry {
        constructor(t = 1, e = 32, i = 0, r = 2 * Math.PI) {
          super(),
            (this.type = "CircleGeometry"),
            (this.parameters = {
              radius: t,
              segments: e,
              thetaStart: i,
              thetaLength: r,
            }),
            (e = Math.max(3, e));
          let s = [],
            n = [],
            a = [],
            o = [],
            h = new Vector3(),
            l = new Vector2();
          n.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5);
          for (let s = 0, u = 3; s <= e; s++, u += 3) {
            let c = i + (s / e) * r;
            (h.x = t * Math.cos(c)),
              (h.y = t * Math.sin(c)),
              n.push(h.x, h.y, h.z),
              a.push(0, 0, 1),
              (l.x = (n[u] / t + 1) / 2),
              (l.y = (n[u + 1] / t + 1) / 2),
              o.push(l.x, l.y);
          }
          for (let t = 1; t <= e; t++) s.push(t, t + 1, 0);
          this.setIndex(s),
            this.setAttribute("position", new Float32BufferAttribute(n, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(a, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(o, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new CircleGeometry(
            t.radius,
            t.segments,
            t.thetaStart,
            t.thetaLength
          );
        }
      };
      let CylinderGeometry = class CylinderGeometry extends BufferGeometry {
        constructor(
          t = 1,
          e = 1,
          i = 1,
          r = 32,
          s = 1,
          n = !1,
          a = 0,
          o = 2 * Math.PI
        ) {
          super(),
            (this.type = "CylinderGeometry"),
            (this.parameters = {
              radiusTop: t,
              radiusBottom: e,
              height: i,
              radialSegments: r,
              heightSegments: s,
              openEnded: n,
              thetaStart: a,
              thetaLength: o,
            });
          let h = this;
          (r = Math.floor(r)), (s = Math.floor(s));
          let l = [],
            u = [],
            c = [],
            d = [],
            p = 0,
            m = [],
            f = i / 2,
            y = 0;
          function generateCap(i) {
            let s = p,
              n = new Vector2(),
              m = new Vector3(),
              g = 0,
              x = !0 === i ? t : e,
              b = !0 === i ? 1 : -1;
            for (let t = 1; t <= r; t++)
              u.push(0, f * b, 0), c.push(0, b, 0), d.push(0.5, 0.5), p++;
            let M = p;
            for (let t = 0; t <= r; t++) {
              let e = t / r,
                i = e * o + a,
                s = Math.cos(i),
                h = Math.sin(i);
              (m.x = x * h),
                (m.y = f * b),
                (m.z = x * s),
                u.push(m.x, m.y, m.z),
                c.push(0, b, 0),
                (n.x = 0.5 * s + 0.5),
                (n.y = 0.5 * h * b + 0.5),
                d.push(n.x, n.y),
                p++;
            }
            for (let t = 0; t < r; t++) {
              let e = s + t,
                r = M + t;
              !0 === i ? l.push(r, r + 1, e) : l.push(r + 1, r, e), (g += 3);
            }
            h.addGroup(y, g, !0 === i ? 1 : 2), (y += g);
          }
          (function () {
            let n = new Vector3(),
              g = new Vector3(),
              x = 0,
              b = (e - t) / i;
            for (let h = 0; h <= s; h++) {
              let l = [],
                y = h / s,
                x = y * (e - t) + t;
              for (let t = 0; t <= r; t++) {
                let e = t / r,
                  s = e * o + a,
                  h = Math.sin(s),
                  m = Math.cos(s);
                (g.x = x * h),
                  (g.y = -y * i + f),
                  (g.z = x * m),
                  u.push(g.x, g.y, g.z),
                  n.set(h, b, m).normalize(),
                  c.push(n.x, n.y, n.z),
                  d.push(e, 1 - y),
                  l.push(p++);
              }
              m.push(l);
            }
            for (let i = 0; i < r; i++)
              for (let r = 0; r < s; r++) {
                let n = m[r][i],
                  a = m[r + 1][i],
                  o = m[r + 1][i + 1],
                  h = m[r][i + 1];
                (t > 0 || 0 !== r) && (l.push(n, a, h), (x += 3)),
                  (e > 0 || r !== s - 1) && (l.push(a, o, h), (x += 3));
              }
            h.addGroup(y, x, 0), (y += x);
          })(),
            !1 === n && (t > 0 && generateCap(!0), e > 0 && generateCap(!1)),
            this.setIndex(l),
            this.setAttribute("position", new Float32BufferAttribute(u, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(c, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(d, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new CylinderGeometry(
            t.radiusTop,
            t.radiusBottom,
            t.height,
            t.radialSegments,
            t.heightSegments,
            t.openEnded,
            t.thetaStart,
            t.thetaLength
          );
        }
      };
      let ConeGeometry = class ConeGeometry extends CylinderGeometry {
        constructor(
          t = 1,
          e = 1,
          i = 32,
          r = 1,
          s = !1,
          n = 0,
          a = 2 * Math.PI
        ) {
          super(0, t, e, i, r, s, n, a),
            (this.type = "ConeGeometry"),
            (this.parameters = {
              radius: t,
              height: e,
              radialSegments: i,
              heightSegments: r,
              openEnded: s,
              thetaStart: n,
              thetaLength: a,
            });
        }
        static fromJSON(t) {
          return new ConeGeometry(
            t.radius,
            t.height,
            t.radialSegments,
            t.heightSegments,
            t.openEnded,
            t.thetaStart,
            t.thetaLength
          );
        }
      };
      let PolyhedronGeometry = class PolyhedronGeometry extends BufferGeometry {
        constructor(t = [], e = [], i = 1, r = 0) {
          super(),
            (this.type = "PolyhedronGeometry"),
            (this.parameters = {
              vertices: t,
              indices: e,
              radius: i,
              detail: r,
            });
          let s = [],
            n = [];
          function pushVertex(t) {
            s.push(t.x, t.y, t.z);
          }
          function getVertexByIndex(e, i) {
            let r = 3 * e;
            (i.x = t[r + 0]), (i.y = t[r + 1]), (i.z = t[r + 2]);
          }
          function correctUV(t, e, i, r) {
            r < 0 && 1 === t.x && (n[e] = t.x - 1),
              0 === i.x && 0 === i.z && (n[e] = r / 2 / Math.PI + 0.5);
          }
          function azimuth(t) {
            return Math.atan2(t.z, -t.x);
          }
          (function (t) {
            let i = new Vector3(),
              r = new Vector3(),
              s = new Vector3();
            for (let n = 0; n < e.length; n += 3)
              getVertexByIndex(e[n + 0], i),
                getVertexByIndex(e[n + 1], r),
                getVertexByIndex(e[n + 2], s),
                (function (t, e, i, r) {
                  let s = r + 1,
                    n = [];
                  for (let r = 0; r <= s; r++) {
                    n[r] = [];
                    let a = t.clone().lerp(i, r / s),
                      o = e.clone().lerp(i, r / s),
                      h = s - r;
                    for (let t = 0; t <= h; t++)
                      0 === t && r === s
                        ? (n[r][t] = a)
                        : (n[r][t] = a.clone().lerp(o, t / h));
                  }
                  for (let t = 0; t < s; t++)
                    for (let e = 0; e < 2 * (s - t) - 1; e++) {
                      let i = Math.floor(e / 2);
                      e % 2 == 0
                        ? (pushVertex(n[t][i + 1]),
                          pushVertex(n[t + 1][i]),
                          pushVertex(n[t][i]))
                        : (pushVertex(n[t][i + 1]),
                          pushVertex(n[t + 1][i + 1]),
                          pushVertex(n[t + 1][i]));
                    }
                })(i, r, s, t);
          })(r),
            (function (t) {
              let e = new Vector3();
              for (let i = 0; i < s.length; i += 3)
                (e.x = s[i + 0]),
                  (e.y = s[i + 1]),
                  (e.z = s[i + 2]),
                  e.normalize().multiplyScalar(t),
                  (s[i + 0] = e.x),
                  (s[i + 1] = e.y),
                  (s[i + 2] = e.z);
            })(i),
            (function () {
              let t = new Vector3();
              for (let e = 0; e < s.length; e += 3) {
                (t.x = s[e + 0]), (t.y = s[e + 1]), (t.z = s[e + 2]);
                let i = azimuth(t) / 2 / Math.PI + 0.5,
                  r =
                    Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) /
                      Math.PI +
                    0.5;
                n.push(i, 1 - r);
              }
              (function () {
                let t = new Vector3(),
                  e = new Vector3(),
                  i = new Vector3(),
                  r = new Vector3(),
                  a = new Vector2(),
                  o = new Vector2(),
                  h = new Vector2();
                for (let l = 0, u = 0; l < s.length; l += 9, u += 6) {
                  t.set(s[l + 0], s[l + 1], s[l + 2]),
                    e.set(s[l + 3], s[l + 4], s[l + 5]),
                    i.set(s[l + 6], s[l + 7], s[l + 8]),
                    a.set(n[u + 0], n[u + 1]),
                    o.set(n[u + 2], n[u + 3]),
                    h.set(n[u + 4], n[u + 5]),
                    r.copy(t).add(e).add(i).divideScalar(3);
                  let c = azimuth(r);
                  correctUV(a, u + 0, t, c),
                    correctUV(o, u + 2, e, c),
                    correctUV(h, u + 4, i, c);
                }
              })(),
                (function () {
                  for (let t = 0; t < n.length; t += 6) {
                    let e = n[t + 0],
                      i = n[t + 2],
                      r = n[t + 4],
                      s = Math.max(e, i, r),
                      a = Math.min(e, i, r);
                    s > 0.9 &&
                      a < 0.1 &&
                      (e < 0.2 && (n[t + 0] += 1),
                      i < 0.2 && (n[t + 2] += 1),
                      r < 0.2 && (n[t + 4] += 1));
                  }
                })();
            })(),
            this.setAttribute("position", new Float32BufferAttribute(s, 3)),
            this.setAttribute(
              "normal",
              new Float32BufferAttribute(s.slice(), 3)
            ),
            this.setAttribute("uv", new Float32BufferAttribute(n, 2)),
            0 === r ? this.computeVertexNormals() : this.normalizeNormals();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new PolyhedronGeometry(
            t.vertices,
            t.indices,
            t.radius,
            t.details
          );
        }
      };
      let DodecahedronGeometry = class DodecahedronGeometry extends PolyhedronGeometry {
        constructor(t = 1, e = 0) {
          let i = (1 + Math.sqrt(5)) / 2,
            r = 1 / i,
            s = [
              -1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              1,
              1,
              1,
              0,
              -r,
              -i,
              0,
              -r,
              i,
              0,
              r,
              -i,
              0,
              r,
              i,
              -r,
              -i,
              0,
              -r,
              i,
              0,
              r,
              -i,
              0,
              r,
              i,
              0,
              -i,
              0,
              -r,
              i,
              0,
              -r,
              -i,
              0,
              r,
              i,
              0,
              r,
            ];
          super(
            s,
            [
              3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17,
              4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12,
              1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18,
              2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4,
              12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14,
              4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
            ],
            t,
            e
          ),
            (this.type = "DodecahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new DodecahedronGeometry(t.radius, t.detail);
        }
      };
      let nl = new Vector3(),
        nu = new Vector3(),
        nc = new Vector3(),
        nd = new Triangle();
      let EdgesGeometry = class EdgesGeometry extends BufferGeometry {
        constructor(t = null, e = 1) {
          if (
            (super(),
            (this.type = "EdgesGeometry"),
            (this.parameters = { geometry: t, thresholdAngle: e }),
            null !== t)
          ) {
            let i = Math.cos(iI * e),
              r = t.getIndex(),
              s = t.getAttribute("position"),
              n = r ? r.count : s.count,
              a = [0, 0, 0],
              o = ["a", "b", "c"],
              h = [, , ,],
              l = {},
              u = [];
            for (let t = 0; t < n; t += 3) {
              r
                ? ((a[0] = r.getX(t)),
                  (a[1] = r.getX(t + 1)),
                  (a[2] = r.getX(t + 2)))
                : ((a[0] = t), (a[1] = t + 1), (a[2] = t + 2));
              let { a: e, b: n, c } = nd;
              if (
                (e.fromBufferAttribute(s, a[0]),
                n.fromBufferAttribute(s, a[1]),
                c.fromBufferAttribute(s, a[2]),
                nd.getNormal(nc),
                (h[0] = `${Math.round(1e4 * e.x)},${Math.round(
                  1e4 * e.y
                )},${Math.round(1e4 * e.z)}`),
                (h[1] = `${Math.round(1e4 * n.x)},${Math.round(
                  1e4 * n.y
                )},${Math.round(1e4 * n.z)}`),
                (h[2] = `${Math.round(1e4 * c.x)},${Math.round(
                  1e4 * c.y
                )},${Math.round(1e4 * c.z)}`),
                h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
              )
                for (let t = 0; t < 3; t++) {
                  let e = (t + 1) % 3,
                    r = h[t],
                    s = h[e],
                    n = nd[o[t]],
                    c = nd[o[e]],
                    d = `${r}_${s}`,
                    p = `${s}_${r}`;
                  p in l && l[p]
                    ? (nc.dot(l[p].normal) <= i &&
                        (u.push(n.x, n.y, n.z), u.push(c.x, c.y, c.z)),
                      (l[p] = null))
                    : d in l ||
                      (l[d] = {
                        index0: a[t],
                        index1: a[e],
                        normal: nc.clone(),
                      });
                }
            }
            for (let t in l)
              if (l[t]) {
                let { index0: e, index1: i } = l[t];
                nl.fromBufferAttribute(s, e),
                  nu.fromBufferAttribute(s, i),
                  u.push(nl.x, nl.y, nl.z),
                  u.push(nu.x, nu.y, nu.z);
              }
            this.setAttribute("position", new Float32BufferAttribute(u, 3));
          }
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
      };
      let Shape = class Shape extends Path {
        constructor(t) {
          super(t),
            (this.uuid = generateUUID()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(t) {
          let e = [];
          for (let i = 0, r = this.holes.length; i < r; i++)
            e[i] = this.holes[i].getPoints(t);
          return e;
        }
        extractPoints(t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
        }
        copy(t) {
          super.copy(t), (this.holes = []);
          for (let e = 0, i = t.holes.length; e < i; e++) {
            let i = t.holes[e];
            this.holes.push(i.clone());
          }
          return this;
        }
        toJSON() {
          let t = super.toJSON();
          (t.uuid = this.uuid), (t.holes = []);
          for (let e = 0, i = this.holes.length; e < i; e++) {
            let i = this.holes[e];
            t.holes.push(i.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
          for (let e = 0, i = t.holes.length; e < i; e++) {
            let i = t.holes[e];
            this.holes.push(new Path().fromJSON(i));
          }
          return this;
        }
      };
      let np = {
        triangulate: function (t, e, i = 2) {
          let r, s, n, a, o, h, l;
          let u = e && e.length,
            c = u ? e[0] * i : t.length,
            d = linkedList(t, 0, c, i, !0),
            p = [];
          if (!d || d.next === d.prev) return p;
          if (
            (u &&
              (d = (function (t, e, i, r) {
                let s, n, a, o, h;
                let l = [];
                for (s = 0, n = e.length; s < n; s++)
                  (a = e[s] * r),
                    (o = s < n - 1 ? e[s + 1] * r : t.length),
                    (h = linkedList(t, a, o, r, !1)) === h.next &&
                      (h.steiner = !0),
                    l.push(
                      (function (t) {
                        let e = t,
                          i = t;
                        do
                          (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e),
                            (e = e.next);
                        while (e !== t);
                        return i;
                      })(h)
                    );
                for (l.sort(compareX), s = 0; s < l.length; s++)
                  i = (function (t, e) {
                    let i = (function (t, e) {
                      let i = e,
                        r = -1 / 0,
                        s,
                        n = t.x,
                        a = t.y;
                      do {
                        if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                          let t =
                            i.x +
                            ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
                          if (
                            t <= n &&
                            t > r &&
                            ((r = t),
                            (s = i.x < i.next.x ? i : i.next),
                            t === n)
                          )
                            return s;
                        }
                        i = i.next;
                      } while (i !== e);
                      if (!s) return null;
                      let o = s,
                        h = s.x,
                        l = s.y,
                        u = 1 / 0,
                        c;
                      i = s;
                      do {
                        var d, p;
                        n >= i.x &&
                          i.x >= h &&
                          n !== i.x &&
                          pointInTriangle(
                            a < l ? n : r,
                            a,
                            h,
                            l,
                            a < l ? r : n,
                            a,
                            i.x,
                            i.y
                          ) &&
                          ((c = Math.abs(a - i.y) / (n - i.x)),
                          locallyInside(i, t) &&
                            (c < u ||
                              (c === u &&
                                (i.x > s.x ||
                                  (i.x === s.x &&
                                    ((d = s),
                                    (p = i),
                                    0 > area(d.prev, d, p.prev) &&
                                      0 > area(p.next, d, d.next)))))) &&
                            ((s = i), (u = c))),
                          (i = i.next);
                      } while (i !== o);
                      return s;
                    })(t, e);
                    if (!i) return e;
                    let r = splitPolygon(i, t);
                    return filterPoints(r, r.next), filterPoints(i, i.next);
                  })(l[s], i);
                return i;
              })(t, e, d, i)),
            t.length > 80 * i)
          ) {
            (r = n = t[0]), (s = a = t[1]);
            for (let e = i; e < c; e += i)
              (o = t[e]),
                (h = t[e + 1]),
                o < r && (r = o),
                h < s && (s = h),
                o > n && (n = o),
                h > a && (a = h);
            l = 0 !== (l = Math.max(n - r, a - s)) ? 32767 / l : 0;
          }
          return (
            (function earcutLinked(t, e, i, r, s, n, a) {
              if (!t) return;
              !a &&
                n &&
                (function (t, e, i, r) {
                  let s = t;
                  do
                    0 === s.z && (s.z = zOrder(s.x, s.y, e, i, r)),
                      (s.prevZ = s.prev),
                      (s.nextZ = s.next),
                      (s = s.next);
                  while (s !== t);
                  (s.prevZ.nextZ = null),
                    (s.prevZ = null),
                    (function (t) {
                      let e,
                        i,
                        r,
                        s,
                        n,
                        a,
                        o,
                        h,
                        l = 1;
                      do {
                        for (i = t, t = null, n = null, a = 0; i; ) {
                          for (
                            a++, r = i, o = 0, e = 0;
                            e < l && (o++, (r = r.nextZ));
                            e++
                          );
                          for (h = l; o > 0 || (h > 0 && r); )
                            0 !== o && (0 === h || !r || i.z <= r.z)
                              ? ((s = i), (i = i.nextZ), o--)
                              : ((s = r), (r = r.nextZ), h--),
                              n ? (n.nextZ = s) : (t = s),
                              (s.prevZ = n),
                              (n = s);
                          i = r;
                        }
                        (n.nextZ = null), (l *= 2);
                      } while (a > 1);
                    })(s);
                })(t, r, s, n);
              let o = t,
                h,
                l;
              for (; t.prev !== t.next; ) {
                if (
                  ((h = t.prev),
                  (l = t.next),
                  n
                    ? (function (t, e, i, r) {
                        let s = t.prev,
                          n = t.next;
                        if (area(s, t, n) >= 0) return !1;
                        let a = s.x,
                          o = t.x,
                          h = n.x,
                          l = s.y,
                          u = t.y,
                          c = n.y,
                          d = a < o ? (a < h ? a : h) : o < h ? o : h,
                          p = l < u ? (l < c ? l : c) : u < c ? u : c,
                          m = a > o ? (a > h ? a : h) : o > h ? o : h,
                          f = l > u ? (l > c ? l : c) : u > c ? u : c,
                          y = zOrder(d, p, e, i, r),
                          g = zOrder(m, f, e, i, r),
                          x = t.prevZ,
                          b = t.nextZ;
                        for (; x && x.z >= y && b && b.z <= g; ) {
                          if (
                            (x.x >= d &&
                              x.x <= m &&
                              x.y >= p &&
                              x.y <= f &&
                              x !== s &&
                              x !== n &&
                              pointInTriangle(a, l, o, u, h, c, x.x, x.y) &&
                              area(x.prev, x, x.next) >= 0) ||
                            ((x = x.prevZ),
                            b.x >= d &&
                              b.x <= m &&
                              b.y >= p &&
                              b.y <= f &&
                              b !== s &&
                              b !== n &&
                              pointInTriangle(a, l, o, u, h, c, b.x, b.y) &&
                              area(b.prev, b, b.next) >= 0)
                          )
                            return !1;
                          b = b.nextZ;
                        }
                        for (; x && x.z >= y; ) {
                          if (
                            x.x >= d &&
                            x.x <= m &&
                            x.y >= p &&
                            x.y <= f &&
                            x !== s &&
                            x !== n &&
                            pointInTriangle(a, l, o, u, h, c, x.x, x.y) &&
                            area(x.prev, x, x.next) >= 0
                          )
                            return !1;
                          x = x.prevZ;
                        }
                        for (; b && b.z <= g; ) {
                          if (
                            b.x >= d &&
                            b.x <= m &&
                            b.y >= p &&
                            b.y <= f &&
                            b !== s &&
                            b !== n &&
                            pointInTriangle(a, l, o, u, h, c, b.x, b.y) &&
                            area(b.prev, b, b.next) >= 0
                          )
                            return !1;
                          b = b.nextZ;
                        }
                        return !0;
                      })(t, r, s, n)
                    : (function (t) {
                        let e = t.prev,
                          i = t.next;
                        if (area(e, t, i) >= 0) return !1;
                        let r = e.x,
                          s = t.x,
                          n = i.x,
                          a = e.y,
                          o = t.y,
                          h = i.y,
                          l = r < s ? (r < n ? r : n) : s < n ? s : n,
                          u = a < o ? (a < h ? a : h) : o < h ? o : h,
                          c = r > s ? (r > n ? r : n) : s > n ? s : n,
                          d = a > o ? (a > h ? a : h) : o > h ? o : h,
                          p = i.next;
                        for (; p !== e; ) {
                          if (
                            p.x >= l &&
                            p.x <= c &&
                            p.y >= u &&
                            p.y <= d &&
                            pointInTriangle(r, a, s, o, n, h, p.x, p.y) &&
                            area(p.prev, p, p.next) >= 0
                          )
                            return !1;
                          p = p.next;
                        }
                        return !0;
                      })(t))
                ) {
                  e.push((h.i / i) | 0),
                    e.push((t.i / i) | 0),
                    e.push((l.i / i) | 0),
                    removeNode(t),
                    (t = l.next),
                    (o = l.next);
                  continue;
                }
                if ((t = l) === o) {
                  a
                    ? 1 === a
                      ? earcutLinked(
                          (t = (function (t, e, i) {
                            let r = t;
                            do {
                              let s = r.prev,
                                n = r.next.next;
                              !equals(s, n) &&
                                intersects(s, r, r.next, n) &&
                                locallyInside(s, n) &&
                                locallyInside(n, s) &&
                                (e.push((s.i / i) | 0),
                                e.push((r.i / i) | 0),
                                e.push((n.i / i) | 0),
                                removeNode(r),
                                removeNode(r.next),
                                (r = t = n)),
                                (r = r.next);
                            } while (r !== t);
                            return filterPoints(r);
                          })(filterPoints(t), e, i)),
                          e,
                          i,
                          r,
                          s,
                          n,
                          2
                        )
                      : 2 === a &&
                        (function (t, e, i, r, s, n) {
                          let a = t;
                          do {
                            let t = a.next.next;
                            for (; t !== a.prev; ) {
                              var o, h;
                              if (
                                a.i !== t.i &&
                                ((o = a),
                                (h = t),
                                o.next.i !== h.i &&
                                  o.prev.i !== h.i &&
                                  !(function (t, e) {
                                    let i = t;
                                    do {
                                      if (
                                        i.i !== t.i &&
                                        i.next.i !== t.i &&
                                        i.i !== e.i &&
                                        i.next.i !== e.i &&
                                        intersects(i, i.next, t, e)
                                      )
                                        return !0;
                                      i = i.next;
                                    } while (i !== t);
                                    return !1;
                                  })(o, h) &&
                                  ((locallyInside(o, h) &&
                                    locallyInside(h, o) &&
                                    (function (t, e) {
                                      let i = t,
                                        r = !1,
                                        s = (t.x + e.x) / 2,
                                        n = (t.y + e.y) / 2;
                                      do
                                        i.y > n != i.next.y > n &&
                                          i.next.y !== i.y &&
                                          s <
                                            ((i.next.x - i.x) * (n - i.y)) /
                                              (i.next.y - i.y) +
                                              i.x &&
                                          (r = !r),
                                          (i = i.next);
                                      while (i !== t);
                                      return r;
                                    })(o, h) &&
                                    (area(o.prev, o, h.prev) ||
                                      area(o, h.prev, h))) ||
                                    (equals(o, h) &&
                                      area(o.prev, o, o.next) > 0 &&
                                      area(h.prev, h, h.next) > 0)))
                              ) {
                                let o = splitPolygon(a, t);
                                (a = filterPoints(a, a.next)),
                                  (o = filterPoints(o, o.next)),
                                  earcutLinked(a, e, i, r, s, n, 0),
                                  earcutLinked(o, e, i, r, s, n, 0);
                                return;
                              }
                              t = t.next;
                            }
                            a = a.next;
                          } while (a !== t);
                        })(t, e, i, r, s, n)
                    : earcutLinked(filterPoints(t), e, i, r, s, n, 1);
                  break;
                }
              }
            })(d, p, i, r, s, l, 0),
            p
          );
        },
      };
      function linkedList(t, e, i, r, s) {
        let n, a;
        if (
          s ===
          (function (t, e, i, r) {
            let s = 0;
            for (let n = e, a = i - r; n < i; n += r)
              (s += (t[a] - t[n]) * (t[n + 1] + t[a + 1])), (a = n);
            return s;
          })(t, e, i, r) >
            0
        )
          for (n = e; n < i; n += r) a = insertNode(n, t[n], t[n + 1], a);
        else
          for (n = i - r; n >= e; n -= r) a = insertNode(n, t[n], t[n + 1], a);
        return a && equals(a, a.next) && (removeNode(a), (a = a.next)), a;
      }
      function filterPoints(t, e) {
        if (!t) return t;
        e || (e = t);
        let i = t,
          r;
        do
          if (
            ((r = !1),
            !i.steiner && (equals(i, i.next) || 0 === area(i.prev, i, i.next)))
          ) {
            if ((removeNode(i), (i = e = i.prev) === i.next)) break;
            r = !0;
          } else i = i.next;
        while (r || i !== e);
        return e;
      }
      function compareX(t, e) {
        return t.x - e.x;
      }
      function zOrder(t, e, i, r, s) {
        return (
          (t =
            ((t =
              ((t =
                ((t = ((t = ((t - i) * s) | 0) | (t << 8)) & 16711935) |
                  (t << 4)) &
                252645135) |
                (t << 2)) &
              858993459) |
              (t << 1)) &
            1431655765) |
          ((e =
            ((e =
              ((e =
                ((e = ((e = ((e - r) * s) | 0) | (e << 8)) & 16711935) |
                  (e << 4)) &
                252645135) |
                (e << 2)) &
              858993459) |
              (e << 1)) &
            1431655765) <<
            1)
        );
      }
      function pointInTriangle(t, e, i, r, s, n, a, o) {
        return (
          (s - a) * (e - o) >= (t - a) * (n - o) &&
          (t - a) * (r - o) >= (i - a) * (e - o) &&
          (i - a) * (n - o) >= (s - a) * (r - o)
        );
      }
      function area(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
      }
      function equals(t, e) {
        return t.x === e.x && t.y === e.y;
      }
      function intersects(t, e, i, r) {
        let s = sign(area(t, e, i)),
          n = sign(area(t, e, r)),
          a = sign(area(i, r, t)),
          o = sign(area(i, r, e));
        return !!(
          (s !== n && a !== o) ||
          (0 === s && onSegment(t, i, e)) ||
          (0 === n && onSegment(t, r, e)) ||
          (0 === a && onSegment(i, t, r)) ||
          (0 === o && onSegment(i, e, r))
        );
      }
      function onSegment(t, e, i) {
        return (
          e.x <= Math.max(t.x, i.x) &&
          e.x >= Math.min(t.x, i.x) &&
          e.y <= Math.max(t.y, i.y) &&
          e.y >= Math.min(t.y, i.y)
        );
      }
      function sign(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
      function locallyInside(t, e) {
        return 0 > area(t.prev, t, t.next)
          ? area(t, e, t.next) >= 0 && area(t, t.prev, e) >= 0
          : 0 > area(t, e, t.prev) || 0 > area(t, t.next, e);
      }
      function splitPolygon(t, e) {
        let i = new Node(t.i, t.x, t.y),
          r = new Node(e.i, e.x, e.y),
          s = t.next,
          n = e.prev;
        return (
          (t.next = e),
          (e.prev = t),
          (i.next = s),
          (s.prev = i),
          (r.next = i),
          (i.prev = r),
          (n.next = r),
          (r.prev = n),
          r
        );
      }
      function insertNode(t, e, i, r) {
        let s = new Node(t, e, i);
        return (
          r
            ? ((s.next = r.next), (s.prev = r), (r.next.prev = s), (r.next = s))
            : ((s.prev = s), (s.next = s)),
          s
        );
      }
      function removeNode(t) {
        (t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }
      function Node(t, e, i) {
        (this.i = t),
          (this.x = e),
          (this.y = i),
          (this.prev = null),
          (this.next = null),
          (this.z = 0),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      let ShapeUtils = class ShapeUtils {
        static area(t) {
          let e = t.length,
            i = 0;
          for (let r = e - 1, s = 0; s < e; r = s++)
            i += t[r].x * t[s].y - t[s].x * t[r].y;
          return 0.5 * i;
        }
        static isClockWise(t) {
          return 0 > ShapeUtils.area(t);
        }
        static triangulateShape(t, e) {
          let i = [],
            r = [],
            s = [];
          removeDupEndPts(t), addContour(i, t);
          let n = t.length;
          e.forEach(removeDupEndPts);
          for (let t = 0; t < e.length; t++)
            r.push(n), (n += e[t].length), addContour(i, e[t]);
          let a = np.triangulate(i, r);
          for (let t = 0; t < a.length; t += 3) s.push(a.slice(t, t + 3));
          return s;
        }
      };
      function removeDupEndPts(t) {
        let e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop();
      }
      function addContour(t, e) {
        for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y);
      }
      let ExtrudeGeometry = class ExtrudeGeometry extends BufferGeometry {
        constructor(
          t = new Shape([
            new Vector2(0.5, 0.5),
            new Vector2(-0.5, 0.5),
            new Vector2(-0.5, -0.5),
            new Vector2(0.5, -0.5),
          ]),
          e = {}
        ) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: t, options: e }),
            (t = Array.isArray(t) ? t : [t]);
          let i = this,
            r = [],
            s = [];
          for (let n = 0, a = t.length; n < a; n++) {
            let a = t[n];
            !(function (t) {
              let n, a, o, h;
              let l = [],
                u = void 0 !== e.curveSegments ? e.curveSegments : 12,
                c = void 0 !== e.steps ? e.steps : 1,
                d = void 0 !== e.depth ? e.depth : 1,
                p = void 0 === e.bevelEnabled || e.bevelEnabled,
                m = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
                f = void 0 !== e.bevelSize ? e.bevelSize : m - 0.1,
                y = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                g = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                x = e.extrudePath,
                b = void 0 !== e.UVGenerator ? e.UVGenerator : nm,
                M,
                w = !1;
              x &&
                ((M = x.getSpacedPoints(c)),
                (w = !0),
                (p = !1),
                (n = x.computeFrenetFrames(c, !1)),
                (a = new Vector3()),
                (o = new Vector3()),
                (h = new Vector3())),
                p || ((g = 0), (m = 0), (f = 0), (y = 0));
              let S = t.extractPoints(u),
                A = S.shape,
                _ = S.holes,
                T = !ShapeUtils.isClockWise(A);
              if (T) {
                A = A.reverse();
                for (let t = 0, e = _.length; t < e; t++) {
                  let e = _[t];
                  ShapeUtils.isClockWise(e) && (_[t] = e.reverse());
                }
              }
              let C = ShapeUtils.triangulateShape(A, _),
                z = A;
              for (let t = 0, e = _.length; t < e; t++) {
                let e = _[t];
                A = A.concat(e);
              }
              function scalePt2(t, e, i) {
                return (
                  e ||
                    console.error("THREE.ExtrudeGeometry: vec does not exist"),
                  t.clone().addScaledVector(e, i)
                );
              }
              let B = A.length,
                I = C.length;
              function getBevelVec(t, e, i) {
                let r, s, n;
                let a = t.x - e.x,
                  o = t.y - e.y,
                  h = i.x - t.x,
                  l = i.y - t.y,
                  u = a * a + o * o,
                  c = a * l - o * h;
                if (Math.abs(c) > Number.EPSILON) {
                  let c = Math.sqrt(u),
                    d = Math.sqrt(h * h + l * l),
                    p = e.x - o / c,
                    m = e.y + a / c,
                    f = i.x - l / d,
                    y = i.y + h / d,
                    g = ((f - p) * l - (y - m) * h) / (a * l - o * h);
                  (r = p + a * g - t.x), (s = m + o * g - t.y);
                  let x = r * r + s * s;
                  if (x <= 2) return new Vector2(r, s);
                  n = Math.sqrt(x / 2);
                } else {
                  let t = !1;
                  a > Number.EPSILON
                    ? h > Number.EPSILON && (t = !0)
                    : a < -Number.EPSILON
                    ? h < -Number.EPSILON && (t = !0)
                    : Math.sign(o) === Math.sign(l) && (t = !0),
                    t
                      ? ((r = -o), (s = a), (n = Math.sqrt(u)))
                      : ((r = a), (s = o), (n = Math.sqrt(u / 2)));
                }
                return new Vector2(r / n, s / n);
              }
              let V = [];
              for (
                let t = 0, e = z.length, i = e - 1, r = t + 1;
                t < e;
                t++, i++, r++
              )
                i === e && (i = 0),
                  r === e && (r = 0),
                  (V[t] = getBevelVec(z[t], z[i], z[r]));
              let P = [],
                L,
                k = V.concat();
              for (let t = 0, e = _.length; t < e; t++) {
                let e = _[t];
                L = [];
                for (
                  let t = 0, i = e.length, r = i - 1, s = t + 1;
                  t < i;
                  t++, r++, s++
                )
                  r === i && (r = 0),
                    s === i && (s = 0),
                    (L[t] = getBevelVec(e[t], e[r], e[s]));
                P.push(L), (k = k.concat(L));
              }
              for (let t = 0; t < g; t++) {
                let e = t / g,
                  i = m * Math.cos((e * Math.PI) / 2),
                  r = f * Math.sin((e * Math.PI) / 2) + y;
                for (let t = 0, e = z.length; t < e; t++) {
                  let e = scalePt2(z[t], V[t], r);
                  v(e.x, e.y, -i);
                }
                for (let t = 0, e = _.length; t < e; t++) {
                  let e = _[t];
                  L = P[t];
                  for (let t = 0, s = e.length; t < s; t++) {
                    let s = scalePt2(e[t], L[t], r);
                    v(s.x, s.y, -i);
                  }
                }
              }
              let R = f + y;
              for (let t = 0; t < B; t++) {
                let e = p ? scalePt2(A[t], k[t], R) : A[t];
                w
                  ? (o.copy(n.normals[0]).multiplyScalar(e.x),
                    a.copy(n.binormals[0]).multiplyScalar(e.y),
                    h.copy(M[0]).add(o).add(a),
                    v(h.x, h.y, h.z))
                  : v(e.x, e.y, 0);
              }
              for (let t = 1; t <= c; t++)
                for (let e = 0; e < B; e++) {
                  let i = p ? scalePt2(A[e], k[e], R) : A[e];
                  w
                    ? (o.copy(n.normals[t]).multiplyScalar(i.x),
                      a.copy(n.binormals[t]).multiplyScalar(i.y),
                      h.copy(M[t]).add(o).add(a),
                      v(h.x, h.y, h.z))
                    : v(i.x, i.y, (d / c) * t);
                }
              for (let t = g - 1; t >= 0; t--) {
                let e = t / g,
                  i = m * Math.cos((e * Math.PI) / 2),
                  r = f * Math.sin((e * Math.PI) / 2) + y;
                for (let t = 0, e = z.length; t < e; t++) {
                  let e = scalePt2(z[t], V[t], r);
                  v(e.x, e.y, d + i);
                }
                for (let t = 0, e = _.length; t < e; t++) {
                  let e = _[t];
                  L = P[t];
                  for (let t = 0, s = e.length; t < s; t++) {
                    let s = scalePt2(e[t], L[t], r);
                    w
                      ? v(s.x, s.y + M[c - 1].y, M[c - 1].x + i)
                      : v(s.x, s.y, d + i);
                  }
                }
              }
              function sidewalls(t, e) {
                let s = t.length;
                for (; --s >= 0; ) {
                  let n = s,
                    a = s - 1;
                  a < 0 && (a = t.length - 1);
                  for (let t = 0, s = c + 2 * g; t < s; t++) {
                    let s = B * t,
                      o = B * (t + 1),
                      h = e + n + s,
                      l = e + a + s,
                      u = e + a + o,
                      c = e + n + o;
                    !(function (t, e, s, n) {
                      addVertex(t),
                        addVertex(e),
                        addVertex(n),
                        addVertex(e),
                        addVertex(s),
                        addVertex(n);
                      let a = r.length / 3,
                        o = b.generateSideWallUV(
                          i,
                          r,
                          a - 6,
                          a - 3,
                          a - 2,
                          a - 1
                        );
                      addUV(o[0]),
                        addUV(o[1]),
                        addUV(o[3]),
                        addUV(o[1]),
                        addUV(o[2]),
                        addUV(o[3]);
                    })(h, l, u, c);
                  }
                }
              }
              function v(t, e, i) {
                l.push(t), l.push(e), l.push(i);
              }
              function f3(t, e, s) {
                addVertex(t), addVertex(e), addVertex(s);
                let n = r.length / 3,
                  a = b.generateTopUV(i, r, n - 3, n - 2, n - 1);
                addUV(a[0]), addUV(a[1]), addUV(a[2]);
              }
              function addVertex(t) {
                r.push(l[3 * t + 0]),
                  r.push(l[3 * t + 1]),
                  r.push(l[3 * t + 2]);
              }
              function addUV(t) {
                s.push(t.x), s.push(t.y);
              }
              (function () {
                let t = r.length / 3;
                if (p) {
                  let t = 0 * B;
                  for (let e = 0; e < I; e++) {
                    let i = C[e];
                    f3(i[2] + t, i[1] + t, i[0] + t);
                  }
                  t = B * (c + 2 * g);
                  for (let e = 0; e < I; e++) {
                    let i = C[e];
                    f3(i[0] + t, i[1] + t, i[2] + t);
                  }
                } else {
                  for (let t = 0; t < I; t++) {
                    let e = C[t];
                    f3(e[2], e[1], e[0]);
                  }
                  for (let t = 0; t < I; t++) {
                    let e = C[t];
                    f3(e[0] + B * c, e[1] + B * c, e[2] + B * c);
                  }
                }
                i.addGroup(t, r.length / 3 - t, 0);
              })(),
                (function () {
                  let t = r.length / 3,
                    e = 0;
                  sidewalls(z, 0), (e += z.length);
                  for (let t = 0, i = _.length; t < i; t++) {
                    let i = _[t];
                    sidewalls(i, e), (e += i.length);
                  }
                  i.addGroup(t, r.length / 3 - t, 1);
                })();
            })(a);
          }
          this.setAttribute("position", new Float32BufferAttribute(r, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(s, 2)),
            this.computeVertexNormals();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        toJSON() {
          let t = super.toJSON(),
            e = this.parameters.shapes,
            i = this.parameters.options;
          return (function (t, e, i) {
            if (((i.shapes = []), Array.isArray(t)))
              for (let e = 0, r = t.length; e < r; e++) {
                let r = t[e];
                i.shapes.push(r.uuid);
              }
            else i.shapes.push(t.uuid);
            return (
              (i.options = Object.assign({}, e)),
              void 0 !== e.extrudePath &&
                (i.options.extrudePath = e.extrudePath.toJSON()),
              i
            );
          })(e, i, t);
        }
        static fromJSON(t, e) {
          let i = [];
          for (let r = 0, s = t.shapes.length; r < s; r++) {
            let s = e[t.shapes[r]];
            i.push(s);
          }
          let r = t.options.extrudePath;
          return (
            void 0 !== r &&
              (t.options.extrudePath = new nh[r.type]().fromJSON(r)),
            new ExtrudeGeometry(i, t.options)
          );
        }
      };
      let nm = {
        generateTopUV: function (t, e, i, r, s) {
          let n = e[3 * i],
            a = e[3 * i + 1],
            o = e[3 * r],
            h = e[3 * r + 1],
            l = e[3 * s],
            u = e[3 * s + 1];
          return [new Vector2(n, a), new Vector2(o, h), new Vector2(l, u)];
        },
        generateSideWallUV: function (t, e, i, r, s, n) {
          let a = e[3 * i],
            o = e[3 * i + 1],
            h = e[3 * i + 2],
            l = e[3 * r],
            u = e[3 * r + 1],
            c = e[3 * r + 2],
            d = e[3 * s],
            p = e[3 * s + 1],
            m = e[3 * s + 2],
            f = e[3 * n],
            y = e[3 * n + 1],
            g = e[3 * n + 2];
          return Math.abs(o - u) < Math.abs(a - l)
            ? [
                new Vector2(a, 1 - h),
                new Vector2(l, 1 - c),
                new Vector2(d, 1 - m),
                new Vector2(f, 1 - g),
              ]
            : [
                new Vector2(o, 1 - h),
                new Vector2(u, 1 - c),
                new Vector2(p, 1 - m),
                new Vector2(y, 1 - g),
              ];
        },
      };
      let IcosahedronGeometry = class IcosahedronGeometry extends PolyhedronGeometry {
        constructor(t = 1, e = 0) {
          let i = (1 + Math.sqrt(5)) / 2,
            r = [
              -1,
              i,
              0,
              1,
              i,
              0,
              -1,
              -i,
              0,
              1,
              -i,
              0,
              0,
              -1,
              i,
              0,
              1,
              i,
              0,
              -1,
              -i,
              0,
              1,
              -i,
              i,
              0,
              -1,
              i,
              0,
              1,
              -i,
              0,
              -1,
              -i,
              0,
              1,
            ];
          super(
            r,
            [
              0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
              4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6,
              8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
            ],
            t,
            e
          ),
            (this.type = "IcosahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new IcosahedronGeometry(t.radius, t.detail);
        }
      };
      let OctahedronGeometry = class OctahedronGeometry extends PolyhedronGeometry {
        constructor(t = 1, e = 0) {
          super(
            [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            [
              0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1,
              4, 2,
            ],
            t,
            e
          ),
            (this.type = "OctahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new OctahedronGeometry(t.radius, t.detail);
        }
      };
      let PlaneGeometry = class PlaneGeometry extends BufferGeometry {
        constructor(t = 1, e = 1, i = 1, r = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              widthSegments: i,
              heightSegments: r,
            });
          let s = t / 2,
            n = e / 2,
            a = Math.floor(i),
            o = Math.floor(r),
            h = a + 1,
            l = o + 1,
            u = t / a,
            c = e / o,
            d = [],
            p = [],
            m = [],
            f = [];
          for (let t = 0; t < l; t++) {
            let e = t * c - n;
            for (let i = 0; i < h; i++) {
              let r = i * u - s;
              p.push(r, -e, 0),
                m.push(0, 0, 1),
                f.push(i / a),
                f.push(1 - t / o);
            }
          }
          for (let t = 0; t < o; t++)
            for (let e = 0; e < a; e++) {
              let i = e + h * t,
                r = e + h * (t + 1),
                s = e + 1 + h * (t + 1),
                n = e + 1 + h * t;
              d.push(i, r, n), d.push(r, s, n);
            }
          this.setIndex(d),
            this.setAttribute("position", new Float32BufferAttribute(p, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(m, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(f, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new PlaneGeometry(
            t.width,
            t.height,
            t.widthSegments,
            t.heightSegments
          );
        }
      };
      let RingGeometry = class RingGeometry extends BufferGeometry {
        constructor(t = 0.5, e = 1, i = 32, r = 1, s = 0, n = 2 * Math.PI) {
          super(),
            (this.type = "RingGeometry"),
            (this.parameters = {
              innerRadius: t,
              outerRadius: e,
              thetaSegments: i,
              phiSegments: r,
              thetaStart: s,
              thetaLength: n,
            }),
            (i = Math.max(3, i)),
            (r = Math.max(1, r));
          let a = [],
            o = [],
            h = [],
            l = [],
            u = t,
            c = (e - t) / r,
            d = new Vector3(),
            p = new Vector2();
          for (let t = 0; t <= r; t++) {
            for (let t = 0; t <= i; t++) {
              let r = s + (t / i) * n;
              (d.x = u * Math.cos(r)),
                (d.y = u * Math.sin(r)),
                o.push(d.x, d.y, d.z),
                h.push(0, 0, 1),
                (p.x = (d.x / e + 1) / 2),
                (p.y = (d.y / e + 1) / 2),
                l.push(p.x, p.y);
            }
            u += c;
          }
          for (let t = 0; t < r; t++) {
            let e = t * (i + 1);
            for (let t = 0; t < i; t++) {
              let r = t + e,
                s = r + i + 1,
                n = r + i + 2,
                o = r + 1;
              a.push(r, s, o), a.push(s, n, o);
            }
          }
          this.setIndex(a),
            this.setAttribute("position", new Float32BufferAttribute(o, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(h, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(l, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new RingGeometry(
            t.innerRadius,
            t.outerRadius,
            t.thetaSegments,
            t.phiSegments,
            t.thetaStart,
            t.thetaLength
          );
        }
      };
      let ShapeGeometry = class ShapeGeometry extends BufferGeometry {
        constructor(
          t = new Shape([
            new Vector2(0, 0.5),
            new Vector2(-0.5, -0.5),
            new Vector2(0.5, -0.5),
          ]),
          e = 12
        ) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: t, curveSegments: e });
          let i = [],
            r = [],
            s = [],
            n = [],
            a = 0,
            o = 0;
          if (!1 === Array.isArray(t)) addShape(t);
          else
            for (let e = 0; e < t.length; e++)
              addShape(t[e]), this.addGroup(a, o, e), (a += o), (o = 0);
          function addShape(t) {
            let a = r.length / 3,
              h = t.extractPoints(e),
              l = h.shape,
              u = h.holes;
            !1 === ShapeUtils.isClockWise(l) && (l = l.reverse());
            for (let t = 0, e = u.length; t < e; t++) {
              let e = u[t];
              !0 === ShapeUtils.isClockWise(e) && (u[t] = e.reverse());
            }
            let c = ShapeUtils.triangulateShape(l, u);
            for (let t = 0, e = u.length; t < e; t++) {
              let e = u[t];
              l = l.concat(e);
            }
            for (let t = 0, e = l.length; t < e; t++) {
              let e = l[t];
              r.push(e.x, e.y, 0), s.push(0, 0, 1), n.push(e.x, e.y);
            }
            for (let t = 0, e = c.length; t < e; t++) {
              let e = c[t],
                r = e[0] + a,
                s = e[1] + a,
                n = e[2] + a;
              i.push(r, s, n), (o += 3);
            }
          }
          this.setIndex(i),
            this.setAttribute("position", new Float32BufferAttribute(r, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(s, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(n, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        toJSON() {
          let t = super.toJSON(),
            e = this.parameters.shapes;
          return (function (t, e) {
            if (((e.shapes = []), Array.isArray(t)))
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                e.shapes.push(r.uuid);
              }
            else e.shapes.push(t.uuid);
            return e;
          })(e, t);
        }
        static fromJSON(t, e) {
          let i = [];
          for (let r = 0, s = t.shapes.length; r < s; r++) {
            let s = e[t.shapes[r]];
            i.push(s);
          }
          return new ShapeGeometry(i, t.curveSegments);
        }
      };
      let SphereGeometry = class SphereGeometry extends BufferGeometry {
        constructor(
          t = 1,
          e = 32,
          i = 16,
          r = 0,
          s = 2 * Math.PI,
          n = 0,
          a = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: t,
              widthSegments: e,
              heightSegments: i,
              phiStart: r,
              phiLength: s,
              thetaStart: n,
              thetaLength: a,
            }),
            (e = Math.max(3, Math.floor(e))),
            (i = Math.max(2, Math.floor(i)));
          let o = Math.min(n + a, Math.PI),
            h = 0,
            l = [],
            u = new Vector3(),
            c = new Vector3(),
            d = [],
            p = [],
            m = [],
            f = [];
          for (let d = 0; d <= i; d++) {
            let y = [],
              g = d / i,
              x = 0;
            0 === d && 0 === n
              ? (x = 0.5 / e)
              : d === i && o === Math.PI && (x = -0.5 / e);
            for (let i = 0; i <= e; i++) {
              let o = i / e;
              (u.x = -t * Math.cos(r + o * s) * Math.sin(n + g * a)),
                (u.y = t * Math.cos(n + g * a)),
                (u.z = t * Math.sin(r + o * s) * Math.sin(n + g * a)),
                p.push(u.x, u.y, u.z),
                c.copy(u).normalize(),
                m.push(c.x, c.y, c.z),
                f.push(o + x, 1 - g),
                y.push(h++);
            }
            l.push(y);
          }
          for (let t = 0; t < i; t++)
            for (let r = 0; r < e; r++) {
              let e = l[t][r + 1],
                s = l[t][r],
                a = l[t + 1][r],
                h = l[t + 1][r + 1];
              (0 !== t || n > 0) && d.push(e, s, h),
                (t !== i - 1 || o < Math.PI) && d.push(s, a, h);
            }
          this.setIndex(d),
            this.setAttribute("position", new Float32BufferAttribute(p, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(m, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(f, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new SphereGeometry(
            t.radius,
            t.widthSegments,
            t.heightSegments,
            t.phiStart,
            t.phiLength,
            t.thetaStart,
            t.thetaLength
          );
        }
      };
      let TetrahedronGeometry = class TetrahedronGeometry extends PolyhedronGeometry {
        constructor(t = 1, e = 0) {
          super(
            [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
            t,
            e
          ),
            (this.type = "TetrahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new TetrahedronGeometry(t.radius, t.detail);
        }
      };
      let TorusGeometry = class TorusGeometry extends BufferGeometry {
        constructor(t = 1, e = 0.4, i = 12, r = 48, s = 2 * Math.PI) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: t,
              tube: e,
              radialSegments: i,
              tubularSegments: r,
              arc: s,
            }),
            (i = Math.floor(i)),
            (r = Math.floor(r));
          let n = [],
            a = [],
            o = [],
            h = [],
            l = new Vector3(),
            u = new Vector3(),
            c = new Vector3();
          for (let n = 0; n <= i; n++)
            for (let d = 0; d <= r; d++) {
              let p = (d / r) * s,
                m = (n / i) * Math.PI * 2;
              (u.x = (t + e * Math.cos(m)) * Math.cos(p)),
                (u.y = (t + e * Math.cos(m)) * Math.sin(p)),
                (u.z = e * Math.sin(m)),
                a.push(u.x, u.y, u.z),
                (l.x = t * Math.cos(p)),
                (l.y = t * Math.sin(p)),
                c.subVectors(u, l).normalize(),
                o.push(c.x, c.y, c.z),
                h.push(d / r),
                h.push(n / i);
            }
          for (let t = 1; t <= i; t++)
            for (let e = 1; e <= r; e++) {
              let i = (r + 1) * t + e - 1,
                s = (r + 1) * (t - 1) + e - 1,
                a = (r + 1) * (t - 1) + e,
                o = (r + 1) * t + e;
              n.push(i, s, o), n.push(s, a, o);
            }
          this.setIndex(n),
            this.setAttribute("position", new Float32BufferAttribute(a, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(o, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(h, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new TorusGeometry(
            t.radius,
            t.tube,
            t.radialSegments,
            t.tubularSegments,
            t.arc
          );
        }
      };
      let TorusKnotGeometry = class TorusKnotGeometry extends BufferGeometry {
        constructor(t = 1, e = 0.4, i = 64, r = 8, s = 2, n = 3) {
          super(),
            (this.type = "TorusKnotGeometry"),
            (this.parameters = {
              radius: t,
              tube: e,
              tubularSegments: i,
              radialSegments: r,
              p: s,
              q: n,
            }),
            (i = Math.floor(i)),
            (r = Math.floor(r));
          let a = [],
            o = [],
            h = [],
            l = [],
            u = new Vector3(),
            c = new Vector3(),
            d = new Vector3(),
            p = new Vector3(),
            m = new Vector3(),
            f = new Vector3(),
            y = new Vector3();
          for (let a = 0; a <= i; ++a) {
            let g = (a / i) * s * Math.PI * 2;
            calculatePositionOnCurve(g, s, n, t, d),
              calculatePositionOnCurve(g + 0.01, s, n, t, p),
              f.subVectors(p, d),
              y.addVectors(p, d),
              m.crossVectors(f, y),
              y.crossVectors(m, f),
              m.normalize(),
              y.normalize();
            for (let t = 0; t <= r; ++t) {
              let s = (t / r) * Math.PI * 2,
                n = -e * Math.cos(s),
                p = e * Math.sin(s);
              (u.x = d.x + (n * y.x + p * m.x)),
                (u.y = d.y + (n * y.y + p * m.y)),
                (u.z = d.z + (n * y.z + p * m.z)),
                o.push(u.x, u.y, u.z),
                c.subVectors(u, d).normalize(),
                h.push(c.x, c.y, c.z),
                l.push(a / i),
                l.push(t / r);
            }
          }
          for (let t = 1; t <= i; t++)
            for (let e = 1; e <= r; e++) {
              let i = (r + 1) * (t - 1) + (e - 1),
                s = (r + 1) * t + (e - 1),
                n = (r + 1) * t + e,
                o = (r + 1) * (t - 1) + e;
              a.push(i, s, o), a.push(s, n, o);
            }
          function calculatePositionOnCurve(t, e, i, r, s) {
            let n = (i / e) * t,
              a = Math.cos(n);
            (s.x = r * (2 + a) * 0.5 * Math.cos(t)),
              (s.y = r * (2 + a) * Math.sin(t) * 0.5),
              (s.z = r * Math.sin(n) * 0.5);
          }
          this.setIndex(a),
            this.setAttribute("position", new Float32BufferAttribute(o, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(h, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(l, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new TorusKnotGeometry(
            t.radius,
            t.tube,
            t.tubularSegments,
            t.radialSegments,
            t.p,
            t.q
          );
        }
      };
      let TubeGeometry = class TubeGeometry extends BufferGeometry {
        constructor(
          t = new QuadraticBezierCurve3(
            new Vector3(-1, -1, 0),
            new Vector3(-1, 1, 0),
            new Vector3(1, 1, 0)
          ),
          e = 64,
          i = 1,
          r = 8,
          s = !1
        ) {
          super(),
            (this.type = "TubeGeometry"),
            (this.parameters = {
              path: t,
              tubularSegments: e,
              radius: i,
              radialSegments: r,
              closed: s,
            });
          let n = t.computeFrenetFrames(e, s);
          (this.tangents = n.tangents),
            (this.normals = n.normals),
            (this.binormals = n.binormals);
          let a = new Vector3(),
            o = new Vector3(),
            h = new Vector2(),
            l = new Vector3(),
            u = [],
            c = [],
            d = [],
            p = [];
          function generateSegment(s) {
            l = t.getPointAt(s / e, l);
            let h = n.normals[s],
              d = n.binormals[s];
            for (let t = 0; t <= r; t++) {
              let e = (t / r) * Math.PI * 2,
                s = Math.sin(e),
                n = -Math.cos(e);
              (o.x = n * h.x + s * d.x),
                (o.y = n * h.y + s * d.y),
                (o.z = n * h.z + s * d.z),
                o.normalize(),
                c.push(o.x, o.y, o.z),
                (a.x = l.x + i * o.x),
                (a.y = l.y + i * o.y),
                (a.z = l.z + i * o.z),
                u.push(a.x, a.y, a.z);
            }
          }
          (function () {
            for (let t = 0; t < e; t++) generateSegment(t);
            generateSegment(!1 === s ? e : 0),
              (function () {
                for (let t = 0; t <= e; t++)
                  for (let i = 0; i <= r; i++)
                    (h.x = t / e), (h.y = i / r), d.push(h.x, h.y);
              })(),
              (function () {
                for (let t = 1; t <= e; t++)
                  for (let e = 1; e <= r; e++) {
                    let i = (r + 1) * (t - 1) + (e - 1),
                      s = (r + 1) * t + (e - 1),
                      n = (r + 1) * t + e,
                      a = (r + 1) * (t - 1) + e;
                    p.push(i, s, a), p.push(s, n, a);
                  }
              })();
          })(),
            this.setIndex(p),
            this.setAttribute("position", new Float32BufferAttribute(u, 3)),
            this.setAttribute("normal", new Float32BufferAttribute(c, 3)),
            this.setAttribute("uv", new Float32BufferAttribute(d, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        toJSON() {
          let t = super.toJSON();
          return (t.path = this.parameters.path.toJSON()), t;
        }
        static fromJSON(t) {
          return new TubeGeometry(
            new nh[t.path.type]().fromJSON(t.path),
            t.tubularSegments,
            t.radius,
            t.radialSegments,
            t.closed
          );
        }
      };
      let WireframeGeometry = class WireframeGeometry extends BufferGeometry {
        constructor(t = null) {
          if (
            (super(),
            (this.type = "WireframeGeometry"),
            (this.parameters = { geometry: t }),
            null !== t)
          ) {
            let e = [],
              i = new Set(),
              r = new Vector3(),
              s = new Vector3();
            if (null !== t.index) {
              let n = t.attributes.position,
                a = t.index,
                o = t.groups;
              0 === o.length &&
                (o = [{ start: 0, count: a.count, materialIndex: 0 }]);
              for (let t = 0, h = o.length; t < h; ++t) {
                let h = o[t],
                  l = h.start,
                  u = h.count;
                for (let t = l, o = l + u; t < o; t += 3)
                  for (let o = 0; o < 3; o++) {
                    let h = a.getX(t + o),
                      l = a.getX(t + ((o + 1) % 3));
                    r.fromBufferAttribute(n, h),
                      s.fromBufferAttribute(n, l),
                      !0 === isUniqueEdge(r, s, i) &&
                        (e.push(r.x, r.y, r.z), e.push(s.x, s.y, s.z));
                  }
              }
            } else {
              let n = t.attributes.position;
              for (let t = 0, a = n.count / 3; t < a; t++)
                for (let a = 0; a < 3; a++) {
                  let o = 3 * t + a,
                    h = 3 * t + ((a + 1) % 3);
                  r.fromBufferAttribute(n, o),
                    s.fromBufferAttribute(n, h),
                    !0 === isUniqueEdge(r, s, i) &&
                      (e.push(r.x, r.y, r.z), e.push(s.x, s.y, s.z));
                }
            }
            this.setAttribute("position", new Float32BufferAttribute(e, 3));
          }
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
      };
      function isUniqueEdge(t, e, i) {
        let r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
          s = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
        return !0 !== i.has(r) && !0 !== i.has(s) && (i.add(r), i.add(s), !0);
      }
      var nf = Object.freeze({
        __proto__: null,
        BoxGeometry: BoxGeometry,
        CapsuleGeometry: CapsuleGeometry,
        CircleGeometry: CircleGeometry,
        ConeGeometry: ConeGeometry,
        CylinderGeometry: CylinderGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        EdgesGeometry: EdgesGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        LatheGeometry: LatheGeometry,
        OctahedronGeometry: OctahedronGeometry,
        PlaneGeometry: PlaneGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        RingGeometry: RingGeometry,
        ShapeGeometry: ShapeGeometry,
        SphereGeometry: SphereGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TorusGeometry: TorusGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TubeGeometry: TubeGeometry,
        WireframeGeometry: WireframeGeometry,
      });
      let ShadowMaterial = class ShadowMaterial extends Material {
        constructor(t) {
          super(),
            (this.isShadowMaterial = !0),
            (this.type = "ShadowMaterial"),
            (this.color = new Color(0)),
            (this.transparent = !0),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t), this.color.copy(t.color), (this.fog = t.fog), this
          );
        }
      };
      let RawShaderMaterial = class RawShaderMaterial extends ShaderMaterial {
        constructor(t) {
          super(t),
            (this.isRawShaderMaterial = !0),
            (this.type = "RawShaderMaterial");
        }
      };
      let MeshStandardMaterial = class MeshStandardMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshStandardMaterial = !0),
            (this.type = "MeshStandardMaterial"),
            (this.defines = { STANDARD: "" }),
            (this.color = new Color(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Color(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = eq),
            (this.normalScale = new Vector2(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new Euler()),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "" }),
            this.color.copy(t.color),
            (this.roughness = t.roughness),
            (this.metalness = t.metalness),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.roughnessMap = t.roughnessMap),
            (this.metalnessMap = t.metalnessMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            this.envMapRotation.copy(t.envMapRotation),
            (this.envMapIntensity = t.envMapIntensity),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            (this.fog = t.fog),
            this
          );
        }
      };
      let MeshPhysicalMaterial = class MeshPhysicalMaterial extends MeshStandardMaterial {
        constructor(t) {
          super(),
            (this.isMeshPhysicalMaterial = !0),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.anisotropyRotation = 0),
            (this.anisotropyMap = null),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Vector2(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return clamp((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
              },
            }),
            (this.iridescenceMap = null),
            (this.iridescenceIOR = 1.3),
            (this.iridescenceThicknessRange = [100, 400]),
            (this.iridescenceThicknessMap = null),
            (this.sheenColor = new Color(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 1 / 0),
            (this.attenuationColor = new Color(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new Color(1, 1, 1)),
            (this.specularColorMap = null),
            (this._anisotropy = 0),
            (this._clearcoat = 0),
            (this._dispersion = 0),
            (this._iridescence = 0),
            (this._sheen = 0),
            (this._transmission = 0),
            this.setValues(t);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(t) {
          this._anisotropy > 0 != t > 0 && this.version++,
            (this._anisotropy = t);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(t) {
          this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(t) {
          this._iridescence > 0 != t > 0 && this.version++,
            (this._iridescence = t);
        }
        get dispersion() {
          return this._dispersion;
        }
        set dispersion(t) {
          this._dispersion > 0 != t > 0 && this.version++,
            (this._dispersion = t);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(t) {
          this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(t) {
          this._transmission > 0 != t > 0 && this.version++,
            (this._transmission = t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.anisotropy = t.anisotropy),
            (this.anisotropyRotation = t.anisotropyRotation),
            (this.anisotropyMap = t.anisotropyMap),
            (this.clearcoat = t.clearcoat),
            (this.clearcoatMap = t.clearcoatMap),
            (this.clearcoatRoughness = t.clearcoatRoughness),
            (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = t.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            (this.dispersion = t.dispersion),
            (this.ior = t.ior),
            (this.iridescence = t.iridescence),
            (this.iridescenceMap = t.iridescenceMap),
            (this.iridescenceIOR = t.iridescenceIOR),
            (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
            (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
            (this.sheen = t.sheen),
            this.sheenColor.copy(t.sheenColor),
            (this.sheenColorMap = t.sheenColorMap),
            (this.sheenRoughness = t.sheenRoughness),
            (this.sheenRoughnessMap = t.sheenRoughnessMap),
            (this.transmission = t.transmission),
            (this.transmissionMap = t.transmissionMap),
            (this.thickness = t.thickness),
            (this.thicknessMap = t.thicknessMap),
            (this.attenuationDistance = t.attenuationDistance),
            this.attenuationColor.copy(t.attenuationColor),
            (this.specularIntensity = t.specularIntensity),
            (this.specularIntensityMap = t.specularIntensityMap),
            this.specularColor.copy(t.specularColor),
            (this.specularColorMap = t.specularColorMap),
            this
          );
        }
      };
      let MeshPhongMaterial = class MeshPhongMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshPhongMaterial = !0),
            (this.type = "MeshPhongMaterial"),
            (this.color = new Color(16777215)),
            (this.specular = new Color(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Color(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = eq),
            (this.normalScale = new Vector2(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new Euler()),
            (this.combine = tr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            (this.shininess = t.shininess),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            this.envMapRotation.copy(t.envMapRotation),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            (this.fog = t.fog),
            this
          );
        }
      };
      let MeshToonMaterial = class MeshToonMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshToonMaterial = !0),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new Color(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Color(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = eq),
            (this.normalScale = new Vector2(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.gradientMap = t.gradientMap),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.fog = t.fog),
            this
          );
        }
      };
      let MeshNormalMaterial = class MeshNormalMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshNormalMaterial = !0),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = eq),
            (this.normalScale = new Vector2(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.flatShading = t.flatShading),
            this
          );
        }
      };
      let MeshLambertMaterial = class MeshLambertMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshLambertMaterial = !0),
            (this.type = "MeshLambertMaterial"),
            (this.color = new Color(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Color(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = eq),
            (this.normalScale = new Vector2(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new Euler()),
            (this.combine = tr),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            this.envMapRotation.copy(t.envMapRotation),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            (this.fog = t.fog),
            this
          );
        }
      };
      let MeshDepthMaterial = class MeshDepthMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = eG),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.depthPacking = t.depthPacking),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          );
        }
      };
      let MeshDistanceMaterial = class MeshDistanceMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = "MeshDistanceMaterial"),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          );
        }
      };
      let MeshMatcapMaterial = class MeshMatcapMaterial extends Material {
        constructor(t) {
          super(),
            (this.isMeshMatcapMaterial = !0),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new Color(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = eq),
            (this.normalScale = new Vector2(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { MATCAP: "" }),
            this.color.copy(t.color),
            (this.matcap = t.matcap),
            (this.map = t.map),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.flatShading = t.flatShading),
            (this.fog = t.fog),
            this
          );
        }
      };
      let LineDashedMaterial = class LineDashedMaterial extends LineBasicMaterial {
        constructor(t) {
          super(),
            (this.isLineDashedMaterial = !0),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.scale = t.scale),
            (this.dashSize = t.dashSize),
            (this.gapSize = t.gapSize),
            this
          );
        }
      };
      function convertArray(t, e, i) {
        return t && (i || t.constructor !== e)
          ? "number" == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t)
          : t;
      }
      function isTypedArray(t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
      }
      function getKeyframeOrder(t) {
        let e = t.length,
          i = Array(e);
        for (let t = 0; t !== e; ++t) i[t] = t;
        return (
          i.sort(function (e, i) {
            return t[e] - t[i];
          }),
          i
        );
      }
      function sortedArray(t, e, i) {
        let r = t.length,
          s = new t.constructor(r);
        for (let n = 0, a = 0; a !== r; ++n) {
          let r = i[n] * e;
          for (let i = 0; i !== e; ++i) s[a++] = t[r + i];
        }
        return s;
      }
      function flattenJSON(t, e, i, r) {
        let s = 1,
          n = t[0];
        for (; void 0 !== n && void 0 === n[r]; ) n = t[s++];
        if (void 0 === n) return;
        let a = n[r];
        if (void 0 !== a) {
          if (Array.isArray(a))
            do
              void 0 !== (a = n[r]) && (e.push(n.time), i.push.apply(i, a)),
                (n = t[s++]);
            while (void 0 !== n);
          else if (void 0 !== a.toArray)
            do
              void 0 !== (a = n[r]) && (e.push(n.time), a.toArray(i, i.length)),
                (n = t[s++]);
            while (void 0 !== n);
          else
            do
              void 0 !== (a = n[r]) && (e.push(n.time), i.push(a)),
                (n = t[s++]);
            while (void 0 !== n);
        }
      }
      let ny = {
        convertArray: convertArray,
        isTypedArray: isTypedArray,
        getKeyframeOrder: getKeyframeOrder,
        sortedArray: sortedArray,
        flattenJSON: flattenJSON,
        subclip: function (t, e, i, r, s = 30) {
          let n = t.clone();
          n.name = e;
          let a = [];
          for (let t = 0; t < n.tracks.length; ++t) {
            let e = n.tracks[t],
              o = e.getValueSize(),
              h = [],
              l = [];
            for (let t = 0; t < e.times.length; ++t) {
              let n = e.times[t] * s;
              if (!(n < i) && !(n >= r)) {
                h.push(e.times[t]);
                for (let i = 0; i < o; ++i) l.push(e.values[t * o + i]);
              }
            }
            0 !== h.length &&
              ((e.times = convertArray(h, e.times.constructor)),
              (e.values = convertArray(l, e.values.constructor)),
              a.push(e));
          }
          n.tracks = a;
          let o = 1 / 0;
          for (let t = 0; t < n.tracks.length; ++t)
            o > n.tracks[t].times[0] && (o = n.tracks[t].times[0]);
          for (let t = 0; t < n.tracks.length; ++t) n.tracks[t].shift(-1 * o);
          return n.resetDuration(), n;
        },
        makeClipAdditive: function (t, e = 0, i = t, r = 30) {
          r <= 0 && (r = 30);
          let s = i.tracks.length,
            n = e / r;
          for (let e = 0; e < s; ++e) {
            let r;
            let s = i.tracks[e],
              a = s.ValueTypeName;
            if ("bool" === a || "string" === a) continue;
            let o = t.tracks.find(function (t) {
              return t.name === s.name && t.ValueTypeName === a;
            });
            if (void 0 === o) continue;
            let h = 0,
              l = s.getValueSize();
            s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (h = l / 3);
            let u = 0,
              c = o.getValueSize();
            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (u = c / 3);
            let d = s.times.length - 1;
            if (n <= s.times[0]) {
              let t = h,
                e = l - h;
              r = s.values.slice(t, e);
            } else if (n >= s.times[d]) {
              let t = d * l + h,
                e = t + l - h;
              r = s.values.slice(t, e);
            } else {
              let t = s.createInterpolant(),
                e = h,
                i = l - h;
              t.evaluate(n), (r = t.resultBuffer.slice(e, i));
            }
            if ("quaternion" === a) {
              let t = new Quaternion().fromArray(r).normalize().conjugate();
              t.toArray(r);
            }
            let p = o.times.length;
            for (let t = 0; t < p; ++t) {
              let e = t * c + u;
              if ("quaternion" === a)
                Quaternion.multiplyQuaternionsFlat(
                  o.values,
                  e,
                  r,
                  0,
                  o.values,
                  e
                );
              else {
                let t = c - 2 * u;
                for (let i = 0; i < t; ++i) o.values[e + i] -= r[i];
              }
            }
          }
          return (t.blendMode = eF), t;
        },
      };
      let Interpolant = class Interpolant {
        constructor(t, e, i, r) {
          (this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== r ? r : new e.constructor(i)),
            (this.sampleValues = e),
            (this.valueSize = i),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(t) {
          let e = this.parameterPositions,
            i = this._cachedIndex,
            r = e[i],
            s = e[i - 1];
          t: {
            e: {
              let n;
              i: {
                r: if (!(t < r)) {
                  for (let n = i + 2; ; ) {
                    if (void 0 === r) {
                      if (t < s) break r;
                      return (
                        (i = e.length),
                        (this._cachedIndex = i),
                        this.copySampleValue_(i - 1)
                      );
                    }
                    if (i === n) break;
                    if (((s = r), t < (r = e[++i]))) break e;
                  }
                  n = e.length;
                  break i;
                }
                if (!(t >= s)) {
                  let a = e[1];
                  t < a && ((i = 2), (s = a));
                  for (let n = i - 2; ; ) {
                    if (void 0 === s)
                      return (this._cachedIndex = 0), this.copySampleValue_(0);
                    if (i === n) break;
                    if (((r = s), t >= (s = e[--i - 1]))) break e;
                  }
                  (n = i), (i = 0);
                  break i;
                }
                break t;
              }
              for (; i < n; ) {
                let r = (i + n) >>> 1;
                t < e[r] ? (n = r) : (i = r + 1);
              }
              if (((r = e[i]), void 0 === (s = e[i - 1])))
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (void 0 === r)
                return (
                  (i = e.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
            }
            (this._cachedIndex = i), this.intervalChanged_(i, s, r);
          }
          return this.interpolate_(i, s, t, r);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t) {
          let e = this.resultBuffer,
            i = this.sampleValues,
            r = this.valueSize,
            s = t * r;
          for (let t = 0; t !== r; ++t) e[t] = i[s + t];
          return e;
        }
        interpolate_() {
          throw Error("call to abstract method");
        }
        intervalChanged_() {}
      };
      let CubicInterpolant = class CubicInterpolant extends Interpolant {
        constructor(t, e, i, r) {
          super(t, e, i, r),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: ek, endingEnd: ek });
        }
        intervalChanged_(t, e, i) {
          let r = this.parameterPositions,
            s = t - 2,
            n = t + 1,
            a = r[s],
            o = r[n];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case eR:
                (s = t), (a = 2 * e - i);
                break;
              case eE:
                (s = r.length - 2), (a = e + r[s] - r[s + 1]);
                break;
              default:
                (s = t), (a = i);
            }
          if (void 0 === o)
            switch (this.getSettings_().endingEnd) {
              case eR:
                (n = t), (o = 2 * i - e);
                break;
              case eE:
                (n = 1), (o = i + r[1] - r[0]);
                break;
              default:
                (n = t - 1), (o = e);
            }
          let h = (i - e) * 0.5,
            l = this.valueSize;
          (this._weightPrev = h / (e - a)),
            (this._weightNext = h / (o - i)),
            (this._offsetPrev = s * l),
            (this._offsetNext = n * l);
        }
        interpolate_(t, e, i, r) {
          let s = this.resultBuffer,
            n = this.sampleValues,
            a = this.valueSize,
            o = t * a,
            h = o - a,
            l = this._offsetPrev,
            u = this._offsetNext,
            c = this._weightPrev,
            d = this._weightNext,
            p = (i - e) / (r - e),
            m = p * p,
            f = m * p,
            y = -c * f + 2 * c * m - c * p,
            g = (1 + c) * f + (-1.5 - 2 * c) * m + (-0.5 + c) * p + 1,
            x = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
            b = d * f - d * m;
          for (let t = 0; t !== a; ++t)
            s[t] = y * n[l + t] + g * n[h + t] + x * n[o + t] + b * n[u + t];
          return s;
        }
      };
      let LinearInterpolant = class LinearInterpolant extends Interpolant {
        constructor(t, e, i, r) {
          super(t, e, i, r);
        }
        interpolate_(t, e, i, r) {
          let s = this.resultBuffer,
            n = this.sampleValues,
            a = this.valueSize,
            o = t * a,
            h = o - a,
            l = (i - e) / (r - e),
            u = 1 - l;
          for (let t = 0; t !== a; ++t) s[t] = n[h + t] * u + n[o + t] * l;
          return s;
        }
      };
      let DiscreteInterpolant = class DiscreteInterpolant extends Interpolant {
        constructor(t, e, i, r) {
          super(t, e, i, r);
        }
        interpolate_(t) {
          return this.copySampleValue_(t - 1);
        }
      };
      let KeyframeTrack = class KeyframeTrack {
        constructor(t, e, i, r) {
          if (void 0 === t)
            throw Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === e || 0 === e.length)
            throw Error(
              "THREE.KeyframeTrack: no keyframes in track named " + t
            );
          (this.name = t),
            (this.times = convertArray(e, this.TimeBufferType)),
            (this.values = convertArray(i, this.ValueBufferType)),
            this.setInterpolation(r || this.DefaultInterpolation);
        }
        static toJSON(t) {
          let e;
          let i = t.constructor;
          if (i.toJSON !== this.toJSON) e = i.toJSON(t);
          else {
            e = {
              name: t.name,
              times: convertArray(t.times, Array),
              values: convertArray(t.values, Array),
            };
            let i = t.getInterpolation();
            i !== t.DefaultInterpolation && (e.interpolation = i);
          }
          return (e.type = t.ValueTypeName), e;
        }
        InterpolantFactoryMethodDiscrete(t) {
          return new DiscreteInterpolant(
            this.times,
            this.values,
            this.getValueSize(),
            t
          );
        }
        InterpolantFactoryMethodLinear(t) {
          return new LinearInterpolant(
            this.times,
            this.values,
            this.getValueSize(),
            t
          );
        }
        InterpolantFactoryMethodSmooth(t) {
          return new CubicInterpolant(
            this.times,
            this.values,
            this.getValueSize(),
            t
          );
        }
        setInterpolation(t) {
          let e;
          switch (t) {
            case eV:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case eP:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case eL:
              e = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e) {
            let e =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (t !== this.DefaultInterpolation)
                this.setInterpolation(this.DefaultInterpolation);
              else throw Error(e);
            }
            return console.warn("THREE.KeyframeTrack:", e), this;
          }
          return (this.createInterpolant = e), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return eV;
            case this.InterpolantFactoryMethodLinear:
              return eP;
            case this.InterpolantFactoryMethodSmooth:
              return eL;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(t) {
          if (0 !== t) {
            let e = this.times;
            for (let i = 0, r = e.length; i !== r; ++i) e[i] += t;
          }
          return this;
        }
        scale(t) {
          if (1 !== t) {
            let e = this.times;
            for (let i = 0, r = e.length; i !== r; ++i) e[i] *= t;
          }
          return this;
        }
        trim(t, e) {
          let i = this.times,
            r = i.length,
            s = 0,
            n = r - 1;
          for (; s !== r && i[s] < t; ) ++s;
          for (; -1 !== n && i[n] > e; ) --n;
          if ((++n, 0 !== s || n !== r)) {
            s >= n && (s = (n = Math.max(n, 1)) - 1);
            let t = this.getValueSize();
            (this.times = i.slice(s, n)),
              (this.values = this.values.slice(s * t, n * t));
          }
          return this;
        }
        validate() {
          let t = !0,
            e = this.getValueSize();
          e - Math.floor(e) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (t = !1));
          let i = this.times,
            r = this.values,
            s = i.length;
          0 === s &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (t = !1));
          let n = null;
          for (let e = 0; e !== s; e++) {
            let r = i[e];
            if ("number" == typeof r && isNaN(r)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                e,
                r
              ),
                (t = !1);
              break;
            }
            if (null !== n && n > r) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                e,
                r,
                n
              ),
                (t = !1);
              break;
            }
            n = r;
          }
          if (void 0 !== r && isTypedArray(r))
            for (let e = 0, i = r.length; e !== i; ++e) {
              let i = r[e];
              if (isNaN(i)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  e,
                  i
                ),
                  (t = !1);
                break;
              }
            }
          return t;
        }
        optimize() {
          let t = this.times.slice(),
            e = this.values.slice(),
            i = this.getValueSize(),
            r = this.getInterpolation() === eL,
            s = t.length - 1,
            n = 1;
          for (let a = 1; a < s; ++a) {
            let s = !1,
              o = t[a],
              h = t[a + 1];
            if (o !== h && (1 !== a || o !== t[0])) {
              if (r) s = !0;
              else {
                let t = a * i,
                  r = t - i,
                  n = t + i;
                for (let a = 0; a !== i; ++a) {
                  let i = e[t + a];
                  if (i !== e[r + a] || i !== e[n + a]) {
                    s = !0;
                    break;
                  }
                }
              }
            }
            if (s) {
              if (a !== n) {
                t[n] = t[a];
                let r = a * i,
                  s = n * i;
                for (let t = 0; t !== i; ++t) e[s + t] = e[r + t];
              }
              ++n;
            }
          }
          if (s > 0) {
            t[n] = t[s];
            for (let t = s * i, r = n * i, a = 0; a !== i; ++a)
              e[r + a] = e[t + a];
            ++n;
          }
          return (
            n !== t.length
              ? ((this.times = t.slice(0, n)),
                (this.values = e.slice(0, n * i)))
              : ((this.times = t), (this.values = e)),
            this
          );
        }
        clone() {
          let t = this.times.slice(),
            e = this.values.slice(),
            i = this.constructor,
            r = new i(this.name, t, e);
          return (r.createInterpolant = this.createInterpolant), r;
        }
      };
      (KeyframeTrack.prototype.TimeBufferType = Float32Array),
        (KeyframeTrack.prototype.ValueBufferType = Float32Array),
        (KeyframeTrack.prototype.DefaultInterpolation = eP);
      let BooleanKeyframeTrack = class BooleanKeyframeTrack extends KeyframeTrack {
        constructor(t, e, i) {
          super(t, e, i);
        }
      };
      (BooleanKeyframeTrack.prototype.ValueTypeName = "bool"),
        (BooleanKeyframeTrack.prototype.ValueBufferType = Array),
        (BooleanKeyframeTrack.prototype.DefaultInterpolation = eV),
        (BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear =
          void 0),
        (BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth =
          void 0);
      let ColorKeyframeTrack = class ColorKeyframeTrack extends KeyframeTrack {};
      ColorKeyframeTrack.prototype.ValueTypeName = "color";
      let NumberKeyframeTrack = class NumberKeyframeTrack extends KeyframeTrack {};
      NumberKeyframeTrack.prototype.ValueTypeName = "number";
      let QuaternionLinearInterpolant = class QuaternionLinearInterpolant extends Interpolant {
        constructor(t, e, i, r) {
          super(t, e, i, r);
        }
        interpolate_(t, e, i, r) {
          let s = this.resultBuffer,
            n = this.sampleValues,
            a = this.valueSize,
            o = (i - e) / (r - e),
            h = t * a;
          for (let t = h + a; h !== t; h += 4)
            Quaternion.slerpFlat(s, 0, n, h - a, n, h, o);
          return s;
        }
      };
      let QuaternionKeyframeTrack = class QuaternionKeyframeTrack extends KeyframeTrack {
        InterpolantFactoryMethodLinear(t) {
          return new QuaternionLinearInterpolant(
            this.times,
            this.values,
            this.getValueSize(),
            t
          );
        }
      };
      (QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion"),
        (QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth =
          void 0);
      let StringKeyframeTrack = class StringKeyframeTrack extends KeyframeTrack {
        constructor(t, e, i) {
          super(t, e, i);
        }
      };
      (StringKeyframeTrack.prototype.ValueTypeName = "string"),
        (StringKeyframeTrack.prototype.ValueBufferType = Array),
        (StringKeyframeTrack.prototype.DefaultInterpolation = eV),
        (StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0),
        (StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0);
      let VectorKeyframeTrack = class VectorKeyframeTrack extends KeyframeTrack {};
      VectorKeyframeTrack.prototype.ValueTypeName = "vector";
      let AnimationClip = class AnimationClip {
        constructor(t = "", e = -1, i = [], r = eO) {
          (this.name = t),
            (this.tracks = i),
            (this.duration = e),
            (this.blendMode = r),
            (this.uuid = generateUUID()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(t) {
          let e = [],
            i = t.tracks,
            r = 1 / (t.fps || 1);
          for (let t = 0, s = i.length; t !== s; ++t)
            e.push(
              (function (t) {
                if (void 0 === t.type)
                  throw Error(
                    "THREE.KeyframeTrack: track type undefined, can not parse"
                  );
                let e = (function (t) {
                  switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                      return NumberKeyframeTrack;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                      return VectorKeyframeTrack;
                    case "color":
                      return ColorKeyframeTrack;
                    case "quaternion":
                      return QuaternionKeyframeTrack;
                    case "bool":
                    case "boolean":
                      return BooleanKeyframeTrack;
                    case "string":
                      return StringKeyframeTrack;
                  }
                  throw Error(
                    "THREE.KeyframeTrack: Unsupported typeName: " + t
                  );
                })(t.type);
                if (void 0 === t.times) {
                  let e = [],
                    i = [];
                  flattenJSON(t.keys, e, i, "value"),
                    (t.times = e),
                    (t.values = i);
                }
                return void 0 !== e.parse
                  ? e.parse(t)
                  : new e(t.name, t.times, t.values, t.interpolation);
              })(i[t]).scale(r)
            );
          let s = new this(t.name, t.duration, e, t.blendMode);
          return (s.uuid = t.uuid), s;
        }
        static toJSON(t) {
          let e = [],
            i = t.tracks,
            r = {
              name: t.name,
              duration: t.duration,
              tracks: e,
              uuid: t.uuid,
              blendMode: t.blendMode,
            };
          for (let t = 0, r = i.length; t !== r; ++t)
            e.push(KeyframeTrack.toJSON(i[t]));
          return r;
        }
        static CreateFromMorphTargetSequence(t, e, i, r) {
          let s = e.length,
            n = [];
          for (let t = 0; t < s; t++) {
            let a = [],
              o = [];
            a.push((t + s - 1) % s, t, (t + 1) % s), o.push(0, 1, 0);
            let h = getKeyframeOrder(a);
            (a = sortedArray(a, 1, h)),
              (o = sortedArray(o, 1, h)),
              r || 0 !== a[0] || (a.push(s), o.push(o[0])),
              n.push(
                new NumberKeyframeTrack(
                  ".morphTargetInfluences[" + e[t].name + "]",
                  a,
                  o
                ).scale(1 / i)
              );
          }
          return new this(t, -1, n);
        }
        static findByName(t, e) {
          let i = t;
          Array.isArray(t) ||
            (i = (t.geometry && t.geometry.animations) || t.animations);
          for (let t = 0; t < i.length; t++) if (i[t].name === e) return i[t];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(t, e, i) {
          let r = {},
            s = /^([\w-]*?)([\d]+)$/;
          for (let e = 0, i = t.length; e < i; e++) {
            let i = t[e],
              n = i.name.match(s);
            if (n && n.length > 1) {
              let t = n[1],
                e = r[t];
              e || (r[t] = e = []), e.push(i);
            }
          }
          let n = [];
          for (let t in r)
            n.push(this.CreateFromMorphTargetSequence(t, r[t], e, i));
          return n;
        }
        static parseAnimation(t, e) {
          if (!t)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          let addNonemptyTrack = function (t, e, i, r, s) {
              if (0 !== i.length) {
                let n = [],
                  a = [];
                flattenJSON(i, n, a, r),
                  0 !== n.length && s.push(new t(e, n, a));
              }
            },
            i = [],
            r = t.name || "default",
            s = t.fps || 30,
            n = t.blendMode,
            a = t.length || -1,
            o = t.hierarchy || [];
          for (let t = 0; t < o.length; t++) {
            let r = o[t].keys;
            if (r && 0 !== r.length) {
              if (r[0].morphTargets) {
                let t;
                let e = {};
                for (t = 0; t < r.length; t++)
                  if (r[t].morphTargets)
                    for (let i = 0; i < r[t].morphTargets.length; i++)
                      e[r[t].morphTargets[i]] = -1;
                for (let s in e) {
                  let e = [],
                    n = [];
                  for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                    let i = r[t];
                    e.push(i.time), n.push(i.morphTarget === s ? 1 : 0);
                  }
                  i.push(
                    new NumberKeyframeTrack(
                      ".morphTargetInfluence[" + s + "]",
                      e,
                      n
                    )
                  );
                }
                a = e.length * s;
              } else {
                let s = ".bones[" + e[t].name + "]";
                addNonemptyTrack(
                  VectorKeyframeTrack,
                  s + ".position",
                  r,
                  "pos",
                  i
                ),
                  addNonemptyTrack(
                    QuaternionKeyframeTrack,
                    s + ".quaternion",
                    r,
                    "rot",
                    i
                  ),
                  addNonemptyTrack(
                    VectorKeyframeTrack,
                    s + ".scale",
                    r,
                    "scl",
                    i
                  );
              }
            }
          }
          if (0 === i.length) return null;
          let h = new this(r, a, i, n);
          return h;
        }
        resetDuration() {
          let t = this.tracks,
            e = 0;
          for (let i = 0, r = t.length; i !== r; ++i) {
            let t = this.tracks[i];
            e = Math.max(e, t.times[t.times.length - 1]);
          }
          return (this.duration = e), this;
        }
        trim() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
          return this;
        }
        validate() {
          let t = !0;
          for (let e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate();
          return t;
        }
        optimize() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
          return this;
        }
        clone() {
          let t = [];
          for (let e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone());
          return new this.constructor(
            this.name,
            this.duration,
            t,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      };
      let ng = {
        enabled: !1,
        files: {},
        add: function (t, e) {
          !1 !== this.enabled && (this.files[t] = e);
        },
        get: function (t) {
          if (!1 !== this.enabled) return this.files[t];
        },
        remove: function (t) {
          delete this.files[t];
        },
        clear: function () {
          this.files = {};
        },
      };
      let LoadingManager = class LoadingManager {
        constructor(t, e, i) {
          let r;
          let s = this,
            n = !1,
            a = 0,
            o = 0,
            h = [];
          (this.onStart = void 0),
            (this.onLoad = t),
            (this.onProgress = e),
            (this.onError = i),
            (this.itemStart = function (t) {
              o++,
                !1 === n && void 0 !== s.onStart && s.onStart(t, a, o),
                (n = !0);
            }),
            (this.itemEnd = function (t) {
              a++,
                void 0 !== s.onProgress && s.onProgress(t, a, o),
                a === o && ((n = !1), void 0 !== s.onLoad && s.onLoad());
            }),
            (this.itemError = function (t) {
              void 0 !== s.onError && s.onError(t);
            }),
            (this.resolveURL = function (t) {
              return r ? r(t) : t;
            }),
            (this.setURLModifier = function (t) {
              return (r = t), this;
            }),
            (this.addHandler = function (t, e) {
              return h.push(t, e), this;
            }),
            (this.removeHandler = function (t) {
              let e = h.indexOf(t);
              return -1 !== e && h.splice(e, 2), this;
            }),
            (this.getHandler = function (t) {
              for (let e = 0, i = h.length; e < i; e += 2) {
                let i = h[e],
                  r = h[e + 1];
                if ((i.global && (i.lastIndex = 0), i.test(t))) return r;
              }
              return null;
            });
        }
      };
      let nx = new LoadingManager();
      let Loader = class Loader {
        constructor(t) {
          (this.manager = void 0 !== t ? t : nx),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(t, e) {
          let i = this;
          return new Promise(function (r, s) {
            i.load(t, r, e, s);
          });
        }
        parse() {}
        setCrossOrigin(t) {
          return (this.crossOrigin = t), this;
        }
        setWithCredentials(t) {
          return (this.withCredentials = t), this;
        }
        setPath(t) {
          return (this.path = t), this;
        }
        setResourcePath(t) {
          return (this.resourcePath = t), this;
        }
        setRequestHeader(t) {
          return (this.requestHeader = t), this;
        }
      };
      Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      let nb = {};
      let HttpError = class HttpError extends Error {
        constructor(t, e) {
          super(t), (this.response = e);
        }
      };
      let FileLoader = class FileLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          let s = ng.get(t);
          if (void 0 !== s)
            return (
              this.manager.itemStart(t),
              setTimeout(() => {
                e && e(s), this.manager.itemEnd(t);
              }, 0),
              s
            );
          if (void 0 !== nb[t]) {
            nb[t].push({ onLoad: e, onProgress: i, onError: r });
            return;
          }
          (nb[t] = []), nb[t].push({ onLoad: e, onProgress: i, onError: r });
          let n = new Request(t, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            a = this.mimeType,
            o = this.responseType;
          fetch(n)
            .then((e) => {
              if (200 === e.status || 0 === e.status) {
                if (
                  (0 === e.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  "undefined" == typeof ReadableStream ||
                    void 0 === e.body ||
                    void 0 === e.body.getReader)
                )
                  return e;
                let i = nb[t],
                  r = e.body.getReader(),
                  s =
                    e.headers.get("X-File-Size") ||
                    e.headers.get("Content-Length"),
                  n = s ? parseInt(s) : 0,
                  a = 0 !== n,
                  o = 0,
                  h = new ReadableStream({
                    start(t) {
                      (function readData() {
                        r.read().then(
                          ({ done: e, value: r }) => {
                            if (e) t.close();
                            else {
                              o += r.byteLength;
                              let e = new ProgressEvent("progress", {
                                lengthComputable: a,
                                loaded: o,
                                total: n,
                              });
                              for (let t = 0, r = i.length; t < r; t++) {
                                let r = i[t];
                                r.onProgress && r.onProgress(e);
                              }
                              t.enqueue(r), readData();
                            }
                          },
                          (e) => {
                            t.error(e);
                          }
                        );
                      })();
                    },
                  });
                return new Response(h);
              }
              throw new HttpError(
                `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,
                e
              );
            })
            .then((t) => {
              switch (o) {
                case "arraybuffer":
                  return t.arrayBuffer();
                case "blob":
                  return t.blob();
                case "document":
                  return t.text().then((t) => {
                    let e = new DOMParser();
                    return e.parseFromString(t, a);
                  });
                case "json":
                  return t.json();
                default:
                  if (void 0 === a) return t.text();
                  {
                    let e = /charset="?([^;"\s]*)"?/i.exec(a),
                      i = e && e[1] ? e[1].toLowerCase() : void 0,
                      r = new TextDecoder(i);
                    return t.arrayBuffer().then((t) => r.decode(t));
                  }
              }
            })
            .then((e) => {
              ng.add(t, e);
              let i = nb[t];
              delete nb[t];
              for (let t = 0, r = i.length; t < r; t++) {
                let r = i[t];
                r.onLoad && r.onLoad(e);
              }
            })
            .catch((e) => {
              let i = nb[t];
              if (void 0 === i) throw (this.manager.itemError(t), e);
              delete nb[t];
              for (let t = 0, r = i.length; t < r; t++) {
                let r = i[t];
                r.onError && r.onError(e);
              }
              this.manager.itemError(t);
            })
            .finally(() => {
              this.manager.itemEnd(t);
            }),
            this.manager.itemStart(t);
        }
        setResponseType(t) {
          return (this.responseType = t), this;
        }
        setMimeType(t) {
          return (this.mimeType = t), this;
        }
      };
      let AnimationLoader = class AnimationLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          let s = this,
            n = new FileLoader(this.manager);
          n.setPath(this.path),
            n.setRequestHeader(this.requestHeader),
            n.setWithCredentials(this.withCredentials),
            n.load(
              t,
              function (i) {
                try {
                  e(s.parse(JSON.parse(i)));
                } catch (e) {
                  r ? r(e) : console.error(e), s.manager.itemError(t);
                }
              },
              i,
              r
            );
        }
        parse(t) {
          let e = [];
          for (let i = 0; i < t.length; i++) {
            let r = AnimationClip.parse(t[i]);
            e.push(r);
          }
          return e;
        }
      };
      let CompressedTextureLoader = class CompressedTextureLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          let s = this,
            n = [],
            a = new CompressedTexture(),
            o = new FileLoader(this.manager);
          o.setPath(this.path),
            o.setResponseType("arraybuffer"),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(s.withCredentials);
          let h = 0;
          if (Array.isArray(t))
            for (let l = 0, u = t.length; l < u; ++l)
              !(function (l) {
                o.load(
                  t[l],
                  function (t) {
                    let i = s.parse(t, !0);
                    (n[l] = {
                      width: i.width,
                      height: i.height,
                      format: i.format,
                      mipmaps: i.mipmaps,
                    }),
                      6 === (h += 1) &&
                        (1 === i.mipmapCount && (a.minFilter = tI),
                        (a.image = n),
                        (a.format = i.format),
                        (a.needsUpdate = !0),
                        e && e(a));
                  },
                  i,
                  r
                );
              })(l);
          else
            o.load(
              t,
              function (t) {
                let i = s.parse(t, !0);
                if (i.isCubemap) {
                  let t = i.mipmaps.length / i.mipmapCount;
                  for (let e = 0; e < t; e++) {
                    n[e] = { mipmaps: [] };
                    for (let t = 0; t < i.mipmapCount; t++)
                      n[e].mipmaps.push(i.mipmaps[e * i.mipmapCount + t]),
                        (n[e].format = i.format),
                        (n[e].width = i.width),
                        (n[e].height = i.height);
                  }
                  a.image = n;
                } else
                  (a.image.width = i.width),
                    (a.image.height = i.height),
                    (a.mipmaps = i.mipmaps);
                1 === i.mipmapCount && (a.minFilter = tI),
                  (a.format = i.format),
                  (a.needsUpdate = !0),
                  e && e(a);
              },
              i,
              r
            );
          return a;
        }
      };
      let ImageLoader = class ImageLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          let s = this,
            n = ng.get(t);
          if (void 0 !== n)
            return (
              s.manager.itemStart(t),
              setTimeout(function () {
                e && e(n), s.manager.itemEnd(t);
              }, 0),
              n
            );
          let a = createElementNS("img");
          function onImageLoad() {
            removeEventListeners(),
              ng.add(t, this),
              e && e(this),
              s.manager.itemEnd(t);
          }
          function onImageError(e) {
            removeEventListeners(),
              r && r(e),
              s.manager.itemError(t),
              s.manager.itemEnd(t);
          }
          function removeEventListeners() {
            a.removeEventListener("load", onImageLoad, !1),
              a.removeEventListener("error", onImageError, !1);
          }
          return (
            a.addEventListener("load", onImageLoad, !1),
            a.addEventListener("error", onImageError, !1),
            "data:" !== t.slice(0, 5) &&
              void 0 !== this.crossOrigin &&
              (a.crossOrigin = this.crossOrigin),
            s.manager.itemStart(t),
            (a.src = t),
            a
          );
        }
      };
      let CubeTextureLoader = class CubeTextureLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          let s = new CubeTexture();
          s.colorSpace = eX;
          let n = new ImageLoader(this.manager);
          n.setCrossOrigin(this.crossOrigin), n.setPath(this.path);
          let a = 0;
          for (let i = 0; i < t.length; ++i)
            !(function (i) {
              n.load(
                t[i],
                function (t) {
                  (s.images[i] = t),
                    6 == ++a && ((s.needsUpdate = !0), e && e(s));
                },
                void 0,
                r
              );
            })(i);
          return s;
        }
      };
      let DataTextureLoader = class DataTextureLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          let s = this,
            n = new DataTexture(),
            a = new FileLoader(this.manager);
          return (
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(s.withCredentials),
            a.load(
              t,
              function (t) {
                let i;
                try {
                  i = s.parse(t);
                } catch (t) {
                  if (void 0 !== r) r(t);
                  else {
                    console.error(t);
                    return;
                  }
                }
                void 0 !== i.image
                  ? (n.image = i.image)
                  : void 0 !== i.data &&
                    ((n.image.width = i.width),
                    (n.image.height = i.height),
                    (n.image.data = i.data)),
                  (n.wrapS = void 0 !== i.wrapS ? i.wrapS : tS),
                  (n.wrapT = void 0 !== i.wrapT ? i.wrapT : tS),
                  (n.magFilter = void 0 !== i.magFilter ? i.magFilter : tI),
                  (n.minFilter = void 0 !== i.minFilter ? i.minFilter : tI),
                  (n.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1),
                  void 0 !== i.colorSpace && (n.colorSpace = i.colorSpace),
                  void 0 !== i.flipY && (n.flipY = i.flipY),
                  void 0 !== i.format && (n.format = i.format),
                  void 0 !== i.type && (n.type = i.type),
                  void 0 !== i.mipmaps &&
                    ((n.mipmaps = i.mipmaps), (n.minFilter = tL)),
                  1 === i.mipmapCount && (n.minFilter = tI),
                  void 0 !== i.generateMipmaps &&
                    (n.generateMipmaps = i.generateMipmaps),
                  (n.needsUpdate = !0),
                  e && e(n, i);
              },
              i,
              r
            ),
            n
          );
        }
      };
      let TextureLoader = class TextureLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          let s = new Texture(),
            n = new ImageLoader(this.manager);
          return (
            n.setCrossOrigin(this.crossOrigin),
            n.setPath(this.path),
            n.load(
              t,
              function (t) {
                (s.image = t), (s.needsUpdate = !0), void 0 !== e && e(s);
              },
              i,
              r
            ),
            s
          );
        }
      };
      let Light = class Light extends Object3D {
        constructor(t, e = 1) {
          super(),
            (this.isLight = !0),
            (this.type = "Light"),
            (this.color = new Color(t)),
            (this.intensity = e);
        }
        dispose() {}
        copy(t, e) {
          return (
            super.copy(t, e),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        }
        toJSON(t) {
          let e = super.toJSON(t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            void 0 !== this.target && (e.object.target = this.target.uuid),
            e
          );
        }
      };
      let HemisphereLight = class HemisphereLight extends Light {
        constructor(t, e, i) {
          super(t, i),
            (this.isHemisphereLight = !0),
            (this.type = "HemisphereLight"),
            this.position.copy(Object3D.DEFAULT_UP),
            this.updateMatrix(),
            (this.groundColor = new Color(e));
        }
        copy(t, e) {
          return super.copy(t, e), this.groundColor.copy(t.groundColor), this;
        }
      };
      let nv = new Matrix4(),
        nM = new Vector3(),
        nw = new Vector3();
      let LightShadow = class LightShadow {
        constructor(t) {
          (this.camera = t),
            (this.intensity = 1),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new Vector2(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new Matrix4()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Frustum()),
            (this._frameExtents = new Vector2(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Vector4(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t) {
          let e = this.camera,
            i = this.matrix;
          nM.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(nM),
            nw.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(nw),
            e.updateMatrixWorld(),
            nv.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(nv),
            i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            i.multiply(nv);
        }
        getViewport(t) {
          return this._viewports[t];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
          return (
            (this.camera = t.camera.clone()),
            (this.intensity = t.intensity),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          let t = {};
          return (
            1 !== this.intensity && (t.intensity = this.intensity),
            0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            (512 !== this.mapSize.x || 512 !== this.mapSize.y) &&
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        }
      };
      let SpotLightShadow = class SpotLightShadow extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(50, 1, 0.5, 500)),
            (this.isSpotLightShadow = !0),
            (this.focus = 1);
        }
        updateMatrices(t) {
          let e = this.camera,
            i = 2 * iV * t.angle * this.focus,
            r = this.mapSize.width / this.mapSize.height,
            s = t.distance || e.far;
          (i !== e.fov || r !== e.aspect || s !== e.far) &&
            ((e.fov = i),
            (e.aspect = r),
            (e.far = s),
            e.updateProjectionMatrix()),
            super.updateMatrices(t);
        }
        copy(t) {
          return super.copy(t), (this.focus = t.focus), this;
        }
      };
      let SpotLight = class SpotLight extends Light {
        constructor(t, e, i = 0, r = Math.PI / 3, s = 0, n = 2) {
          super(t, e),
            (this.isSpotLight = !0),
            (this.type = "SpotLight"),
            this.position.copy(Object3D.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new Object3D()),
            (this.distance = i),
            (this.angle = r),
            (this.penumbra = s),
            (this.decay = n),
            (this.map = null),
            (this.shadow = new SpotLightShadow());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      };
      let nS = new Matrix4(),
        nA = new Vector3(),
        n_ = new Vector3();
      let PointLightShadow = class PointLightShadow extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new Vector2(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new Vector4(2, 1, 1, 1),
              new Vector4(0, 1, 1, 1),
              new Vector4(3, 1, 1, 1),
              new Vector4(1, 1, 1, 1),
              new Vector4(3, 0, 1, 1),
              new Vector4(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new Vector3(1, 0, 0),
              new Vector3(-1, 0, 0),
              new Vector3(0, 0, 1),
              new Vector3(0, 0, -1),
              new Vector3(0, 1, 0),
              new Vector3(0, -1, 0),
            ]),
            (this._cubeUps = [
              new Vector3(0, 1, 0),
              new Vector3(0, 1, 0),
              new Vector3(0, 1, 0),
              new Vector3(0, 1, 0),
              new Vector3(0, 0, 1),
              new Vector3(0, 0, -1),
            ]);
        }
        updateMatrices(t, e = 0) {
          let i = this.camera,
            r = this.matrix,
            s = t.distance || i.far;
          s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
            nA.setFromMatrixPosition(t.matrixWorld),
            i.position.copy(nA),
            n_.copy(i.position),
            n_.add(this._cubeDirections[e]),
            i.up.copy(this._cubeUps[e]),
            i.lookAt(n_),
            i.updateMatrixWorld(),
            r.makeTranslation(-nA.x, -nA.y, -nA.z),
            nS.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(nS);
        }
      };
      let PointLight = class PointLight extends Light {
        constructor(t, e, i = 0, r = 2) {
          super(t, e),
            (this.isPointLight = !0),
            (this.type = "PointLight"),
            (this.distance = i),
            (this.decay = r),
            (this.shadow = new PointLightShadow());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      };
      let OrthographicCamera = class OrthographicCamera extends Camera {
        constructor(t = -1, e = 1, i = 1, r = -1, s = 0.1, n = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = t),
            (this.right = e),
            (this.top = i),
            (this.bottom = r),
            (this.near = s),
            (this.far = n),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        }
        setViewOffset(t, e, i, r, s, n) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = n),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          let t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2,
            s = i - t,
            n = i + t,
            a = r + e,
            o = r - e;
          if (null !== this.view && this.view.enabled) {
            let t = (this.right - this.left) / this.view.fullWidth / this.zoom,
              e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (s += t * this.view.offsetX),
              (n = s + t * this.view.width),
              (a -= e * this.view.offsetY),
              (o = a - e * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            s,
            n,
            a,
            o,
            this.near,
            this.far,
            this.coordinateSystem
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          let e = super.toJSON(t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        }
      };
      let DirectionalLightShadow = class DirectionalLightShadow extends LightShadow {
        constructor() {
          super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)),
            (this.isDirectionalLightShadow = !0);
        }
      };
      let DirectionalLight = class DirectionalLight extends Light {
        constructor(t, e) {
          super(t, e),
            (this.isDirectionalLight = !0),
            (this.type = "DirectionalLight"),
            this.position.copy(Object3D.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new Object3D()),
            (this.shadow = new DirectionalLightShadow());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      };
      let AmbientLight = class AmbientLight extends Light {
        constructor(t, e) {
          super(t, e), (this.isAmbientLight = !0), (this.type = "AmbientLight");
        }
      };
      let RectAreaLight = class RectAreaLight extends Light {
        constructor(t, e, i = 10, r = 10) {
          super(t, e),
            (this.isRectAreaLight = !0),
            (this.type = "RectAreaLight"),
            (this.width = i),
            (this.height = r);
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(t) {
          this.intensity = t / (this.width * this.height * Math.PI);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        }
        toJSON(t) {
          let e = super.toJSON(t);
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          );
        }
      };
      let SphericalHarmonics3 = class SphericalHarmonics3 {
        constructor() {
          (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
          for (let t = 0; t < 9; t++) this.coefficients.push(new Vector3());
        }
        set(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
          return this;
        }
        zero() {
          for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
          return this;
        }
        getAt(t, e) {
          let i = t.x,
            r = t.y,
            s = t.z,
            n = this.coefficients;
          return (
            e.copy(n[0]).multiplyScalar(0.282095),
            e.addScaledVector(n[1], 0.488603 * r),
            e.addScaledVector(n[2], 0.488603 * s),
            e.addScaledVector(n[3], 0.488603 * i),
            e.addScaledVector(n[4], 1.092548 * (i * r)),
            e.addScaledVector(n[5], 1.092548 * (r * s)),
            e.addScaledVector(n[6], 0.315392 * (3 * s * s - 1)),
            e.addScaledVector(n[7], 1.092548 * (i * s)),
            e.addScaledVector(n[8], 0.546274 * (i * i - r * r)),
            e
          );
        }
        getIrradianceAt(t, e) {
          let i = t.x,
            r = t.y,
            s = t.z,
            n = this.coefficients;
          return (
            e.copy(n[0]).multiplyScalar(0.886227),
            e.addScaledVector(n[1], 1.023328 * r),
            e.addScaledVector(n[2], 1.023328 * s),
            e.addScaledVector(n[3], 1.023328 * i),
            e.addScaledVector(n[4], 0.858086 * i * r),
            e.addScaledVector(n[5], 0.858086 * r * s),
            e.addScaledVector(n[6], 0.743125 * s * s - 0.247708),
            e.addScaledVector(n[7], 0.858086 * i * s),
            e.addScaledVector(n[8], 0.429043 * (i * i - r * r)),
            e
          );
        }
        add(t) {
          for (let e = 0; e < 9; e++)
            this.coefficients[e].add(t.coefficients[e]);
          return this;
        }
        addScaledSH(t, e) {
          for (let i = 0; i < 9; i++)
            this.coefficients[i].addScaledVector(t.coefficients[i], e);
          return this;
        }
        scale(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
          return this;
        }
        lerp(t, e) {
          for (let i = 0; i < 9; i++)
            this.coefficients[i].lerp(t.coefficients[i], e);
          return this;
        }
        equals(t) {
          for (let e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
          return !0;
        }
        copy(t) {
          return this.set(t.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(t, e = 0) {
          let i = this.coefficients;
          for (let r = 0; r < 9; r++) i[r].fromArray(t, e + 3 * r);
          return this;
        }
        toArray(t = [], e = 0) {
          let i = this.coefficients;
          for (let r = 0; r < 9; r++) i[r].toArray(t, e + 3 * r);
          return t;
        }
        static getBasisAt(t, e) {
          let i = t.x,
            r = t.y,
            s = t.z;
          (e[0] = 0.282095),
            (e[1] = 0.488603 * r),
            (e[2] = 0.488603 * s),
            (e[3] = 0.488603 * i),
            (e[4] = 1.092548 * i * r),
            (e[5] = 1.092548 * r * s),
            (e[6] = 0.315392 * (3 * s * s - 1)),
            (e[7] = 1.092548 * i * s),
            (e[8] = 0.546274 * (i * i - r * r));
        }
      };
      let LightProbe = class LightProbe extends Light {
        constructor(t = new SphericalHarmonics3(), e = 1) {
          super(void 0, e), (this.isLightProbe = !0), (this.sh = t);
        }
        copy(t) {
          return super.copy(t), this.sh.copy(t.sh), this;
        }
        fromJSON(t) {
          return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
        }
        toJSON(t) {
          let e = super.toJSON(t);
          return (e.object.sh = this.sh.toArray()), e;
        }
      };
      let MaterialLoader = class MaterialLoader extends Loader {
        constructor(t) {
          super(t), (this.textures = {});
        }
        load(t, e, i, r) {
          let s = this,
            n = new FileLoader(s.manager);
          n.setPath(s.path),
            n.setRequestHeader(s.requestHeader),
            n.setWithCredentials(s.withCredentials),
            n.load(
              t,
              function (i) {
                try {
                  e(s.parse(JSON.parse(i)));
                } catch (e) {
                  r ? r(e) : console.error(e), s.manager.itemError(t);
                }
              },
              i,
              r
            );
        }
        parse(t) {
          let e = this.textures;
          function getTexture(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
              e[t]
            );
          }
          let i = this.createMaterialFromType(t.type);
          if (
            (void 0 !== t.uuid && (i.uuid = t.uuid),
            void 0 !== t.name && (i.name = t.name),
            void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color),
            void 0 !== t.roughness && (i.roughness = t.roughness),
            void 0 !== t.metalness && (i.metalness = t.metalness),
            void 0 !== t.sheen && (i.sheen = t.sheen),
            void 0 !== t.sheenColor &&
              (i.sheenColor = new Color().setHex(t.sheenColor)),
            void 0 !== t.sheenRoughness &&
              (i.sheenRoughness = t.sheenRoughness),
            void 0 !== t.emissive &&
              void 0 !== i.emissive &&
              i.emissive.setHex(t.emissive),
            void 0 !== t.specular &&
              void 0 !== i.specular &&
              i.specular.setHex(t.specular),
            void 0 !== t.specularIntensity &&
              (i.specularIntensity = t.specularIntensity),
            void 0 !== t.specularColor &&
              void 0 !== i.specularColor &&
              i.specularColor.setHex(t.specularColor),
            void 0 !== t.shininess && (i.shininess = t.shininess),
            void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness &&
              (i.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.dispersion && (i.dispersion = t.dispersion),
            void 0 !== t.iridescence && (i.iridescence = t.iridescence),
            void 0 !== t.iridescenceIOR &&
              (i.iridescenceIOR = t.iridescenceIOR),
            void 0 !== t.iridescenceThicknessRange &&
              (i.iridescenceThicknessRange = t.iridescenceThicknessRange),
            void 0 !== t.transmission && (i.transmission = t.transmission),
            void 0 !== t.thickness && (i.thickness = t.thickness),
            void 0 !== t.attenuationDistance &&
              (i.attenuationDistance = t.attenuationDistance),
            void 0 !== t.attenuationColor &&
              void 0 !== i.attenuationColor &&
              i.attenuationColor.setHex(t.attenuationColor),
            void 0 !== t.anisotropy && (i.anisotropy = t.anisotropy),
            void 0 !== t.anisotropyRotation &&
              (i.anisotropyRotation = t.anisotropyRotation),
            void 0 !== t.fog && (i.fog = t.fog),
            void 0 !== t.flatShading && (i.flatShading = t.flatShading),
            void 0 !== t.blending && (i.blending = t.blending),
            void 0 !== t.combine && (i.combine = t.combine),
            void 0 !== t.side && (i.side = t.side),
            void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),
            void 0 !== t.opacity && (i.opacity = t.opacity),
            void 0 !== t.transparent && (i.transparent = t.transparent),
            void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
            void 0 !== t.alphaHash && (i.alphaHash = t.alphaHash),
            void 0 !== t.depthFunc && (i.depthFunc = t.depthFunc),
            void 0 !== t.depthTest && (i.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
            void 0 !== t.blendSrc && (i.blendSrc = t.blendSrc),
            void 0 !== t.blendDst && (i.blendDst = t.blendDst),
            void 0 !== t.blendEquation && (i.blendEquation = t.blendEquation),
            void 0 !== t.blendSrcAlpha && (i.blendSrcAlpha = t.blendSrcAlpha),
            void 0 !== t.blendDstAlpha && (i.blendDstAlpha = t.blendDstAlpha),
            void 0 !== t.blendEquationAlpha &&
              (i.blendEquationAlpha = t.blendEquationAlpha),
            void 0 !== t.blendColor &&
              void 0 !== i.blendColor &&
              i.blendColor.setHex(t.blendColor),
            void 0 !== t.blendAlpha && (i.blendAlpha = t.blendAlpha),
            void 0 !== t.stencilWriteMask &&
              (i.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask &&
              (i.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
            void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
            void 0 !== t.wireframe && (i.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth &&
              (i.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap &&
              (i.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin &&
              (i.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (i.rotation = t.rotation),
            void 0 !== t.linewidth && (i.linewidth = t.linewidth),
            void 0 !== t.dashSize && (i.dashSize = t.dashSize),
            void 0 !== t.gapSize && (i.gapSize = t.gapSize),
            void 0 !== t.scale && (i.scale = t.scale),
            void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor &&
              (i.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits &&
              (i.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.dithering && (i.dithering = t.dithering),
            void 0 !== t.alphaToCoverage &&
              (i.alphaToCoverage = t.alphaToCoverage),
            void 0 !== t.premultipliedAlpha &&
              (i.premultipliedAlpha = t.premultipliedAlpha),
            void 0 !== t.forceSinglePass &&
              (i.forceSinglePass = t.forceSinglePass),
            void 0 !== t.visible && (i.visible = t.visible),
            void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
            void 0 !== t.userData && (i.userData = t.userData),
            void 0 !== t.vertexColors &&
              ("number" == typeof t.vertexColors
                ? (i.vertexColors = t.vertexColors > 0)
                : (i.vertexColors = t.vertexColors)),
            void 0 !== t.uniforms)
          )
            for (let e in t.uniforms) {
              let r = t.uniforms[e];
              switch (((i.uniforms[e] = {}), r.type)) {
                case "t":
                  i.uniforms[e].value = getTexture(r.value);
                  break;
                case "c":
                  i.uniforms[e].value = new Color().setHex(r.value);
                  break;
                case "v2":
                  i.uniforms[e].value = new Vector2().fromArray(r.value);
                  break;
                case "v3":
                  i.uniforms[e].value = new Vector3().fromArray(r.value);
                  break;
                case "v4":
                  i.uniforms[e].value = new Vector4().fromArray(r.value);
                  break;
                case "m3":
                  i.uniforms[e].value = new Matrix3().fromArray(r.value);
                  break;
                case "m4":
                  i.uniforms[e].value = new Matrix4().fromArray(r.value);
                  break;
                default:
                  i.uniforms[e].value = r.value;
              }
            }
          if (
            (void 0 !== t.defines && (i.defines = t.defines),
            void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader &&
              (i.fragmentShader = t.fragmentShader),
            void 0 !== t.glslVersion && (i.glslVersion = t.glslVersion),
            void 0 !== t.extensions)
          )
            for (let e in t.extensions) i.extensions[e] = t.extensions[e];
          if (
            (void 0 !== t.lights && (i.lights = t.lights),
            void 0 !== t.clipping && (i.clipping = t.clipping),
            void 0 !== t.size && (i.size = t.size),
            void 0 !== t.sizeAttenuation &&
              (i.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (i.map = getTexture(t.map)),
            void 0 !== t.matcap && (i.matcap = getTexture(t.matcap)),
            void 0 !== t.alphaMap && (i.alphaMap = getTexture(t.alphaMap)),
            void 0 !== t.bumpMap && (i.bumpMap = getTexture(t.bumpMap)),
            void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (i.normalMap = getTexture(t.normalMap)),
            void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
            void 0 !== t.normalScale)
          ) {
            let e = t.normalScale;
            !1 === Array.isArray(e) && (e = [e, e]),
              (i.normalScale = new Vector2().fromArray(e));
          }
          return (
            void 0 !== t.displacementMap &&
              (i.displacementMap = getTexture(t.displacementMap)),
            void 0 !== t.displacementScale &&
              (i.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias &&
              (i.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap &&
              (i.roughnessMap = getTexture(t.roughnessMap)),
            void 0 !== t.metalnessMap &&
              (i.metalnessMap = getTexture(t.metalnessMap)),
            void 0 !== t.emissiveMap &&
              (i.emissiveMap = getTexture(t.emissiveMap)),
            void 0 !== t.emissiveIntensity &&
              (i.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap &&
              (i.specularMap = getTexture(t.specularMap)),
            void 0 !== t.specularIntensityMap &&
              (i.specularIntensityMap = getTexture(t.specularIntensityMap)),
            void 0 !== t.specularColorMap &&
              (i.specularColorMap = getTexture(t.specularColorMap)),
            void 0 !== t.envMap && (i.envMap = getTexture(t.envMap)),
            void 0 !== t.envMapRotation &&
              i.envMapRotation.fromArray(t.envMapRotation),
            void 0 !== t.envMapIntensity &&
              (i.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio &&
              (i.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (i.lightMap = getTexture(t.lightMap)),
            void 0 !== t.lightMapIntensity &&
              (i.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (i.aoMap = getTexture(t.aoMap)),
            void 0 !== t.aoMapIntensity &&
              (i.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap &&
              (i.gradientMap = getTexture(t.gradientMap)),
            void 0 !== t.clearcoatMap &&
              (i.clearcoatMap = getTexture(t.clearcoatMap)),
            void 0 !== t.clearcoatRoughnessMap &&
              (i.clearcoatRoughnessMap = getTexture(t.clearcoatRoughnessMap)),
            void 0 !== t.clearcoatNormalMap &&
              (i.clearcoatNormalMap = getTexture(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale &&
              (i.clearcoatNormalScale = new Vector2().fromArray(
                t.clearcoatNormalScale
              )),
            void 0 !== t.iridescenceMap &&
              (i.iridescenceMap = getTexture(t.iridescenceMap)),
            void 0 !== t.iridescenceThicknessMap &&
              (i.iridescenceThicknessMap = getTexture(
                t.iridescenceThicknessMap
              )),
            void 0 !== t.transmissionMap &&
              (i.transmissionMap = getTexture(t.transmissionMap)),
            void 0 !== t.thicknessMap &&
              (i.thicknessMap = getTexture(t.thicknessMap)),
            void 0 !== t.anisotropyMap &&
              (i.anisotropyMap = getTexture(t.anisotropyMap)),
            void 0 !== t.sheenColorMap &&
              (i.sheenColorMap = getTexture(t.sheenColorMap)),
            void 0 !== t.sheenRoughnessMap &&
              (i.sheenRoughnessMap = getTexture(t.sheenRoughnessMap)),
            i
          );
        }
        setTextures(t) {
          return (this.textures = t), this;
        }
        createMaterialFromType(t) {
          return MaterialLoader.createMaterialFromType(t);
        }
        static createMaterialFromType(t) {
          return new {
            ShadowMaterial,
            SpriteMaterial,
            RawShaderMaterial,
            ShaderMaterial,
            PointsMaterial,
            MeshPhysicalMaterial,
            MeshStandardMaterial,
            MeshPhongMaterial,
            MeshToonMaterial,
            MeshNormalMaterial,
            MeshLambertMaterial,
            MeshDepthMaterial,
            MeshDistanceMaterial,
            MeshBasicMaterial,
            MeshMatcapMaterial,
            LineDashedMaterial,
            LineBasicMaterial,
            Material,
          }[t]();
        }
      };
      let LoaderUtils = class LoaderUtils {
        static decodeText(t) {
          if (
            (console.warn(
              "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
            ),
            "undefined" != typeof TextDecoder)
          )
            return new TextDecoder().decode(t);
          let e = "";
          for (let i = 0, r = t.length; i < r; i++)
            e += String.fromCharCode(t[i]);
          try {
            return decodeURIComponent(escape(e));
          } catch (t) {
            return e;
          }
        }
        static extractUrlBase(t) {
          let e = t.lastIndexOf("/");
          return -1 === e ? "./" : t.slice(0, e + 1);
        }
        static resolveURL(t, e) {
          return "string" != typeof t || "" === t
            ? ""
            : (/^https?:\/\//i.test(e) &&
                /^\//.test(t) &&
                (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(t) ||
                /^data:.*,.*$/i.test(t) ||
                /^blob:.*$/i.test(t))
            ? t
            : e + t;
        }
      };
      let InstancedBufferGeometry = class InstancedBufferGeometry extends BufferGeometry {
        constructor() {
          super(),
            (this.isInstancedBufferGeometry = !0),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(t) {
          return super.copy(t), (this.instanceCount = t.instanceCount), this;
        }
        toJSON() {
          let t = super.toJSON();
          return (
            (t.instanceCount = this.instanceCount),
            (t.isInstancedBufferGeometry = !0),
            t
          );
        }
      };
      let BufferGeometryLoader = class BufferGeometryLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          let s = this,
            n = new FileLoader(s.manager);
          n.setPath(s.path),
            n.setRequestHeader(s.requestHeader),
            n.setWithCredentials(s.withCredentials),
            n.load(
              t,
              function (i) {
                try {
                  e(s.parse(JSON.parse(i)));
                } catch (e) {
                  r ? r(e) : console.error(e), s.manager.itemError(t);
                }
              },
              i,
              r
            );
        }
        parse(t) {
          let e = {},
            i = {};
          function getInterleavedBuffer(t, r) {
            if (void 0 !== e[r]) return e[r];
            let s = t.interleavedBuffers,
              n = s[r],
              a = (function (t, e) {
                if (void 0 !== i[e]) return i[e];
                let r = t.arrayBuffers,
                  s = r[e],
                  n = new Uint32Array(s).buffer;
                return (i[e] = n), n;
              })(t, n.buffer),
              o = getTypedArray(n.type, a),
              h = new InterleavedBuffer(o, n.stride);
            return (h.uuid = n.uuid), (e[r] = h), h;
          }
          let r = t.isInstancedBufferGeometry
              ? new InstancedBufferGeometry()
              : new BufferGeometry(),
            s = t.data.index;
          if (void 0 !== s) {
            let t = getTypedArray(s.type, s.array);
            r.setIndex(new BufferAttribute(t, 1));
          }
          let n = t.data.attributes;
          for (let e in n) {
            let i;
            let s = n[e];
            if (s.isInterleavedBufferAttribute) {
              let e = getInterleavedBuffer(t.data, s.data);
              i = new InterleavedBufferAttribute(
                e,
                s.itemSize,
                s.offset,
                s.normalized
              );
            } else {
              let t = getTypedArray(s.type, s.array),
                e = s.isInstancedBufferAttribute
                  ? InstancedBufferAttribute
                  : BufferAttribute;
              i = new e(t, s.itemSize, s.normalized);
            }
            void 0 !== s.name && (i.name = s.name),
              void 0 !== s.usage && i.setUsage(s.usage),
              r.setAttribute(e, i);
          }
          let a = t.data.morphAttributes;
          if (a)
            for (let e in a) {
              let i = a[e],
                s = [];
              for (let e = 0, r = i.length; e < r; e++) {
                let r;
                let n = i[e];
                if (n.isInterleavedBufferAttribute) {
                  let e = getInterleavedBuffer(t.data, n.data);
                  r = new InterleavedBufferAttribute(
                    e,
                    n.itemSize,
                    n.offset,
                    n.normalized
                  );
                } else {
                  let t = getTypedArray(n.type, n.array);
                  r = new BufferAttribute(t, n.itemSize, n.normalized);
                }
                void 0 !== n.name && (r.name = n.name), s.push(r);
              }
              r.morphAttributes[e] = s;
            }
          let o = t.data.morphTargetsRelative;
          o && (r.morphTargetsRelative = !0);
          let h = t.data.groups || t.data.drawcalls || t.data.offsets;
          if (void 0 !== h)
            for (let t = 0, e = h.length; t !== e; ++t) {
              let e = h[t];
              r.addGroup(e.start, e.count, e.materialIndex);
            }
          let l = t.data.boundingSphere;
          if (void 0 !== l) {
            let t = new Vector3();
            void 0 !== l.center && t.fromArray(l.center),
              (r.boundingSphere = new Sphere(t, l.radius));
          }
          return (
            t.name && (r.name = t.name),
            t.userData && (r.userData = t.userData),
            r
          );
        }
      };
      let ObjectLoader = class ObjectLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          let s = this,
            n = "" === this.path ? LoaderUtils.extractUrlBase(t) : this.path;
          this.resourcePath = this.resourcePath || n;
          let a = new FileLoader(this.manager);
          a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
              t,
              function (i) {
                let n = null;
                try {
                  n = JSON.parse(i);
                } catch (e) {
                  void 0 !== r && r(e),
                    console.error(
                      "THREE:ObjectLoader: Can't parse " + t + ".",
                      e.message
                    );
                  return;
                }
                let a = n.metadata;
                if (
                  void 0 === a ||
                  void 0 === a.type ||
                  "geometry" === a.type.toLowerCase()
                ) {
                  void 0 !== r &&
                    r(Error("THREE.ObjectLoader: Can't load " + t)),
                    console.error("THREE.ObjectLoader: Can't load " + t);
                  return;
                }
                s.parse(n, e);
              },
              i,
              r
            );
        }
        async loadAsync(t, e) {
          let i = "" === this.path ? LoaderUtils.extractUrlBase(t) : this.path;
          this.resourcePath = this.resourcePath || i;
          let r = new FileLoader(this.manager);
          r.setPath(this.path),
            r.setRequestHeader(this.requestHeader),
            r.setWithCredentials(this.withCredentials);
          let s = await r.loadAsync(t, e),
            n = JSON.parse(s),
            a = n.metadata;
          if (
            void 0 === a ||
            void 0 === a.type ||
            "geometry" === a.type.toLowerCase()
          )
            throw Error("THREE.ObjectLoader: Can't load " + t);
          return await this.parseAsync(n);
        }
        parse(t, e) {
          let i = this.parseAnimations(t.animations),
            r = this.parseShapes(t.shapes),
            s = this.parseGeometries(t.geometries, r),
            n = this.parseImages(t.images, function () {
              void 0 !== e && e(h);
            }),
            a = this.parseTextures(t.textures, n),
            o = this.parseMaterials(t.materials, a),
            h = this.parseObject(t.object, s, o, a, i),
            l = this.parseSkeletons(t.skeletons, h);
          if (
            (this.bindSkeletons(h, l), this.bindLightTargets(h), void 0 !== e)
          ) {
            let t = !1;
            for (let e in n)
              if (n[e].data instanceof HTMLImageElement) {
                t = !0;
                break;
              }
            !1 === t && e(h);
          }
          return h;
        }
        async parseAsync(t) {
          let e = this.parseAnimations(t.animations),
            i = this.parseShapes(t.shapes),
            r = this.parseGeometries(t.geometries, i),
            s = await this.parseImagesAsync(t.images),
            n = this.parseTextures(t.textures, s),
            a = this.parseMaterials(t.materials, n),
            o = this.parseObject(t.object, r, a, n, e),
            h = this.parseSkeletons(t.skeletons, o);
          return this.bindSkeletons(o, h), this.bindLightTargets(o), o;
        }
        parseShapes(t) {
          let e = {};
          if (void 0 !== t)
            for (let i = 0, r = t.length; i < r; i++) {
              let r = new Shape().fromJSON(t[i]);
              e[r.uuid] = r;
            }
          return e;
        }
        parseSkeletons(t, e) {
          let i = {},
            r = {};
          if (
            (e.traverse(function (t) {
              t.isBone && (r[t.uuid] = t);
            }),
            void 0 !== t)
          )
            for (let e = 0, s = t.length; e < s; e++) {
              let s = new Skeleton().fromJSON(t[e], r);
              i[s.uuid] = s;
            }
          return i;
        }
        parseGeometries(t, e) {
          let i = {};
          if (void 0 !== t) {
            let r = new BufferGeometryLoader();
            for (let s = 0, n = t.length; s < n; s++) {
              let n;
              let a = t[s];
              switch (a.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  n = r.parse(a);
                  break;
                default:
                  a.type in nf
                    ? (n = nf[a.type].fromJSON(a, e))
                    : console.warn(
                        `THREE.ObjectLoader: Unsupported geometry type "${a.type}"`
                      );
              }
              (n.uuid = a.uuid),
                void 0 !== a.name && (n.name = a.name),
                void 0 !== a.userData && (n.userData = a.userData),
                (i[a.uuid] = n);
            }
          }
          return i;
        }
        parseMaterials(t, e) {
          let i = {},
            r = {};
          if (void 0 !== t) {
            let s = new MaterialLoader();
            s.setTextures(e);
            for (let e = 0, n = t.length; e < n; e++) {
              let n = t[e];
              void 0 === i[n.uuid] && (i[n.uuid] = s.parse(n)),
                (r[n.uuid] = i[n.uuid]);
            }
          }
          return r;
        }
        parseAnimations(t) {
          let e = {};
          if (void 0 !== t)
            for (let i = 0; i < t.length; i++) {
              let r = t[i],
                s = AnimationClip.parse(r);
              e[s.uuid] = s;
            }
          return e;
        }
        parseImages(t, e) {
          let i;
          let r = this,
            s = {};
          function deserializeImage(t) {
            if ("string" == typeof t) {
              let e = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)
                ? t
                : r.resourcePath + t;
              return (
                r.manager.itemStart(e),
                i.load(
                  e,
                  function () {
                    r.manager.itemEnd(e);
                  },
                  void 0,
                  function () {
                    r.manager.itemError(e), r.manager.itemEnd(e);
                  }
                )
              );
            }
            return t.data
              ? {
                  data: getTypedArray(t.type, t.data),
                  width: t.width,
                  height: t.height,
                }
              : null;
          }
          if (void 0 !== t && t.length > 0) {
            let r = new LoadingManager(e);
            (i = new ImageLoader(r)).setCrossOrigin(this.crossOrigin);
            for (let e = 0, i = t.length; e < i; e++) {
              let i = t[e],
                r = i.url;
              if (Array.isArray(r)) {
                let t = [];
                for (let e = 0, i = r.length; e < i; e++) {
                  let i = r[e],
                    s = deserializeImage(i);
                  null !== s &&
                    (s instanceof HTMLImageElement
                      ? t.push(s)
                      : t.push(new DataTexture(s.data, s.width, s.height)));
                }
                s[i.uuid] = new Source(t);
              } else {
                let t = deserializeImage(i.url);
                s[i.uuid] = new Source(t);
              }
            }
          }
          return s;
        }
        async parseImagesAsync(t) {
          let e;
          let i = this,
            r = {};
          async function deserializeImage(t) {
            if ("string" == typeof t) {
              let r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)
                ? t
                : i.resourcePath + t;
              return await e.loadAsync(r);
            }
            return t.data
              ? {
                  data: getTypedArray(t.type, t.data),
                  width: t.width,
                  height: t.height,
                }
              : null;
          }
          if (void 0 !== t && t.length > 0) {
            (e = new ImageLoader(this.manager)).setCrossOrigin(
              this.crossOrigin
            );
            for (let e = 0, i = t.length; e < i; e++) {
              let i = t[e],
                s = i.url;
              if (Array.isArray(s)) {
                let t = [];
                for (let e = 0, i = s.length; e < i; e++) {
                  let i = s[e],
                    r = await deserializeImage(i);
                  null !== r &&
                    (r instanceof HTMLImageElement
                      ? t.push(r)
                      : t.push(new DataTexture(r.data, r.width, r.height)));
                }
                r[i.uuid] = new Source(t);
              } else {
                let t = await deserializeImage(i.url);
                r[i.uuid] = new Source(t);
              }
            }
          }
          return r;
        }
        parseTextures(t, e) {
          function parseConstant(t, e) {
            return "number" == typeof t
              ? t
              : (console.warn(
                  "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                  t
                ),
                e[t]);
          }
          let i = {};
          if (void 0 !== t)
            for (let r = 0, s = t.length; r < s; r++) {
              let s;
              let n = t[r];
              void 0 === n.image &&
                console.warn(
                  'THREE.ObjectLoader: No "image" specified for',
                  n.uuid
                ),
                void 0 === e[n.image] &&
                  console.warn("THREE.ObjectLoader: Undefined image", n.image);
              let a = e[n.image],
                o = a.data;
              Array.isArray(o)
                ? ((s = new CubeTexture()),
                  6 === o.length && (s.needsUpdate = !0))
                : ((s = o && o.data ? new DataTexture() : new Texture()),
                  o && (s.needsUpdate = !0)),
                (s.source = a),
                (s.uuid = n.uuid),
                void 0 !== n.name && (s.name = n.name),
                void 0 !== n.mapping &&
                  (s.mapping = parseConstant(n.mapping, nT)),
                void 0 !== n.channel && (s.channel = n.channel),
                void 0 !== n.offset && s.offset.fromArray(n.offset),
                void 0 !== n.repeat && s.repeat.fromArray(n.repeat),
                void 0 !== n.center && s.center.fromArray(n.center),
                void 0 !== n.rotation && (s.rotation = n.rotation),
                void 0 !== n.wrap &&
                  ((s.wrapS = parseConstant(n.wrap[0], nC)),
                  (s.wrapT = parseConstant(n.wrap[1], nC))),
                void 0 !== n.format && (s.format = n.format),
                void 0 !== n.internalFormat &&
                  (s.internalFormat = n.internalFormat),
                void 0 !== n.type && (s.type = n.type),
                void 0 !== n.colorSpace && (s.colorSpace = n.colorSpace),
                void 0 !== n.minFilter &&
                  (s.minFilter = parseConstant(n.minFilter, nz)),
                void 0 !== n.magFilter &&
                  (s.magFilter = parseConstant(n.magFilter, nz)),
                void 0 !== n.anisotropy && (s.anisotropy = n.anisotropy),
                void 0 !== n.flipY && (s.flipY = n.flipY),
                void 0 !== n.generateMipmaps &&
                  (s.generateMipmaps = n.generateMipmaps),
                void 0 !== n.premultiplyAlpha &&
                  (s.premultiplyAlpha = n.premultiplyAlpha),
                void 0 !== n.unpackAlignment &&
                  (s.unpackAlignment = n.unpackAlignment),
                void 0 !== n.compareFunction &&
                  (s.compareFunction = n.compareFunction),
                void 0 !== n.userData && (s.userData = n.userData),
                (i[n.uuid] = s);
            }
          return i;
        }
        parseObject(t, e, i, r, s) {
          let n, a, o;
          function getGeometry(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.ObjectLoader: Undefined geometry", t),
              e[t]
            );
          }
          function getMaterial(t) {
            if (void 0 !== t) {
              if (Array.isArray(t)) {
                let e = [];
                for (let r = 0, s = t.length; r < s; r++) {
                  let s = t[r];
                  void 0 === i[s] &&
                    console.warn("THREE.ObjectLoader: Undefined material", s),
                    e.push(i[s]);
                }
                return e;
              }
              return (
                void 0 === i[t] &&
                  console.warn("THREE.ObjectLoader: Undefined material", t),
                i[t]
              );
            }
          }
          function getTexture(t) {
            return (
              void 0 === r[t] &&
                console.warn("THREE.ObjectLoader: Undefined texture", t),
              r[t]
            );
          }
          switch (t.type) {
            case "Scene":
              (n = new Scene()),
                void 0 !== t.background &&
                  (Number.isInteger(t.background)
                    ? (n.background = new Color(t.background))
                    : (n.background = getTexture(t.background))),
                void 0 !== t.environment &&
                  (n.environment = getTexture(t.environment)),
                void 0 !== t.fog &&
                  ("Fog" === t.fog.type
                    ? (n.fog = new Fog(t.fog.color, t.fog.near, t.fog.far))
                    : "FogExp2" === t.fog.type &&
                      (n.fog = new FogExp2(t.fog.color, t.fog.density)),
                  "" !== t.fog.name && (n.fog.name = t.fog.name)),
                void 0 !== t.backgroundBlurriness &&
                  (n.backgroundBlurriness = t.backgroundBlurriness),
                void 0 !== t.backgroundIntensity &&
                  (n.backgroundIntensity = t.backgroundIntensity),
                void 0 !== t.backgroundRotation &&
                  n.backgroundRotation.fromArray(t.backgroundRotation),
                void 0 !== t.environmentIntensity &&
                  (n.environmentIntensity = t.environmentIntensity),
                void 0 !== t.environmentRotation &&
                  n.environmentRotation.fromArray(t.environmentRotation);
              break;
            case "PerspectiveCamera":
              (n = new PerspectiveCamera(t.fov, t.aspect, t.near, t.far)),
                void 0 !== t.focus && (n.focus = t.focus),
                void 0 !== t.zoom && (n.zoom = t.zoom),
                void 0 !== t.filmGauge && (n.filmGauge = t.filmGauge),
                void 0 !== t.filmOffset && (n.filmOffset = t.filmOffset),
                void 0 !== t.view && (n.view = Object.assign({}, t.view));
              break;
            case "OrthographicCamera":
              (n = new OrthographicCamera(
                t.left,
                t.right,
                t.top,
                t.bottom,
                t.near,
                t.far
              )),
                void 0 !== t.zoom && (n.zoom = t.zoom),
                void 0 !== t.view && (n.view = Object.assign({}, t.view));
              break;
            case "AmbientLight":
              n = new AmbientLight(t.color, t.intensity);
              break;
            case "DirectionalLight":
              (n = new DirectionalLight(t.color, t.intensity)).target =
                t.target || "";
              break;
            case "PointLight":
              n = new PointLight(t.color, t.intensity, t.distance, t.decay);
              break;
            case "RectAreaLight":
              n = new RectAreaLight(t.color, t.intensity, t.width, t.height);
              break;
            case "SpotLight":
              (n = new SpotLight(
                t.color,
                t.intensity,
                t.distance,
                t.angle,
                t.penumbra,
                t.decay
              )).target = t.target || "";
              break;
            case "HemisphereLight":
              n = new HemisphereLight(t.color, t.groundColor, t.intensity);
              break;
            case "LightProbe":
              n = new LightProbe().fromJSON(t);
              break;
            case "SkinnedMesh":
              (a = getGeometry(t.geometry)),
                (o = getMaterial(t.material)),
                (n = new SkinnedMesh(a, o)),
                void 0 !== t.bindMode && (n.bindMode = t.bindMode),
                void 0 !== t.bindMatrix && n.bindMatrix.fromArray(t.bindMatrix),
                void 0 !== t.skeleton && (n.skeleton = t.skeleton);
              break;
            case "Mesh":
              (a = getGeometry(t.geometry)),
                (o = getMaterial(t.material)),
                (n = new Mesh(a, o));
              break;
            case "InstancedMesh":
              (a = getGeometry(t.geometry)), (o = getMaterial(t.material));
              let h = t.count,
                l = t.instanceMatrix,
                u = t.instanceColor;
              ((n = new InstancedMesh(a, o, h)).instanceMatrix =
                new InstancedBufferAttribute(new Float32Array(l.array), 16)),
                void 0 !== u &&
                  (n.instanceColor = new InstancedBufferAttribute(
                    new Float32Array(u.array),
                    u.itemSize
                  ));
              break;
            case "BatchedMesh":
              (a = getGeometry(t.geometry)),
                (o = getMaterial(t.material)),
                ((n = new BatchedMesh(
                  t.maxInstanceCount,
                  t.maxVertexCount,
                  t.maxIndexCount,
                  o
                )).geometry = a),
                (n.perObjectFrustumCulled = t.perObjectFrustumCulled),
                (n.sortObjects = t.sortObjects),
                (n._drawRanges = t.drawRanges),
                (n._reservedRanges = t.reservedRanges),
                (n._visibility = t.visibility),
                (n._active = t.active),
                (n._bounds = t.bounds.map((t) => {
                  let e = new Box3();
                  e.min.fromArray(t.boxMin), e.max.fromArray(t.boxMax);
                  let i = new Sphere();
                  return (
                    (i.radius = t.sphereRadius),
                    i.center.fromArray(t.sphereCenter),
                    {
                      boxInitialized: t.boxInitialized,
                      box: e,
                      sphereInitialized: t.sphereInitialized,
                      sphere: i,
                    }
                  );
                })),
                (n._maxInstanceCount = t.maxInstanceCount),
                (n._maxVertexCount = t.maxVertexCount),
                (n._maxIndexCount = t.maxIndexCount),
                (n._geometryInitialized = t.geometryInitialized),
                (n._geometryCount = t.geometryCount),
                (n._matricesTexture = getTexture(t.matricesTexture.uuid)),
                void 0 !== t.colorsTexture &&
                  (n._colorsTexture = getTexture(t.colorsTexture.uuid));
              break;
            case "LOD":
              n = new LOD();
              break;
            case "Line":
              n = new Line(getGeometry(t.geometry), getMaterial(t.material));
              break;
            case "LineLoop":
              n = new LineLoop(
                getGeometry(t.geometry),
                getMaterial(t.material)
              );
              break;
            case "LineSegments":
              n = new LineSegments(
                getGeometry(t.geometry),
                getMaterial(t.material)
              );
              break;
            case "PointCloud":
            case "Points":
              n = new Points(getGeometry(t.geometry), getMaterial(t.material));
              break;
            case "Sprite":
              n = new Sprite(getMaterial(t.material));
              break;
            case "Group":
              n = new Group();
              break;
            case "Bone":
              n = new Bone();
              break;
            default:
              n = new Object3D();
          }
          if (
            ((n.uuid = t.uuid),
            void 0 !== t.name && (n.name = t.name),
            void 0 !== t.matrix
              ? (n.matrix.fromArray(t.matrix),
                void 0 !== t.matrixAutoUpdate &&
                  (n.matrixAutoUpdate = t.matrixAutoUpdate),
                n.matrixAutoUpdate &&
                  n.matrix.decompose(n.position, n.quaternion, n.scale))
              : (void 0 !== t.position && n.position.fromArray(t.position),
                void 0 !== t.rotation && n.rotation.fromArray(t.rotation),
                void 0 !== t.quaternion && n.quaternion.fromArray(t.quaternion),
                void 0 !== t.scale && n.scale.fromArray(t.scale)),
            void 0 !== t.up && n.up.fromArray(t.up),
            void 0 !== t.castShadow && (n.castShadow = t.castShadow),
            void 0 !== t.receiveShadow && (n.receiveShadow = t.receiveShadow),
            t.shadow &&
              (void 0 !== t.shadow.intensity &&
                (n.shadow.intensity = t.shadow.intensity),
              void 0 !== t.shadow.bias && (n.shadow.bias = t.shadow.bias),
              void 0 !== t.shadow.normalBias &&
                (n.shadow.normalBias = t.shadow.normalBias),
              void 0 !== t.shadow.radius && (n.shadow.radius = t.shadow.radius),
              void 0 !== t.shadow.mapSize &&
                n.shadow.mapSize.fromArray(t.shadow.mapSize),
              void 0 !== t.shadow.camera &&
                (n.shadow.camera = this.parseObject(t.shadow.camera))),
            void 0 !== t.visible && (n.visible = t.visible),
            void 0 !== t.frustumCulled && (n.frustumCulled = t.frustumCulled),
            void 0 !== t.renderOrder && (n.renderOrder = t.renderOrder),
            void 0 !== t.userData && (n.userData = t.userData),
            void 0 !== t.layers && (n.layers.mask = t.layers),
            void 0 !== t.children)
          ) {
            let a = t.children;
            for (let t = 0; t < a.length; t++)
              n.add(this.parseObject(a[t], e, i, r, s));
          }
          if (void 0 !== t.animations) {
            let e = t.animations;
            for (let t = 0; t < e.length; t++) {
              let i = e[t];
              n.animations.push(s[i]);
            }
          }
          if ("LOD" === t.type) {
            void 0 !== t.autoUpdate && (n.autoUpdate = t.autoUpdate);
            let e = t.levels;
            for (let t = 0; t < e.length; t++) {
              let i = e[t],
                r = n.getObjectByProperty("uuid", i.object);
              void 0 !== r && n.addLevel(r, i.distance, i.hysteresis);
            }
          }
          return n;
        }
        bindSkeletons(t, e) {
          0 !== Object.keys(e).length &&
            t.traverse(function (t) {
              if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                let i = e[t.skeleton];
                void 0 === i
                  ? console.warn(
                      "THREE.ObjectLoader: No skeleton found with UUID:",
                      t.skeleton
                    )
                  : t.bind(i, t.bindMatrix);
              }
            });
        }
        bindLightTargets(t) {
          t.traverse(function (e) {
            if (e.isDirectionalLight || e.isSpotLight) {
              let i = e.target,
                r = t.getObjectByProperty("uuid", i);
              void 0 !== r ? (e.target = r) : (e.target = new Object3D());
            }
          });
        }
      };
      let nT = {
          UVMapping: ty,
          CubeReflectionMapping: tg,
          CubeRefractionMapping: tx,
          EquirectangularReflectionMapping: tb,
          EquirectangularRefractionMapping: tv,
          CubeUVReflectionMapping: tM,
        },
        nC = {
          RepeatWrapping: tw,
          ClampToEdgeWrapping: tS,
          MirroredRepeatWrapping: tA,
        },
        nz = {
          NearestFilter: t_,
          NearestMipmapNearestFilter: tT,
          NearestMipmapLinearFilter: tz,
          LinearFilter: tI,
          LinearMipmapNearestFilter: tV,
          LinearMipmapLinearFilter: tL,
        };
      let ImageBitmapLoader = class ImageBitmapLoader extends Loader {
        constructor(t) {
          super(t),
            (this.isImageBitmapLoader = !0),
            "undefined" == typeof createImageBitmap &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            "undefined" == typeof fetch &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(t) {
          return (this.options = t), this;
        }
        load(t, e, i, r) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          let s = this,
            n = ng.get(t);
          if (void 0 !== n) {
            if ((s.manager.itemStart(t), n.then)) {
              n.then((i) => {
                e && e(i), s.manager.itemEnd(t);
              }).catch((t) => {
                r && r(t);
              });
              return;
            }
            return (
              setTimeout(function () {
                e && e(n), s.manager.itemEnd(t);
              }, 0),
              n
            );
          }
          let a = {};
          (a.credentials =
            "anonymous" === this.crossOrigin ? "same-origin" : "include"),
            (a.headers = this.requestHeader);
          let o = fetch(t, a)
            .then(function (t) {
              return t.blob();
            })
            .then(function (t) {
              return createImageBitmap(
                t,
                Object.assign(s.options, { colorSpaceConversion: "none" })
              );
            })
            .then(function (i) {
              return ng.add(t, i), e && e(i), s.manager.itemEnd(t), i;
            })
            .catch(function (e) {
              r && r(e),
                ng.remove(t),
                s.manager.itemError(t),
                s.manager.itemEnd(t);
            });
          ng.add(t, o), s.manager.itemStart(t);
        }
      };
      let AudioContext = class AudioContext {
        static getContext() {
          return (
            void 0 === n &&
              (n = new (window.AudioContext || window.webkitAudioContext)()),
            n
          );
        }
        static setContext(t) {
          n = t;
        }
      };
      let AudioLoader = class AudioLoader extends Loader {
        constructor(t) {
          super(t);
        }
        load(t, e, i, r) {
          let s = this,
            n = new FileLoader(this.manager);
          function handleError(e) {
            r ? r(e) : console.error(e), s.manager.itemError(t);
          }
          n.setResponseType("arraybuffer"),
            n.setPath(this.path),
            n.setRequestHeader(this.requestHeader),
            n.setWithCredentials(this.withCredentials),
            n.load(
              t,
              function (t) {
                try {
                  let i = t.slice(0),
                    r = AudioContext.getContext();
                  r.decodeAudioData(i, function (t) {
                    e(t);
                  }).catch(handleError);
                } catch (t) {
                  handleError(t);
                }
              },
              i,
              r
            );
        }
      };
      let nB = new Matrix4(),
        nI = new Matrix4(),
        nV = new Matrix4();
      let StereoCamera = class StereoCamera {
        constructor() {
          (this.type = "StereoCamera"),
            (this.aspect = 1),
            (this.eyeSep = 0.064),
            (this.cameraL = new PerspectiveCamera()),
            this.cameraL.layers.enable(1),
            (this.cameraL.matrixAutoUpdate = !1),
            (this.cameraR = new PerspectiveCamera()),
            this.cameraR.layers.enable(2),
            (this.cameraR.matrixAutoUpdate = !1),
            (this._cache = {
              focus: null,
              fov: null,
              aspect: null,
              near: null,
              far: null,
              zoom: null,
              eyeSep: null,
            });
        }
        update(t) {
          let e = this._cache,
            i =
              e.focus !== t.focus ||
              e.fov !== t.fov ||
              e.aspect !== t.aspect * this.aspect ||
              e.near !== t.near ||
              e.far !== t.far ||
              e.zoom !== t.zoom ||
              e.eyeSep !== this.eyeSep;
          if (i) {
            let i, r;
            (e.focus = t.focus),
              (e.fov = t.fov),
              (e.aspect = t.aspect * this.aspect),
              (e.near = t.near),
              (e.far = t.far),
              (e.zoom = t.zoom),
              (e.eyeSep = this.eyeSep),
              nV.copy(t.projectionMatrix);
            let s = e.eyeSep / 2,
              n = (s * e.near) / e.focus,
              a = (e.near * Math.tan(iI * e.fov * 0.5)) / e.zoom;
            (nI.elements[12] = -s),
              (nB.elements[12] = s),
              (i = -a * e.aspect + n),
              (r = a * e.aspect + n),
              (nV.elements[0] = (2 * e.near) / (r - i)),
              (nV.elements[8] = (r + i) / (r - i)),
              this.cameraL.projectionMatrix.copy(nV),
              (i = -a * e.aspect - n),
              (r = a * e.aspect - n),
              (nV.elements[0] = (2 * e.near) / (r - i)),
              (nV.elements[8] = (r + i) / (r - i)),
              this.cameraR.projectionMatrix.copy(nV);
          }
          this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(nI),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(nB);
        }
      };
      let ArrayCamera = class ArrayCamera extends PerspectiveCamera {
        constructor(t = []) {
          super(), (this.isArrayCamera = !0), (this.cameras = t);
        }
      };
      let Clock = class Clock {
        constructor(t = !0) {
          (this.autoStart = t),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = now()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            let e = now();
            (t = (e - this.oldTime) / 1e3),
              (this.oldTime = e),
              (this.elapsedTime += t);
          }
          return t;
        }
      };
      function now() {
        return performance.now();
      }
      let nP = new Vector3(),
        nL = new Quaternion(),
        nk = new Vector3(),
        nR = new Vector3();
      let AudioListener = class AudioListener extends Object3D {
        constructor() {
          super(),
            (this.type = "AudioListener"),
            (this.context = AudioContext.getContext()),
            (this.gain = this.context.createGain()),
            this.gain.connect(this.context.destination),
            (this.filter = null),
            (this.timeDelta = 0),
            (this._clock = new Clock());
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return (
            null !== this.filter &&
              (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination),
              this.gain.connect(this.context.destination),
              (this.filter = null)),
            this
          );
        }
        getFilter() {
          return this.filter;
        }
        setFilter(t) {
          return (
            null !== this.filter
              ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination))
              : this.gain.disconnect(this.context.destination),
            (this.filter = t),
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
          );
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t);
          let e = this.context.listener,
            i = this.up;
          if (
            ((this.timeDelta = this._clock.getDelta()),
            this.matrixWorld.decompose(nP, nL, nk),
            nR.set(0, 0, -1).applyQuaternion(nL),
            e.positionX)
          ) {
            let t = this.context.currentTime + this.timeDelta;
            e.positionX.linearRampToValueAtTime(nP.x, t),
              e.positionY.linearRampToValueAtTime(nP.y, t),
              e.positionZ.linearRampToValueAtTime(nP.z, t),
              e.forwardX.linearRampToValueAtTime(nR.x, t),
              e.forwardY.linearRampToValueAtTime(nR.y, t),
              e.forwardZ.linearRampToValueAtTime(nR.z, t),
              e.upX.linearRampToValueAtTime(i.x, t),
              e.upY.linearRampToValueAtTime(i.y, t),
              e.upZ.linearRampToValueAtTime(i.z, t);
          } else
            e.setPosition(nP.x, nP.y, nP.z),
              e.setOrientation(nR.x, nR.y, nR.z, i.x, i.y, i.z);
        }
      };
      let Audio = class Audio extends Object3D {
        constructor(t) {
          super(),
            (this.type = "Audio"),
            (this.listener = t),
            (this.context = t.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(t.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = t),
            this.connect(),
            this
          );
        }
        setMediaElementSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(t)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(t)),
            this.connect(),
            this
          );
        }
        setBuffer(t) {
          return (
            (this.buffer = t),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(t = 0) {
          if (!0 === this.isPlaying) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (!1 === this.hasPlaybackControl) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + t;
          let e = this.context.createBufferSource();
          return (
            (e.buffer = this.buffer),
            (e.loop = this.loop),
            (e.loopStart = this.loopStart),
            (e.loopEnd = this.loopEnd),
            (e.onended = this.onEnded.bind(this)),
            e.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = e),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (!1 === this.hasPlaybackControl) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            !0 === this.isPlaying &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              !0 === this.loop &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        }
        stop(t = 0) {
          if (!1 === this.hasPlaybackControl) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this._progress = 0),
            null !== this.source &&
              (this.source.stop(this.context.currentTime + t),
              (this.source.onended = null)),
            (this.isPlaying = !1),
            this
          );
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (!1 !== this._connected) {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].disconnect(this.filters[t]);
              this.filters[this.filters.length - 1].disconnect(
                this.getOutput()
              );
            } else this.source.disconnect(this.getOutput());
            return (this._connected = !1), this;
          }
        }
        getFilters() {
          return this.filters;
        }
        setFilters(t) {
          return (
            t || (t = []),
            !0 === this._connected
              ? (this.disconnect(), (this.filters = t.slice()), this.connect())
              : (this.filters = t.slice()),
            this
          );
        }
        setDetune(t) {
          return (
            (this.detune = t),
            !0 === this.isPlaying &&
              void 0 !== this.source.detune &&
              this.source.detune.setTargetAtTime(
                this.detune,
                this.context.currentTime,
                0.01
              ),
            this
          );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(t) {
          return this.setFilters(t ? [t] : []);
        }
        setPlaybackRate(t) {
          if (!1 === this.hasPlaybackControl) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.playbackRate = t),
            !0 === this.isPlaying &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          (this.isPlaying = !1), (this._progress = 0);
        }
        getLoop() {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(t) {
          if (!1 === this.hasPlaybackControl) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return (
            (this.loop = t),
            !0 === this.isPlaying && (this.source.loop = this.loop),
            this
          );
        }
        setLoopStart(t) {
          return (this.loopStart = t), this;
        }
        setLoopEnd(t) {
          return (this.loopEnd = t), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        }
        copy(t, e) {
          return (
            (super.copy(t, e), "buffer" !== t.sourceType)
              ? console.warn("THREE.Audio: Audio source type cannot be copied.")
              : ((this.autoplay = t.autoplay),
                (this.buffer = t.buffer),
                (this.detune = t.detune),
                (this.loop = t.loop),
                (this.loopStart = t.loopStart),
                (this.loopEnd = t.loopEnd),
                (this.offset = t.offset),
                (this.duration = t.duration),
                (this.playbackRate = t.playbackRate),
                (this.hasPlaybackControl = t.hasPlaybackControl),
                (this.sourceType = t.sourceType),
                (this.filters = t.filters.slice())),
            this
          );
        }
        clone(t) {
          return new this.constructor(this.listener).copy(this, t);
        }
      };
      let nE = new Vector3(),
        nO = new Quaternion(),
        nF = new Vector3(),
        nN = new Vector3();
      let PositionalAudio = class PositionalAudio extends Audio {
        constructor(t) {
          super(t),
            (this.panner = this.context.createPanner()),
            (this.panner.panningModel = "HRTF"),
            this.panner.connect(this.gain);
        }
        connect() {
          super.connect(), this.panner.connect(this.gain);
        }
        disconnect() {
          super.disconnect(), this.panner.disconnect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(t) {
          return (this.panner.refDistance = t), this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(t) {
          return (this.panner.rolloffFactor = t), this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(t) {
          return (this.panner.distanceModel = t), this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(t) {
          return (this.panner.maxDistance = t), this;
        }
        setDirectionalCone(t, e, i) {
          return (
            (this.panner.coneInnerAngle = t),
            (this.panner.coneOuterAngle = e),
            (this.panner.coneOuterGain = i),
            this
          );
        }
        updateMatrixWorld(t) {
          if (
            (super.updateMatrixWorld(t),
            !0 === this.hasPlaybackControl && !1 === this.isPlaying)
          )
            return;
          this.matrixWorld.decompose(nE, nO, nF),
            nN.set(0, 0, 1).applyQuaternion(nO);
          let e = this.panner;
          if (e.positionX) {
            let t = this.context.currentTime + this.listener.timeDelta;
            e.positionX.linearRampToValueAtTime(nE.x, t),
              e.positionY.linearRampToValueAtTime(nE.y, t),
              e.positionZ.linearRampToValueAtTime(nE.z, t),
              e.orientationX.linearRampToValueAtTime(nN.x, t),
              e.orientationY.linearRampToValueAtTime(nN.y, t),
              e.orientationZ.linearRampToValueAtTime(nN.z, t);
          } else
            e.setPosition(nE.x, nE.y, nE.z), e.setOrientation(nN.x, nN.y, nN.z);
        }
      };
      let AudioAnalyser = class AudioAnalyser {
        constructor(t, e = 2048) {
          (this.analyser = t.context.createAnalyser()),
            (this.analyser.fftSize = e),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            t.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let t = 0,
            e = this.getFrequencyData();
          for (let i = 0; i < e.length; i++) t += e[i];
          return t / e.length;
        }
      };
      let PropertyMixer = class PropertyMixer {
        constructor(t, e, i) {
          let r, s, n;
          switch (((this.binding = t), (this.valueSize = i), e)) {
            case "quaternion":
              (r = this._slerp),
                (s = this._slerpAdditive),
                (n = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * i)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (r = this._select),
                (s = this._select),
                (n = this._setAdditiveIdentityOther),
                (this.buffer = Array(5 * i));
              break;
            default:
              (r = this._lerp),
                (s = this._lerpAdditive),
                (n = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * i));
          }
          (this._mixBufferRegion = r),
            (this._mixBufferRegionAdditive = s),
            (this._setIdentity = n),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(t, e) {
          let i = this.buffer,
            r = this.valueSize,
            s = t * r + r,
            n = this.cumulativeWeight;
          if (0 === n) {
            for (let t = 0; t !== r; ++t) i[s + t] = i[t];
            n = e;
          } else {
            n += e;
            let t = e / n;
            this._mixBufferRegion(i, s, 0, t, r);
          }
          this.cumulativeWeight = n;
        }
        accumulateAdditive(t) {
          let e = this.buffer,
            i = this.valueSize,
            r = i * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, r, 0, t, i),
            (this.cumulativeWeightAdditive += t);
        }
        apply(t) {
          let e = this.valueSize,
            i = this.buffer,
            r = t * e + e,
            s = this.cumulativeWeight,
            n = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            s < 1)
          ) {
            let t = e * this._origIndex;
            this._mixBufferRegion(i, r, t, 1 - s, e);
          }
          n > 0 &&
            this._mixBufferRegionAdditive(i, r, this._addIndex * e, 1, e);
          for (let t = e, s = e + e; t !== s; ++t)
            if (i[t] !== i[t + e]) {
              a.setValue(i, r);
              break;
            }
        }
        saveOriginalState() {
          let t = this.binding,
            e = this.buffer,
            i = this.valueSize,
            r = i * this._origIndex;
          t.getValue(e, r);
          for (let t = i; t !== r; ++t) e[t] = e[r + (t % i)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          let t = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t);
        }
        _setAdditiveIdentityNumeric() {
          let t = this._addIndex * this.valueSize,
            e = t + this.valueSize;
          for (let i = t; i < e; i++) this.buffer[i] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          let t = this._origIndex * this.valueSize,
            e = this._addIndex * this.valueSize;
          for (let i = 0; i < this.valueSize; i++)
            this.buffer[e + i] = this.buffer[t + i];
        }
        _select(t, e, i, r, s) {
          if (r >= 0.5) for (let r = 0; r !== s; ++r) t[e + r] = t[i + r];
        }
        _slerp(t, e, i, r) {
          Quaternion.slerpFlat(t, e, t, e, t, i, r);
        }
        _slerpAdditive(t, e, i, r, s) {
          let n = this._workIndex * s;
          Quaternion.multiplyQuaternionsFlat(t, n, t, e, t, i),
            Quaternion.slerpFlat(t, e, t, e, t, n, r);
        }
        _lerp(t, e, i, r, s) {
          let n = 1 - r;
          for (let a = 0; a !== s; ++a) {
            let s = e + a;
            t[s] = t[s] * n + t[i + a] * r;
          }
        }
        _lerpAdditive(t, e, i, r, s) {
          for (let n = 0; n !== s; ++n) {
            let s = e + n;
            t[s] = t[s] + t[i + n] * r;
          }
        }
      };
      let nD = "\\[\\]\\.:\\/",
        nU = RegExp("[" + nD + "]", "g"),
        nG = "[^" + nD + "]",
        nj = "[^" + nD.replace("\\.", "") + "]",
        nW = /((?:WC+[\/:])*)/.source.replace("WC", nG),
        nH = /(WCOD+)?/.source.replace("WCOD", nj),
        nq = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", nG),
        nJ = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", nG),
        nZ = RegExp("^" + nW + nH + nq + nJ + "$"),
        nX = ["material", "materials", "bones", "map"];
      let PropertyBinding = class PropertyBinding {
        constructor(t, e, i) {
          (this.path = e),
            (this.parsedPath = i || PropertyBinding.parseTrackName(e)),
            (this.node = PropertyBinding.findNode(t, this.parsedPath.nodeName)),
            (this.rootNode = t),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(t, e, i) {
          return t && t.isAnimationObjectGroup
            ? new PropertyBinding.Composite(t, e, i)
            : new PropertyBinding(t, e, i);
        }
        static sanitizeNodeName(t) {
          return t.replace(/\s/g, "_").replace(nU, "");
        }
        static parseTrackName(t) {
          let e = nZ.exec(t);
          if (null === e)
            throw Error("PropertyBinding: Cannot parse trackName: " + t);
          let i = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
            r = i.nodeName && i.nodeName.lastIndexOf(".");
          if (void 0 !== r && -1 !== r) {
            let t = i.nodeName.substring(r + 1);
            -1 !== nX.indexOf(t) &&
              ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = t));
          }
          if (null === i.propertyName || 0 === i.propertyName.length)
            throw Error(
              "PropertyBinding: can not parse propertyName from trackName: " + t
            );
          return i;
        }
        static findNode(t, e) {
          if (
            void 0 === e ||
            "" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            let i = t.skeleton.getBoneByName(e);
            if (void 0 !== i) return i;
          }
          if (t.children) {
            let searchNodeSubtree = function (t) {
                for (let i = 0; i < t.length; i++) {
                  let r = t[i];
                  if (r.name === e || r.uuid === e) return r;
                  let s = searchNodeSubtree(r.children);
                  if (s) return s;
                }
                return null;
              },
              i = searchNodeSubtree(t.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
          t[e] = this.targetObject[this.propertyName];
        }
        _getValue_array(t, e) {
          let i = this.resolvedProperty;
          for (let r = 0, s = i.length; r !== s; ++r) t[e++] = i[r];
        }
        _getValue_arrayElement(t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t, e) {
          this.resolvedProperty.toArray(t, e);
        }
        _setValue_direct(t, e) {
          this.targetObject[this.propertyName] = t[e];
        }
        _setValue_direct_setNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(t, e) {
          let i = this.resolvedProperty;
          for (let r = 0, s = i.length; r !== s; ++r) i[r] = t[e++];
        }
        _setValue_array_setNeedsUpdate(t, e) {
          let i = this.resolvedProperty;
          for (let r = 0, s = i.length; r !== s; ++r) i[r] = t[e++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
          let i = this.resolvedProperty;
          for (let r = 0, s = i.length; r !== s; ++r) i[r] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(t, e) {
          this.resolvedProperty.fromArray(t, e);
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(t, e) {
          this.bind(), this.getValue(t, e);
        }
        _setValue_unbound(t, e) {
          this.bind(), this.setValue(t, e);
        }
        bind() {
          let t = this.node,
            e = this.parsedPath,
            i = e.objectName,
            r = e.propertyName,
            s = e.propertyIndex;
          if (
            (t ||
              ((t = PropertyBinding.findNode(this.rootNode, e.nodeName)),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !t)
          ) {
            console.warn(
              "THREE.PropertyBinding: No target node found for track: " +
                this.path +
                "."
            );
            return;
          }
          if (i) {
            let r = e.objectIndex;
            switch (i) {
              case "materials":
                if (!t.material) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                  return;
                }
                if (!t.material.materials) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                  return;
                }
                t = t.material.materials;
                break;
              case "bones":
                if (!t.skeleton) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                  return;
                }
                t = t.skeleton.bones;
                for (let e = 0; e < t.length; e++)
                  if (t[e].name === r) {
                    r = e;
                    break;
                  }
                break;
              case "map":
                if ("map" in t) {
                  t = t.map;
                  break;
                }
                if (!t.material) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                  return;
                }
                if (!t.material.map) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                    this
                  );
                  return;
                }
                t = t.material.map;
                break;
              default:
                if (void 0 === t[i]) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                  return;
                }
                t = t[i];
            }
            if (void 0 !== r) {
              if (void 0 === t[r]) {
                console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  t
                );
                return;
              }
              t = t[r];
            }
          }
          let n = t[r];
          if (void 0 === n) {
            let i = e.nodeName;
            console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                i +
                "." +
                r +
                " but it wasn't found.",
              t
            );
            return;
          }
          let a = this.Versioning.None;
          (this.targetObject = t),
            void 0 !== t.needsUpdate
              ? (a = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let o = this.BindingType.Direct;
          if (void 0 !== s) {
            if ("morphTargetInfluences" === r) {
              if (!t.geometry) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
                return;
              }
              if (!t.geometry.morphAttributes) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
                return;
              }
              void 0 !== t.morphTargetDictionary[s] &&
                (s = t.morphTargetDictionary[s]);
            }
            (o = this.BindingType.ArrayElement),
              (this.resolvedProperty = n),
              (this.propertyIndex = s);
          } else
            void 0 !== n.fromArray && void 0 !== n.toArray
              ? ((o = this.BindingType.HasFromToArray),
                (this.resolvedProperty = n))
              : Array.isArray(n)
              ? ((o = this.BindingType.EntireArray),
                (this.resolvedProperty = n))
              : (this.propertyName = r);
          (this.getValue = this.GetterByBindingType[o]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      };
      (PropertyBinding.Composite = class {
        constructor(t, e, i) {
          let r = i || PropertyBinding.parseTrackName(e);
          (this._targetGroup = t), (this._bindings = t.subscribe_(e, r));
        }
        getValue(t, e) {
          this.bind();
          let i = this._targetGroup.nCachedObjects_,
            r = this._bindings[i];
          void 0 !== r && r.getValue(t, e);
        }
        setValue(t, e) {
          let i = this._bindings;
          for (
            let r = this._targetGroup.nCachedObjects_, s = i.length;
            r !== s;
            ++r
          )
            i[r].setValue(t, e);
        }
        bind() {
          let t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, i = t.length;
            e !== i;
            ++e
          )
            t[e].bind();
        }
        unbind() {
          let t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, i = t.length;
            e !== i;
            ++e
          )
            t[e].unbind();
        }
      }),
        (PropertyBinding.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (PropertyBinding.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (PropertyBinding.prototype.GetterByBindingType = [
          PropertyBinding.prototype._getValue_direct,
          PropertyBinding.prototype._getValue_array,
          PropertyBinding.prototype._getValue_arrayElement,
          PropertyBinding.prototype._getValue_toArray,
        ]),
        (PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
          [
            PropertyBinding.prototype._setValue_direct,
            PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
            PropertyBinding.prototype
              ._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            PropertyBinding.prototype._setValue_array,
            PropertyBinding.prototype._setValue_array_setNeedsUpdate,
            PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            PropertyBinding.prototype._setValue_arrayElement,
            PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
            PropertyBinding.prototype
              ._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            PropertyBinding.prototype._setValue_fromArray,
            PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
            PropertyBinding.prototype
              ._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      let AnimationObjectGroup = class AnimationObjectGroup {
        constructor() {
          (this.isAnimationObjectGroup = !0),
            (this.uuid = generateUUID()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          let t = {};
          this._indicesByUUID = t;
          for (let e = 0, i = arguments.length; e !== i; ++e)
            t[arguments[e].uuid] = e;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          let e = this;
          this.stats = {
            objects: {
              get total() {
                return e._objects.length;
              },
              get inUse() {
                return this.total - e.nCachedObjects_;
              },
            },
            get bindingsPerObject() {
              return e._bindings.length;
            },
          };
        }
        add() {
          let t = this._objects,
            e = this._indicesByUUID,
            i = this._paths,
            r = this._parsedPaths,
            s = this._bindings,
            n = s.length,
            a,
            o = t.length,
            h = this.nCachedObjects_;
          for (let l = 0, u = arguments.length; l !== u; ++l) {
            let u = arguments[l],
              c = u.uuid,
              d = e[c];
            if (void 0 === d) {
              (d = o++), (e[c] = d), t.push(u);
              for (let t = 0; t !== n; ++t)
                s[t].push(new PropertyBinding(u, i[t], r[t]));
            } else if (d < h) {
              a = t[d];
              let o = --h,
                l = t[o];
              (e[l.uuid] = d), (t[d] = l), (e[c] = o), (t[o] = u);
              for (let t = 0; t !== n; ++t) {
                let e = s[t],
                  n = e[o],
                  a = e[d];
                (e[d] = n),
                  void 0 === a && (a = new PropertyBinding(u, i[t], r[t])),
                  (e[o] = a);
              }
            } else
              t[d] !== a &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                );
          }
          this.nCachedObjects_ = h;
        }
        remove() {
          let t = this._objects,
            e = this._indicesByUUID,
            i = this._bindings,
            r = i.length,
            s = this.nCachedObjects_;
          for (let n = 0, a = arguments.length; n !== a; ++n) {
            let a = arguments[n],
              o = a.uuid,
              h = e[o];
            if (void 0 !== h && h >= s) {
              let n = s++,
                l = t[n];
              (e[l.uuid] = h), (t[h] = l), (e[o] = n), (t[n] = a);
              for (let t = 0; t !== r; ++t) {
                let e = i[t],
                  r = e[n],
                  s = e[h];
                (e[h] = r), (e[n] = s);
              }
            }
          }
          this.nCachedObjects_ = s;
        }
        uncache() {
          let t = this._objects,
            e = this._indicesByUUID,
            i = this._bindings,
            r = i.length,
            s = this.nCachedObjects_,
            n = t.length;
          for (let a = 0, o = arguments.length; a !== o; ++a) {
            let o = arguments[a],
              h = o.uuid,
              l = e[h];
            if (void 0 !== l) {
              if ((delete e[h], l < s)) {
                let a = --s,
                  o = t[a],
                  h = --n,
                  u = t[h];
                (e[o.uuid] = l),
                  (t[l] = o),
                  (e[u.uuid] = a),
                  (t[a] = u),
                  t.pop();
                for (let t = 0; t !== r; ++t) {
                  let e = i[t],
                    r = e[a],
                    s = e[h];
                  (e[l] = r), (e[a] = s), e.pop();
                }
              } else {
                let s = --n,
                  a = t[s];
                s > 0 && (e[a.uuid] = l), (t[l] = a), t.pop();
                for (let t = 0; t !== r; ++t) {
                  let e = i[t];
                  (e[l] = e[s]), e.pop();
                }
              }
            }
          }
          this.nCachedObjects_ = s;
        }
        subscribe_(t, e) {
          let i = this._bindingsIndicesByPath,
            r = i[t],
            s = this._bindings;
          if (void 0 !== r) return s[r];
          let n = this._paths,
            a = this._parsedPaths,
            o = this._objects,
            h = o.length,
            l = this.nCachedObjects_,
            u = Array(h);
          (r = s.length), (i[t] = r), n.push(t), a.push(e), s.push(u);
          for (let i = l, r = o.length; i !== r; ++i) {
            let r = o[i];
            u[i] = new PropertyBinding(r, t, e);
          }
          return u;
        }
        unsubscribe_(t) {
          let e = this._bindingsIndicesByPath,
            i = e[t];
          if (void 0 !== i) {
            let r = this._paths,
              s = this._parsedPaths,
              n = this._bindings,
              a = n.length - 1,
              o = n[a],
              h = t[a];
            (e[h] = i),
              (n[i] = o),
              n.pop(),
              (s[i] = s[a]),
              s.pop(),
              (r[i] = r[a]),
              r.pop();
          }
        }
      };
      let AnimationAction = class AnimationAction {
        constructor(t, e, i = null, r = e.blendMode) {
          (this._mixer = t),
            (this._clip = e),
            (this._localRoot = i),
            (this.blendMode = r);
          let s = e.tracks,
            n = s.length,
            a = Array(n),
            o = { endingStart: ek, endingEnd: ek };
          for (let t = 0; t !== n; ++t) {
            let e = s[t].createInterpolant(null);
            (a[t] = e), (e.settings = o);
          }
          (this._interpolantSettings = o),
            (this._interpolants = a),
            (this._propertyBindings = Array(n)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = eB),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(t) {
          return (this._startTime = t), this;
        }
        setLoop(t, e) {
          return (this.loop = t), (this.repetitions = e), this;
        }
        setEffectiveWeight(t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(t) {
          return this._scheduleFading(t, 0, 1);
        }
        fadeOut(t) {
          return this._scheduleFading(t, 1, 0);
        }
        crossFadeFrom(t, e, i) {
          if ((t.fadeOut(e), this.fadeIn(e), i)) {
            let i = this._clip.duration,
              r = t._clip.duration;
            t.warp(1, r / i, e), this.warp(i / r, 1, e);
          }
          return this;
        }
        crossFadeTo(t, e, i) {
          return t.crossFadeFrom(this, e, i);
        }
        stopFading() {
          let t = this._weightInterpolant;
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        }
        setEffectiveTimeScale(t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping();
        }
        syncWith(t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          );
        }
        halt(t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        }
        warp(t, e, i) {
          let r = this._mixer,
            s = r.time,
            n = this.timeScale,
            a = this._timeScaleInterpolant;
          null === a &&
            ((a = r._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          let o = a.parameterPositions,
            h = a.sampleValues;
          return (
            (o[0] = s), (o[1] = s + i), (h[0] = t / n), (h[1] = e / n), this
          );
        }
        stopWarping() {
          let t = this._timeScaleInterpolant;
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(t, e, i, r) {
          if (!this.enabled) {
            this._updateWeight(t);
            return;
          }
          let s = this._startTime;
          if (null !== s) {
            let r = (t - s) * i;
            r < 0 || 0 === i
              ? (e = 0)
              : ((this._startTime = null), (e = i * r));
          }
          e *= this._updateTimeScale(t);
          let n = this._updateTime(e),
            a = this._updateWeight(t);
          if (a > 0) {
            let t = this._interpolants,
              e = this._propertyBindings;
            if (this.blendMode === eF)
              for (let i = 0, r = t.length; i !== r; ++i)
                t[i].evaluate(n), e[i].accumulateAdditive(a);
            else
              for (let i = 0, s = t.length; i !== s; ++i)
                t[i].evaluate(n), e[i].accumulate(r, a);
          }
        }
        _updateWeight(t) {
          let e = 0;
          if (this.enabled) {
            e = this.weight;
            let i = this._weightInterpolant;
            if (null !== i) {
              let r = i.evaluate(t)[0];
              (e *= r),
                t > i.parameterPositions[1] &&
                  (this.stopFading(), 0 === r && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = e), e;
        }
        _updateTimeScale(t) {
          let e = 0;
          if (!this.paused) {
            e = this.timeScale;
            let i = this._timeScaleInterpolant;
            if (null !== i) {
              let r = i.evaluate(t)[0];
              (e *= r),
                t > i.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === e ? (this.paused = !0) : (this.timeScale = e));
            }
          }
          return (this._effectiveTimeScale = e), e;
        }
        _updateTime(t) {
          let e = this._clip.duration,
            i = this.loop,
            r = this.time + t,
            s = this._loopCount,
            n = i === eI;
          if (0 === t) return -1 === s ? r : n && (1 & s) == 1 ? e - r : r;
          if (i === ez) {
            -1 === s && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            s: {
              if (r >= e) r = e;
              else if (r < 0) r = 0;
              else {
                this.time = r;
                break s;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = r),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === s &&
                (t >= 0
                  ? ((s = 0), this._setEndings(!0, 0 === this.repetitions, n))
                  : this._setEndings(0 === this.repetitions, !0, n)),
              r >= e || r < 0)
            ) {
              let i = Math.floor(r / e);
              (r -= e * i), (s += Math.abs(i));
              let a = this.repetitions - s;
              if (a <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (r = t > 0 ? e : 0),
                  (this.time = r),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1,
                  });
              else {
                if (1 === a) {
                  let e = t < 0;
                  this._setEndings(e, !e, n);
                } else this._setEndings(!1, !1, n);
                (this._loopCount = s),
                  (this.time = r),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: i,
                  });
              }
            } else this.time = r;
            if (n && (1 & s) == 1) return e - r;
          }
          return r;
        }
        _setEndings(t, e, i) {
          let r = this._interpolantSettings;
          i
            ? ((r.endingStart = eR), (r.endingEnd = eR))
            : (t
                ? (r.endingStart = this.zeroSlopeAtStart ? eR : ek)
                : (r.endingStart = eE),
              e
                ? (r.endingEnd = this.zeroSlopeAtEnd ? eR : ek)
                : (r.endingEnd = eE));
        }
        _scheduleFading(t, e, i) {
          let r = this._mixer,
            s = r.time,
            n = this._weightInterpolant;
          null === n &&
            ((n = r._lendControlInterpolant()), (this._weightInterpolant = n));
          let a = n.parameterPositions,
            o = n.sampleValues;
          return (a[0] = s), (o[0] = e), (a[1] = s + t), (o[1] = i), this;
        }
      };
      let nY = new Float32Array(1);
      let AnimationMixer = class AnimationMixer extends EventDispatcher {
        constructor(t) {
          super(),
            (this._root = t),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(t, e) {
          let i = t._localRoot || this._root,
            r = t._clip.tracks,
            s = r.length,
            n = t._propertyBindings,
            a = t._interpolants,
            o = i.uuid,
            h = this._bindingsByRootAndName,
            l = h[o];
          void 0 === l && ((l = {}), (h[o] = l));
          for (let t = 0; t !== s; ++t) {
            let s = r[t],
              h = s.name,
              u = l[h];
            if (void 0 !== u) ++u.referenceCount, (n[t] = u);
            else {
              if (void 0 !== (u = n[t])) {
                null === u._cacheIndex &&
                  (++u.referenceCount, this._addInactiveBinding(u, o, h));
                continue;
              }
              let r = e && e._propertyBindings[t].binding.parsedPath;
              (u = new PropertyMixer(
                PropertyBinding.create(i, h, r),
                s.ValueTypeName,
                s.getValueSize()
              )),
                ++u.referenceCount,
                this._addInactiveBinding(u, o, h),
                (n[t] = u);
            }
            a[t].resultBuffer = u.buffer;
          }
        }
        _activateAction(t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              let e = (t._localRoot || this._root).uuid,
                i = t._clip.uuid,
                r = this._actionsByClip[i];
              this._bindAction(t, r && r.knownActions[0]),
                this._addInactiveAction(t, i, e);
            }
            let e = t._propertyBindings;
            for (let t = 0, i = e.length; t !== i; ++t) {
              let i = e[t];
              0 == i.useCount++ &&
                (this._lendBinding(i), i.saveOriginalState());
            }
            this._lendAction(t);
          }
        }
        _deactivateAction(t) {
          if (this._isActiveAction(t)) {
            let e = t._propertyBindings;
            for (let t = 0, i = e.length; t !== i; ++t) {
              let i = e[t];
              0 == --i.useCount &&
                (i.restoreOriginalState(), this._takeBackBinding(i));
            }
            this._takeBackAction(t);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          let t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(t) {
          let e = t._cacheIndex;
          return null !== e && e < this._nActiveActions;
        }
        _addInactiveAction(t, e, i) {
          let r = this._actions,
            s = this._actionsByClip,
            n = s[e];
          if (void 0 === n)
            (n = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (s[e] = n);
          else {
            let e = n.knownActions;
            (t._byClipCacheIndex = e.length), e.push(t);
          }
          (t._cacheIndex = r.length), r.push(t), (n.actionByRoot[i] = t);
        }
        _removeInactiveAction(t) {
          let e = this._actions,
            i = e[e.length - 1],
            r = t._cacheIndex;
          (i._cacheIndex = r), (e[r] = i), e.pop(), (t._cacheIndex = null);
          let s = t._clip.uuid,
            n = this._actionsByClip,
            a = n[s],
            o = a.knownActions,
            h = o[o.length - 1],
            l = t._byClipCacheIndex;
          (h._byClipCacheIndex = l),
            (o[l] = h),
            o.pop(),
            (t._byClipCacheIndex = null);
          let u = a.actionByRoot,
            c = (t._localRoot || this._root).uuid;
          delete u[c],
            0 === o.length && delete n[s],
            this._removeInactiveBindingsForAction(t);
        }
        _removeInactiveBindingsForAction(t) {
          let e = t._propertyBindings;
          for (let t = 0, i = e.length; t !== i; ++t) {
            let i = e[t];
            0 == --i.referenceCount && this._removeInactiveBinding(i);
          }
        }
        _lendAction(t) {
          let e = this._actions,
            i = t._cacheIndex,
            r = this._nActiveActions++,
            s = e[r];
          (t._cacheIndex = r), (e[r] = t), (s._cacheIndex = i), (e[i] = s);
        }
        _takeBackAction(t) {
          let e = this._actions,
            i = t._cacheIndex,
            r = --this._nActiveActions,
            s = e[r];
          (t._cacheIndex = r), (e[r] = t), (s._cacheIndex = i), (e[i] = s);
        }
        _addInactiveBinding(t, e, i) {
          let r = this._bindingsByRootAndName,
            s = this._bindings,
            n = r[e];
          void 0 === n && ((n = {}), (r[e] = n)),
            (n[i] = t),
            (t._cacheIndex = s.length),
            s.push(t);
        }
        _removeInactiveBinding(t) {
          let e = this._bindings,
            i = t.binding,
            r = i.rootNode.uuid,
            s = i.path,
            n = this._bindingsByRootAndName,
            a = n[r],
            o = e[e.length - 1],
            h = t._cacheIndex;
          (o._cacheIndex = h),
            (e[h] = o),
            e.pop(),
            delete a[s],
            0 === Object.keys(a).length && delete n[r];
        }
        _lendBinding(t) {
          let e = this._bindings,
            i = t._cacheIndex,
            r = this._nActiveBindings++,
            s = e[r];
          (t._cacheIndex = r), (e[r] = t), (s._cacheIndex = i), (e[i] = s);
        }
        _takeBackBinding(t) {
          let e = this._bindings,
            i = t._cacheIndex,
            r = --this._nActiveBindings,
            s = e[r];
          (t._cacheIndex = r), (e[r] = t), (s._cacheIndex = i), (e[i] = s);
        }
        _lendControlInterpolant() {
          let t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++,
            i = t[e];
          return (
            void 0 === i &&
              (((i = new LinearInterpolant(
                new Float32Array(2),
                new Float32Array(2),
                1,
                nY
              )).__cacheIndex = e),
              (t[e] = i)),
            i
          );
        }
        _takeBackControlInterpolant(t) {
          let e = this._controlInterpolants,
            i = t.__cacheIndex,
            r = --this._nActiveControlInterpolants,
            s = e[r];
          (t.__cacheIndex = r), (e[r] = t), (s.__cacheIndex = i), (e[i] = s);
        }
        clipAction(t, e, i) {
          let r = e || this._root,
            s = r.uuid,
            n = "string" == typeof t ? AnimationClip.findByName(r, t) : t,
            a = null !== n ? n.uuid : t,
            o = this._actionsByClip[a],
            h = null;
          if (
            (void 0 === i && (i = null !== n ? n.blendMode : eO), void 0 !== o)
          ) {
            let t = o.actionByRoot[s];
            if (void 0 !== t && t.blendMode === i) return t;
            (h = o.knownActions[0]), null === n && (n = h._clip);
          }
          if (null === n) return null;
          let l = new AnimationAction(this, n, e, i);
          return this._bindAction(l, h), this._addInactiveAction(l, a, s), l;
        }
        existingAction(t, e) {
          let i = e || this._root,
            r = i.uuid,
            s = "string" == typeof t ? AnimationClip.findByName(i, t) : t,
            n = s ? s.uuid : t,
            a = this._actionsByClip[n];
          return (void 0 !== a && a.actionByRoot[r]) || null;
        }
        stopAllAction() {
          let t = this._actions,
            e = this._nActiveActions;
          for (let i = e - 1; i >= 0; --i) t[i].stop();
          return this;
        }
        update(t) {
          t *= this.timeScale;
          let e = this._actions,
            i = this._nActiveActions,
            r = (this.time += t),
            s = Math.sign(t),
            n = (this._accuIndex ^= 1);
          for (let a = 0; a !== i; ++a) {
            let i = e[a];
            i._update(r, t, s, n);
          }
          let a = this._bindings,
            o = this._nActiveBindings;
          for (let t = 0; t !== o; ++t) a[t].apply(n);
          return this;
        }
        setTime(t) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(t);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(t) {
          let e = this._actions,
            i = t.uuid,
            r = this._actionsByClip,
            s = r[i];
          if (void 0 !== s) {
            let t = s.knownActions;
            for (let i = 0, r = t.length; i !== r; ++i) {
              let r = t[i];
              this._deactivateAction(r);
              let s = r._cacheIndex,
                n = e[e.length - 1];
              (r._cacheIndex = null),
                (r._byClipCacheIndex = null),
                (n._cacheIndex = s),
                (e[s] = n),
                e.pop(),
                this._removeInactiveBindingsForAction(r);
            }
            delete r[i];
          }
        }
        uncacheRoot(t) {
          let e = t.uuid,
            i = this._actionsByClip;
          for (let t in i) {
            let r = i[t].actionByRoot,
              s = r[e];
            void 0 !== s &&
              (this._deactivateAction(s), this._removeInactiveAction(s));
          }
          let r = this._bindingsByRootAndName,
            s = r[e];
          if (void 0 !== s)
            for (let t in s) {
              let e = s[t];
              e.restoreOriginalState(), this._removeInactiveBinding(e);
            }
        }
        uncacheAction(t, e) {
          let i = this.existingAction(t, e);
          null !== i &&
            (this._deactivateAction(i), this._removeInactiveAction(i));
        }
      };
      let Uniform = class Uniform {
        constructor(t) {
          this.value = t;
        }
        clone() {
          return new Uniform(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }
      };
      let nQ = 0;
      let UniformsGroup = class UniformsGroup extends EventDispatcher {
        constructor() {
          super(),
            (this.isUniformsGroup = !0),
            Object.defineProperty(this, "id", { value: nQ++ }),
            (this.name = ""),
            (this.usage = im),
            (this.uniforms = []);
        }
        add(t) {
          return this.uniforms.push(t), this;
        }
        remove(t) {
          let e = this.uniforms.indexOf(t);
          return -1 !== e && this.uniforms.splice(e, 1), this;
        }
        setName(t) {
          return (this.name = t), this;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        dispose() {
          return this.dispatchEvent({ type: "dispose" }), this;
        }
        copy(t) {
          (this.name = t.name), (this.usage = t.usage);
          let e = t.uniforms;
          this.uniforms.length = 0;
          for (let t = 0, i = e.length; t < i; t++) {
            let i = Array.isArray(e[t]) ? e[t] : [e[t]];
            for (let t = 0; t < i.length; t++) this.uniforms.push(i[t].clone());
          }
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      let InstancedInterleavedBuffer = class InstancedInterleavedBuffer extends InterleavedBuffer {
        constructor(t, e, i = 1) {
          super(t, e),
            (this.isInstancedInterleavedBuffer = !0),
            (this.meshPerAttribute = i);
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          );
        }
        clone(t) {
          let e = super.clone(t);
          return (e.meshPerAttribute = this.meshPerAttribute), e;
        }
        toJSON(t) {
          let e = super.toJSON(t);
          return (
            (e.isInstancedInterleavedBuffer = !0),
            (e.meshPerAttribute = this.meshPerAttribute),
            e
          );
        }
      };
      let GLBufferAttribute = class GLBufferAttribute {
        constructor(t, e, i, r, s) {
          (this.isGLBufferAttribute = !0),
            (this.name = ""),
            (this.buffer = t),
            (this.type = e),
            (this.itemSize = i),
            (this.elementSize = r),
            (this.count = s),
            (this.version = 0);
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setBuffer(t) {
          return (this.buffer = t), this;
        }
        setType(t, e) {
          return (this.type = t), (this.elementSize = e), this;
        }
        setItemSize(t) {
          return (this.itemSize = t), this;
        }
        setCount(t) {
          return (this.count = t), this;
        }
      };
      let nK = new Matrix4();
      let Raycaster = class Raycaster {
        constructor(t, e, i = 0, r = 1 / 0) {
          (this.ray = new Ray(t, e)),
            (this.near = i),
            (this.far = r),
            (this.camera = null),
            (this.layers = new Layers()),
            (this.params = {
              Mesh: {},
              Line: { threshold: 1 },
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            });
        }
        set(t, e) {
          this.ray.set(t, e);
        }
        setFromCamera(t, e) {
          e.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
              this.ray.direction
                .set(t.x, t.y, 0.5)
                .unproject(e)
                .sub(this.ray.origin)
                .normalize(),
              (this.camera = e))
            : e.isOrthographicCamera
            ? (this.ray.origin
                .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                .unproject(e),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(e.matrixWorld),
              (this.camera = e))
            : console.error(
                "THREE.Raycaster: Unsupported camera type: " + e.type
              );
        }
        setFromXRController(t) {
          return (
            nK.identity().extractRotation(t.matrixWorld),
            this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(0, 0, -1).applyMatrix4(nK),
            this
          );
        }
        intersectObject(t, e = !0, i = []) {
          return intersect(t, this, i, e), i.sort(ascSort), i;
        }
        intersectObjects(t, e = !0, i = []) {
          for (let r = 0, s = t.length; r < s; r++) intersect(t[r], this, i, e);
          return i.sort(ascSort), i;
        }
      };
      function ascSort(t, e) {
        return t.distance - e.distance;
      }
      function intersect(t, e, i, r) {
        let s = !0;
        if (t.layers.test(e.layers)) {
          let r = t.raycast(e, i);
          !1 === r && (s = !1);
        }
        if (!0 === s && !0 === r) {
          let r = t.children;
          for (let t = 0, s = r.length; t < s; t++) intersect(r[t], e, i, !0);
        }
      }
      let Spherical = class Spherical {
        constructor(t = 1, e = 0, i = 0) {
          return (this.radius = t), (this.phi = e), (this.theta = i), this;
        }
        set(t, e, i) {
          return (this.radius = t), (this.phi = e), (this.theta = i), this;
        }
        copy(t) {
          return (
            (this.radius = t.radius),
            (this.phi = t.phi),
            (this.theta = t.theta),
            this
          );
        }
        makeSafe() {
          return (this.phi = clamp(this.phi, 1e-6, Math.PI - 1e-6)), this;
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        }
        setFromCartesianCoords(t, e, i) {
          return (
            (this.radius = Math.sqrt(t * t + e * e + i * i)),
            0 === this.radius
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(t, i)),
                (this.phi = Math.acos(clamp(e / this.radius, -1, 1)))),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      let Cylindrical = class Cylindrical {
        constructor(t = 1, e = 0, i = 0) {
          return (this.radius = t), (this.theta = e), (this.y = i), this;
        }
        set(t, e, i) {
          return (this.radius = t), (this.theta = e), (this.y = i), this;
        }
        copy(t) {
          return (
            (this.radius = t.radius),
            (this.theta = t.theta),
            (this.y = t.y),
            this
          );
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        }
        setFromCartesianCoords(t, e, i) {
          return (
            (this.radius = Math.sqrt(t * t + i * i)),
            (this.theta = Math.atan2(t, i)),
            (this.y = e),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      let Matrix2 = class Matrix2 {
        constructor(t, e, i, r) {
          (Matrix2.prototype.isMatrix2 = !0),
            (this.elements = [1, 0, 0, 1]),
            void 0 !== t && this.set(t, e, i, r);
        }
        identity() {
          return this.set(1, 0, 0, 1), this;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 4; i++) this.elements[i] = t[i + e];
          return this;
        }
        set(t, e, i, r) {
          let s = this.elements;
          return (s[0] = t), (s[2] = e), (s[1] = i), (s[3] = r), this;
        }
      };
      let n$ = new Vector2();
      let Box2 = class Box2 {
        constructor(
          t = new Vector2(Infinity, Infinity),
          e = new Vector2(-1 / 0, -1 / 0)
        ) {
          (this.isBox2 = !0), (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          let i = n$.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = Infinity),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        containsPoint(t) {
          return (
            t.x >= this.min.x &&
            t.x <= this.max.x &&
            t.y >= this.min.y &&
            t.y <= this.max.y
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          );
        }
        intersectsBox(t) {
          return (
            t.max.x >= this.min.x &&
            t.min.x <= this.max.x &&
            t.max.y >= this.min.y &&
            t.min.y <= this.max.y
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return this.clampPoint(t, n$).distanceTo(t);
        }
        intersect(t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      };
      let n0 = new Vector3(),
        n1 = new Vector3();
      let Line3 = class Line3 {
        constructor(t = new Vector3(), e = new Vector3()) {
          (this.start = t), (this.end = e);
        }
        set(t, e) {
          return this.start.copy(t), this.end.copy(e), this;
        }
        copy(t) {
          return this.start.copy(t.start), this.end.copy(t.end), this;
        }
        getCenter(t) {
          return t.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(t) {
          return t.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, e) {
          return this.delta(e).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(t, e) {
          n0.subVectors(t, this.start), n1.subVectors(this.end, this.start);
          let i = n1.dot(n1),
            r = n1.dot(n0),
            s = r / i;
          return e && (s = clamp(s, 0, 1)), s;
        }
        closestPointToPoint(t, e, i) {
          let r = this.closestPointToPointParameter(t, e);
          return this.delta(i).multiplyScalar(r).add(this.start);
        }
        applyMatrix4(t) {
          return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
        }
        equals(t) {
          return t.start.equals(this.start) && t.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      let n3 = new Vector3();
      let SpotLightHelper = class SpotLightHelper extends Object3D {
        constructor(t, e) {
          super(),
            (this.light = t),
            (this.matrixAutoUpdate = !1),
            (this.color = e),
            (this.type = "SpotLightHelper");
          let i = new BufferGeometry(),
            r = [
              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
              1, 1, 0, 0, 0, 0, -1, 1,
            ];
          for (let t = 0, e = 1; t < 32; t++, e++) {
            let i = (t / 32) * Math.PI * 2,
              s = (e / 32) * Math.PI * 2;
            r.push(Math.cos(i), Math.sin(i), 1, Math.cos(s), Math.sin(s), 1);
          }
          i.setAttribute("position", new Float32BufferAttribute(r, 3));
          let s = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
          (this.cone = new LineSegments(i, s)),
            this.add(this.cone),
            this.update();
        }
        dispose() {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
          this.light.updateWorldMatrix(!0, !1),
            this.light.target.updateWorldMatrix(!0, !1),
            this.parent
              ? (this.parent.updateWorldMatrix(!0),
                this.matrix
                  .copy(this.parent.matrixWorld)
                  .invert()
                  .multiply(this.light.matrixWorld))
              : this.matrix.copy(this.light.matrixWorld),
            this.matrixWorld.copy(this.light.matrixWorld);
          let t = this.light.distance ? this.light.distance : 1e3,
            e = t * Math.tan(this.light.angle);
          this.cone.scale.set(e, e, t),
            n3.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(n3),
            void 0 !== this.color
              ? this.cone.material.color.set(this.color)
              : this.cone.material.color.copy(this.light.color);
        }
      };
      let n2 = new Vector3(),
        n4 = new Matrix4(),
        n5 = new Matrix4();
      let SkeletonHelper = class SkeletonHelper extends LineSegments {
        constructor(t) {
          let e = (function getBoneList(t) {
              let e = [];
              !0 === t.isBone && e.push(t);
              for (let i = 0; i < t.children.length; i++)
                e.push.apply(e, getBoneList(t.children[i]));
              return e;
            })(t),
            i = new BufferGeometry(),
            r = [],
            s = [],
            n = new Color(0, 0, 1),
            a = new Color(0, 1, 0);
          for (let t = 0; t < e.length; t++) {
            let i = e[t];
            i.parent &&
              i.parent.isBone &&
              (r.push(0, 0, 0),
              r.push(0, 0, 0),
              s.push(n.r, n.g, n.b),
              s.push(a.r, a.g, a.b));
          }
          i.setAttribute("position", new Float32BufferAttribute(r, 3)),
            i.setAttribute("color", new Float32BufferAttribute(s, 3));
          let o = new LineBasicMaterial({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0,
          });
          super(i, o),
            (this.isSkeletonHelper = !0),
            (this.type = "SkeletonHelper"),
            (this.root = t),
            (this.bones = e),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(t) {
          let e = this.bones,
            i = this.geometry,
            r = i.getAttribute("position");
          n5.copy(this.root.matrixWorld).invert();
          for (let t = 0, i = 0; t < e.length; t++) {
            let s = e[t];
            s.parent &&
              s.parent.isBone &&
              (n4.multiplyMatrices(n5, s.matrixWorld),
              n2.setFromMatrixPosition(n4),
              r.setXYZ(i, n2.x, n2.y, n2.z),
              n4.multiplyMatrices(n5, s.parent.matrixWorld),
              n2.setFromMatrixPosition(n4),
              r.setXYZ(i + 1, n2.x, n2.y, n2.z),
              (i += 2));
          }
          (i.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(t);
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      };
      let PointLightHelper = class PointLightHelper extends Mesh {
        constructor(t, e, i) {
          let r = new SphereGeometry(e, 4, 2),
            s = new MeshBasicMaterial({
              wireframe: !0,
              fog: !1,
              toneMapped: !1,
            });
          super(r, s),
            (this.light = t),
            (this.color = i),
            (this.type = "PointLightHelper"),
            (this.matrix = this.light.matrixWorld),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
        update() {
          this.light.updateWorldMatrix(!0, !1),
            void 0 !== this.color
              ? this.material.color.set(this.color)
              : this.material.color.copy(this.light.color);
        }
      };
      let n6 = new Vector3(),
        n7 = new Color(),
        n8 = new Color();
      let HemisphereLightHelper = class HemisphereLightHelper extends Object3D {
        constructor(t, e, i) {
          super(),
            (this.light = t),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = i),
            (this.type = "HemisphereLightHelper");
          let r = new OctahedronGeometry(e);
          r.rotateY(0.5 * Math.PI),
            (this.material = new MeshBasicMaterial({
              wireframe: !0,
              fog: !1,
              toneMapped: !1,
            })),
            void 0 === this.color && (this.material.vertexColors = !0);
          let s = r.getAttribute("position"),
            n = new Float32Array(3 * s.count);
          r.setAttribute("color", new BufferAttribute(n, 3)),
            this.add(new Mesh(r, this.material)),
            this.update();
        }
        dispose() {
          this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }
        update() {
          let t = this.children[0];
          if (void 0 !== this.color) this.material.color.set(this.color);
          else {
            let e = t.geometry.getAttribute("color");
            n7.copy(this.light.color), n8.copy(this.light.groundColor);
            for (let t = 0, i = e.count; t < i; t++) {
              let r = t < i / 2 ? n7 : n8;
              e.setXYZ(t, r.r, r.g, r.b);
            }
            e.needsUpdate = !0;
          }
          this.light.updateWorldMatrix(!0, !1),
            t.lookAt(n6.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      };
      let GridHelper = class GridHelper extends LineSegments {
        constructor(t = 10, e = 10, i = 4473924, r = 8947848) {
          (i = new Color(i)), (r = new Color(r));
          let s = e / 2,
            n = t / e,
            a = t / 2,
            o = [],
            h = [];
          for (let t = 0, l = 0, u = -a; t <= e; t++, u += n) {
            o.push(-a, 0, u, a, 0, u), o.push(u, 0, -a, u, 0, a);
            let e = t === s ? i : r;
            e.toArray(h, l),
              (l += 3),
              e.toArray(h, l),
              (l += 3),
              e.toArray(h, l),
              (l += 3),
              e.toArray(h, l),
              (l += 3);
          }
          let l = new BufferGeometry();
          l.setAttribute("position", new Float32BufferAttribute(o, 3)),
            l.setAttribute("color", new Float32BufferAttribute(h, 3));
          let u = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
          super(l, u), (this.type = "GridHelper");
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      };
      let PolarGridHelper = class PolarGridHelper extends LineSegments {
        constructor(t = 10, e = 16, i = 8, r = 64, s = 4473924, n = 8947848) {
          (s = new Color(s)), (n = new Color(n));
          let a = [],
            o = [];
          if (e > 1)
            for (let i = 0; i < e; i++) {
              let r = (i / e) * (2 * Math.PI),
                h = Math.sin(r) * t,
                l = Math.cos(r) * t;
              a.push(0, 0, 0), a.push(h, 0, l);
              let u = 1 & i ? s : n;
              o.push(u.r, u.g, u.b), o.push(u.r, u.g, u.b);
            }
          for (let e = 0; e < i; e++) {
            let h = 1 & e ? s : n,
              l = t - (t / i) * e;
            for (let t = 0; t < r; t++) {
              let e = (t / r) * (2 * Math.PI),
                i = Math.sin(e) * l,
                s = Math.cos(e) * l;
              a.push(i, 0, s),
                o.push(h.r, h.g, h.b),
                (i = Math.sin((e = ((t + 1) / r) * (2 * Math.PI))) * l),
                (s = Math.cos(e) * l),
                a.push(i, 0, s),
                o.push(h.r, h.g, h.b);
            }
          }
          let h = new BufferGeometry();
          h.setAttribute("position", new Float32BufferAttribute(a, 3)),
            h.setAttribute("color", new Float32BufferAttribute(o, 3));
          let l = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
          super(h, l), (this.type = "PolarGridHelper");
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      };
      let n9 = new Vector3(),
        at = new Vector3(),
        ae = new Vector3();
      let DirectionalLightHelper = class DirectionalLightHelper extends Object3D {
        constructor(t, e, i) {
          super(),
            (this.light = t),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = i),
            (this.type = "DirectionalLightHelper"),
            void 0 === e && (e = 1);
          let r = new BufferGeometry();
          r.setAttribute(
            "position",
            new Float32BufferAttribute(
              [-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0],
              3
            )
          );
          let s = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
          (this.lightPlane = new Line(r, s)),
            this.add(this.lightPlane),
            (r = new BufferGeometry()).setAttribute(
              "position",
              new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)
            ),
            (this.targetLine = new Line(r, s)),
            this.add(this.targetLine),
            this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
        }
        update() {
          this.light.updateWorldMatrix(!0, !1),
            this.light.target.updateWorldMatrix(!0, !1),
            n9.setFromMatrixPosition(this.light.matrixWorld),
            at.setFromMatrixPosition(this.light.target.matrixWorld),
            ae.subVectors(at, n9),
            this.lightPlane.lookAt(at),
            void 0 !== this.color
              ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color))
              : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(at),
            (this.targetLine.scale.z = ae.length());
        }
      };
      let ai = new Vector3(),
        ar = new Camera();
      let CameraHelper = class CameraHelper extends LineSegments {
        constructor(t) {
          let e = new BufferGeometry(),
            i = new LineBasicMaterial({
              color: 16777215,
              vertexColors: !0,
              toneMapped: !1,
            }),
            r = [],
            s = [],
            n = {};
          function addLine(t, e) {
            addPoint(t), addPoint(e);
          }
          function addPoint(t) {
            r.push(0, 0, 0),
              s.push(0, 0, 0),
              void 0 === n[t] && (n[t] = []),
              n[t].push(r.length / 3 - 1);
          }
          addLine("n1", "n2"),
            addLine("n2", "n4"),
            addLine("n4", "n3"),
            addLine("n3", "n1"),
            addLine("f1", "f2"),
            addLine("f2", "f4"),
            addLine("f4", "f3"),
            addLine("f3", "f1"),
            addLine("n1", "f1"),
            addLine("n2", "f2"),
            addLine("n3", "f3"),
            addLine("n4", "f4"),
            addLine("p", "n1"),
            addLine("p", "n2"),
            addLine("p", "n3"),
            addLine("p", "n4"),
            addLine("u1", "u2"),
            addLine("u2", "u3"),
            addLine("u3", "u1"),
            addLine("c", "t"),
            addLine("p", "c"),
            addLine("cn1", "cn2"),
            addLine("cn3", "cn4"),
            addLine("cf1", "cf2"),
            addLine("cf3", "cf4"),
            e.setAttribute("position", new Float32BufferAttribute(r, 3)),
            e.setAttribute("color", new Float32BufferAttribute(s, 3)),
            super(e, i),
            (this.type = "CameraHelper"),
            (this.camera = t),
            this.camera.updateProjectionMatrix &&
              this.camera.updateProjectionMatrix(),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.pointMap = n),
            this.update();
          let a = new Color(16755200),
            o = new Color(16711680),
            h = new Color(43775),
            l = new Color(16777215),
            u = new Color(3355443);
          this.setColors(a, o, h, l, u);
        }
        setColors(t, e, i, r, s) {
          let n = this.geometry,
            a = n.getAttribute("color");
          a.setXYZ(0, t.r, t.g, t.b),
            a.setXYZ(1, t.r, t.g, t.b),
            a.setXYZ(2, t.r, t.g, t.b),
            a.setXYZ(3, t.r, t.g, t.b),
            a.setXYZ(4, t.r, t.g, t.b),
            a.setXYZ(5, t.r, t.g, t.b),
            a.setXYZ(6, t.r, t.g, t.b),
            a.setXYZ(7, t.r, t.g, t.b),
            a.setXYZ(8, t.r, t.g, t.b),
            a.setXYZ(9, t.r, t.g, t.b),
            a.setXYZ(10, t.r, t.g, t.b),
            a.setXYZ(11, t.r, t.g, t.b),
            a.setXYZ(12, t.r, t.g, t.b),
            a.setXYZ(13, t.r, t.g, t.b),
            a.setXYZ(14, t.r, t.g, t.b),
            a.setXYZ(15, t.r, t.g, t.b),
            a.setXYZ(16, t.r, t.g, t.b),
            a.setXYZ(17, t.r, t.g, t.b),
            a.setXYZ(18, t.r, t.g, t.b),
            a.setXYZ(19, t.r, t.g, t.b),
            a.setXYZ(20, t.r, t.g, t.b),
            a.setXYZ(21, t.r, t.g, t.b),
            a.setXYZ(22, t.r, t.g, t.b),
            a.setXYZ(23, t.r, t.g, t.b),
            a.setXYZ(24, e.r, e.g, e.b),
            a.setXYZ(25, e.r, e.g, e.b),
            a.setXYZ(26, e.r, e.g, e.b),
            a.setXYZ(27, e.r, e.g, e.b),
            a.setXYZ(28, e.r, e.g, e.b),
            a.setXYZ(29, e.r, e.g, e.b),
            a.setXYZ(30, e.r, e.g, e.b),
            a.setXYZ(31, e.r, e.g, e.b),
            a.setXYZ(32, i.r, i.g, i.b),
            a.setXYZ(33, i.r, i.g, i.b),
            a.setXYZ(34, i.r, i.g, i.b),
            a.setXYZ(35, i.r, i.g, i.b),
            a.setXYZ(36, i.r, i.g, i.b),
            a.setXYZ(37, i.r, i.g, i.b),
            a.setXYZ(38, r.r, r.g, r.b),
            a.setXYZ(39, r.r, r.g, r.b),
            a.setXYZ(40, s.r, s.g, s.b),
            a.setXYZ(41, s.r, s.g, s.b),
            a.setXYZ(42, s.r, s.g, s.b),
            a.setXYZ(43, s.r, s.g, s.b),
            a.setXYZ(44, s.r, s.g, s.b),
            a.setXYZ(45, s.r, s.g, s.b),
            a.setXYZ(46, s.r, s.g, s.b),
            a.setXYZ(47, s.r, s.g, s.b),
            a.setXYZ(48, s.r, s.g, s.b),
            a.setXYZ(49, s.r, s.g, s.b),
            (a.needsUpdate = !0);
        }
        update() {
          let t = this.geometry,
            e = this.pointMap;
          ar.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            setPoint("c", e, t, ar, 0, 0, -1),
            setPoint("t", e, t, ar, 0, 0, 1),
            setPoint("n1", e, t, ar, -1, -1, -1),
            setPoint("n2", e, t, ar, 1, -1, -1),
            setPoint("n3", e, t, ar, -1, 1, -1),
            setPoint("n4", e, t, ar, 1, 1, -1),
            setPoint("f1", e, t, ar, -1, -1, 1),
            setPoint("f2", e, t, ar, 1, -1, 1),
            setPoint("f3", e, t, ar, -1, 1, 1),
            setPoint("f4", e, t, ar, 1, 1, 1),
            setPoint("u1", e, t, ar, 0.7, 1.1, -1),
            setPoint("u2", e, t, ar, -0.7, 1.1, -1),
            setPoint("u3", e, t, ar, 0, 2, -1),
            setPoint("cf1", e, t, ar, -1, 0, 1),
            setPoint("cf2", e, t, ar, 1, 0, 1),
            setPoint("cf3", e, t, ar, 0, -1, 1),
            setPoint("cf4", e, t, ar, 0, 1, 1),
            setPoint("cn1", e, t, ar, -1, 0, -1),
            setPoint("cn2", e, t, ar, 1, 0, -1),
            setPoint("cn3", e, t, ar, 0, -1, -1),
            setPoint("cn4", e, t, ar, 0, 1, -1),
            (t.getAttribute("position").needsUpdate = !0);
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      };
      function setPoint(t, e, i, r, s, n, a) {
        ai.set(s, n, a).unproject(r);
        let o = e[t];
        if (void 0 !== o) {
          let t = i.getAttribute("position");
          for (let e = 0, i = o.length; e < i; e++)
            t.setXYZ(o[e], ai.x, ai.y, ai.z);
        }
      }
      let as = new Box3();
      let BoxHelper = class BoxHelper extends LineSegments {
        constructor(t, e = 16776960) {
          let i = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            r = new Float32Array(24),
            s = new BufferGeometry();
          s.setIndex(new BufferAttribute(i, 1)),
            s.setAttribute("position", new BufferAttribute(r, 3)),
            super(s, new LineBasicMaterial({ color: e, toneMapped: !1 })),
            (this.object = t),
            (this.type = "BoxHelper"),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        update(t) {
          if (
            (void 0 !== t &&
              console.warn(
                "THREE.BoxHelper: .update() has no longer arguments."
              ),
            void 0 !== this.object && as.setFromObject(this.object),
            as.isEmpty())
          )
            return;
          let e = as.min,
            i = as.max,
            r = this.geometry.attributes.position,
            s = r.array;
          (s[0] = i.x),
            (s[1] = i.y),
            (s[2] = i.z),
            (s[3] = e.x),
            (s[4] = i.y),
            (s[5] = i.z),
            (s[6] = e.x),
            (s[7] = e.y),
            (s[8] = i.z),
            (s[9] = i.x),
            (s[10] = e.y),
            (s[11] = i.z),
            (s[12] = i.x),
            (s[13] = i.y),
            (s[14] = e.z),
            (s[15] = e.x),
            (s[16] = i.y),
            (s[17] = e.z),
            (s[18] = e.x),
            (s[19] = e.y),
            (s[20] = e.z),
            (s[21] = i.x),
            (s[22] = e.y),
            (s[23] = e.z),
            (r.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
        setFromObject(t) {
          return (this.object = t), this.update(), this;
        }
        copy(t, e) {
          return super.copy(t, e), (this.object = t.object), this;
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      };
      let Box3Helper = class Box3Helper extends LineSegments {
        constructor(t, e = 16776960) {
          let i = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            r = new BufferGeometry();
          r.setIndex(new BufferAttribute(i, 1)),
            r.setAttribute(
              "position",
              new Float32BufferAttribute(
                [
                  1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                  -1, -1, -1, 1, -1, -1,
                ],
                3
              )
            ),
            super(r, new LineBasicMaterial({ color: e, toneMapped: !1 })),
            (this.box = t),
            (this.type = "Box3Helper"),
            this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(t) {
          let e = this.box;
          e.isEmpty() ||
            (e.getCenter(this.position),
            e.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            super.updateMatrixWorld(t));
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      };
      let PlaneHelper = class PlaneHelper extends Line {
        constructor(t, e = 1, i = 16776960) {
          let r = new BufferGeometry();
          r.setAttribute(
            "position",
            new Float32BufferAttribute(
              [
                1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1,
                -1, 0, 1, 1, 0,
              ],
              3
            )
          ),
            r.computeBoundingSphere(),
            super(r, new LineBasicMaterial({ color: i, toneMapped: !1 })),
            (this.type = "PlaneHelper"),
            (this.plane = t),
            (this.size = e);
          let s = new BufferGeometry();
          s.setAttribute(
            "position",
            new Float32BufferAttribute(
              [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
              3
            )
          ),
            s.computeBoundingSphere(),
            this.add(
              new Mesh(
                s,
                new MeshBasicMaterial({
                  color: i,
                  opacity: 0.2,
                  transparent: !0,
                  depthWrite: !1,
                  toneMapped: !1,
                })
              )
            );
        }
        updateMatrixWorld(t) {
          this.position.set(0, 0, 0),
            this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
            this.lookAt(this.plane.normal),
            this.translateZ(-this.plane.constant),
            super.updateMatrixWorld(t);
        }
        dispose() {
          this.geometry.dispose(),
            this.material.dispose(),
            this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }
      };
      let an = new Vector3();
      let ArrowHelper = class ArrowHelper extends Object3D {
        constructor(
          t = new Vector3(0, 0, 1),
          e = new Vector3(0, 0, 0),
          i = 1,
          r = 16776960,
          s = 0.2 * i,
          n = 0.2 * s
        ) {
          super(),
            (this.type = "ArrowHelper"),
            void 0 === a &&
              ((a = new BufferGeometry()).setAttribute(
                "position",
                new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)
              ),
              (o = new CylinderGeometry(0, 0.5, 1, 5, 1)).translate(
                0,
                -0.5,
                0
              )),
            this.position.copy(e),
            (this.line = new Line(
              a,
              new LineBasicMaterial({ color: r, toneMapped: !1 })
            )),
            (this.line.matrixAutoUpdate = !1),
            this.add(this.line),
            (this.cone = new Mesh(
              o,
              new MeshBasicMaterial({ color: r, toneMapped: !1 })
            )),
            (this.cone.matrixAutoUpdate = !1),
            this.add(this.cone),
            this.setDirection(t),
            this.setLength(i, s, n);
        }
        setDirection(t) {
          if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
          else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
          else {
            an.set(t.z, 0, -t.x).normalize();
            let e = Math.acos(t.y);
            this.quaternion.setFromAxisAngle(an, e);
          }
        }
        setLength(t, e = 0.2 * t, i = 0.2 * e) {
          this.line.scale.set(1, Math.max(1e-4, t - e), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(i, e, i),
            (this.cone.position.y = t),
            this.cone.updateMatrix();
        }
        setColor(t) {
          this.line.material.color.set(t), this.cone.material.color.set(t);
        }
        copy(t) {
          return (
            super.copy(t, !1),
            this.line.copy(t.line),
            this.cone.copy(t.cone),
            this
          );
        }
        dispose() {
          this.line.geometry.dispose(),
            this.line.material.dispose(),
            this.cone.geometry.dispose(),
            this.cone.material.dispose();
        }
      };
      let AxesHelper = class AxesHelper extends LineSegments {
        constructor(t = 1) {
          let e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            i = new BufferGeometry();
          i.setAttribute("position", new Float32BufferAttribute(e, 3)),
            i.setAttribute(
              "color",
              new Float32BufferAttribute(
                [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                3
              )
            );
          let r = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
          super(i, r), (this.type = "AxesHelper");
        }
        setColors(t, e, i) {
          let r = new Color(),
            s = this.geometry.attributes.color.array;
          return (
            r.set(t),
            r.toArray(s, 0),
            r.toArray(s, 3),
            r.set(e),
            r.toArray(s, 6),
            r.toArray(s, 9),
            r.set(i),
            r.toArray(s, 12),
            r.toArray(s, 15),
            (this.geometry.attributes.color.needsUpdate = !0),
            this
          );
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      };
      let ShapePath = class ShapePath {
        constructor() {
          (this.type = "ShapePath"),
            (this.color = new Color()),
            (this.subPaths = []),
            (this.currentPath = null);
        }
        moveTo(t, e) {
          return (
            (this.currentPath = new Path()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e),
            this
          );
        }
        lineTo(t, e) {
          return this.currentPath.lineTo(t, e), this;
        }
        quadraticCurveTo(t, e, i, r) {
          return this.currentPath.quadraticCurveTo(t, e, i, r), this;
        }
        bezierCurveTo(t, e, i, r, s, n) {
          return this.currentPath.bezierCurveTo(t, e, i, r, s, n), this;
        }
        splineThru(t) {
          return this.currentPath.splineThru(t), this;
        }
        toShapes(t) {
          let e, i, r, s, n;
          let a = ShapeUtils.isClockWise,
            o = this.subPaths;
          if (0 === o.length) return [];
          let h = [];
          if (1 === o.length)
            return (
              (i = o[0]), ((r = new Shape()).curves = i.curves), h.push(r), h
            );
          let l = !a(o[0].getPoints());
          l = t ? !l : l;
          let u = [],
            c = [],
            d = [],
            p = 0;
          (c[0] = void 0), (d[p] = []);
          for (let r = 0, n = o.length; r < n; r++)
            (e = a((s = (i = o[r]).getPoints()))),
              (e = t ? !e : e)
                ? (!l && c[p] && p++,
                  (c[p] = { s: new Shape(), p: s }),
                  (c[p].s.curves = i.curves),
                  l && p++,
                  (d[p] = []))
                : d[p].push({ h: i, p: s[0] });
          if (!c[0])
            return (function (t) {
              let e = [];
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i],
                  s = new Shape();
                (s.curves = r.curves), e.push(s);
              }
              return e;
            })(o);
          if (c.length > 1) {
            let t = !1,
              e = 0;
            for (let t = 0, e = c.length; t < e; t++) u[t] = [];
            for (let i = 0, r = c.length; i < r; i++) {
              let r = d[i];
              for (let s = 0; s < r.length; s++) {
                let n = r[s],
                  a = !0;
                for (let r = 0; r < c.length; r++)
                  (function (t, e) {
                    let i = e.length,
                      r = !1;
                    for (let s = i - 1, n = 0; n < i; s = n++) {
                      let i = e[s],
                        a = e[n],
                        o = a.x - i.x,
                        h = a.y - i.y;
                      if (Math.abs(h) > Number.EPSILON) {
                        if (
                          (h < 0 &&
                            ((i = e[n]), (o = -o), (a = e[s]), (h = -h)),
                          t.y < i.y || t.y > a.y)
                        )
                          continue;
                        if (t.y === i.y) {
                          if (t.x === i.x) return !0;
                        } else {
                          let e = h * (t.x - i.x) - o * (t.y - i.y);
                          if (0 === e) return !0;
                          if (e < 0) continue;
                          r = !r;
                        }
                      } else {
                        if (t.y !== i.y) continue;
                        if (
                          (a.x <= t.x && t.x <= i.x) ||
                          (i.x <= t.x && t.x <= a.x)
                        )
                          return !0;
                      }
                    }
                    return r;
                  })(n.p, c[r].p) &&
                    (i !== r && e++, a ? ((a = !1), u[r].push(n)) : (t = !0));
                a && u[i].push(n);
              }
            }
            e > 0 && !1 === t && (d = u);
          }
          for (let t = 0, e = c.length; t < e; t++) {
            (r = c[t].s), h.push(r), (n = d[t]);
            for (let t = 0, e = n.length; t < e; t++) r.holes.push(n[t].h);
          }
          return h;
        }
      };
      let Controls = class Controls extends EventDispatcher {
        constructor(t, e = null) {
          super(),
            (this.object = t),
            (this.domElement = e),
            (this.enabled = !0),
            (this.state = -1),
            (this.keys = {}),
            (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
            (this.touches = { ONE: null, TWO: null });
        }
        connect() {}
        disconnect() {}
        dispose() {}
        update() {}
      };
      function getByteLength(t, e, i, r) {
        let s = (function (t) {
          switch (t) {
            case tR:
            case tE:
              return { byteLength: 1, components: 1 };
            case tF:
            case tO:
            case tG:
              return { byteLength: 2, components: 1 };
            case tj:
            case tW:
              return { byteLength: 2, components: 4 };
            case tD:
            case tN:
            case tU:
              return { byteLength: 4, components: 1 };
            case tq:
              return { byteLength: 4, components: 3 };
          }
          throw Error(`Unknown texture type ${t}.`);
        })(r);
        switch (i) {
          case tJ:
          case tY:
            return t * e;
          case tQ:
            return t * e * 2;
          case t0:
          case t1:
            return ((t * e) / s.components) * s.byteLength;
          case t3:
          case t2:
            return ((t * e * 2) / s.components) * s.byteLength;
          case tZ:
            return ((t * e * 3) / s.components) * s.byteLength;
          case tX:
          case t5:
            return ((t * e * 4) / s.components) * s.byteLength;
          case t6:
          case t7:
            return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
          case t8:
          case t9:
            return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case ee:
          case er:
            return (Math.max(t, 16) * Math.max(e, 8)) / 4;
          case et:
          case ei:
            return (Math.max(t, 8) * Math.max(e, 8)) / 2;
          case es:
          case en:
            return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
          case ea:
          case eo:
            return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case eh:
            return Math.floor((t + 4) / 5) * Math.floor((e + 3) / 4) * 16;
          case el:
            return Math.floor((t + 4) / 5) * Math.floor((e + 4) / 5) * 16;
          case eu:
            return Math.floor((t + 5) / 6) * Math.floor((e + 4) / 5) * 16;
          case ec:
            return Math.floor((t + 5) / 6) * Math.floor((e + 5) / 6) * 16;
          case ed:
            return Math.floor((t + 7) / 8) * Math.floor((e + 4) / 5) * 16;
          case ep:
            return Math.floor((t + 7) / 8) * Math.floor((e + 5) / 6) * 16;
          case em:
            return Math.floor((t + 7) / 8) * Math.floor((e + 7) / 8) * 16;
          case ef:
            return Math.floor((t + 9) / 10) * Math.floor((e + 4) / 5) * 16;
          case ey:
            return Math.floor((t + 9) / 10) * Math.floor((e + 5) / 6) * 16;
          case eg:
            return Math.floor((t + 9) / 10) * Math.floor((e + 7) / 8) * 16;
          case ex:
            return Math.floor((t + 9) / 10) * Math.floor((e + 9) / 10) * 16;
          case eb:
            return Math.floor((t + 11) / 12) * Math.floor((e + 9) / 10) * 16;
          case ev:
            return Math.floor((t + 11) / 12) * Math.floor((e + 11) / 12) * 16;
          case eM:
          case ew:
          case eS:
            return Math.ceil(t / 4) * Math.ceil(e / 4) * 16;
          case eA:
          case e_:
            return Math.ceil(t / 4) * Math.ceil(e / 4) * 8;
          case eT:
          case eC:
            return Math.ceil(t / 4) * Math.ceil(e / 4) * 16;
        }
        throw Error(`Unable to determine texture byte length for ${i} format.`);
      }
      let aa = {
        contain: function (t, e) {
          let i = t.image && t.image.width ? t.image.width / t.image.height : 1;
          return (
            i > e
              ? ((t.repeat.x = 1),
                (t.repeat.y = i / e),
                (t.offset.x = 0),
                (t.offset.y = (1 - t.repeat.y) / 2))
              : ((t.repeat.x = e / i),
                (t.repeat.y = 1),
                (t.offset.x = (1 - t.repeat.x) / 2),
                (t.offset.y = 0)),
            t
          );
        },
        cover: function (t, e) {
          let i = t.image && t.image.width ? t.image.width / t.image.height : 1;
          return (
            i > e
              ? ((t.repeat.x = e / i),
                (t.repeat.y = 1),
                (t.offset.x = (1 - t.repeat.x) / 2),
                (t.offset.y = 0))
              : ((t.repeat.x = 1),
                (t.repeat.y = i / e),
                (t.offset.x = 0),
                (t.offset.y = (1 - t.repeat.y) / 2)),
            t
          );
        },
        fill: function (t) {
          return (
            (t.repeat.x = 1),
            (t.repeat.y = 1),
            (t.offset.x = 0),
            (t.offset.y = 0),
            t
          );
        },
        getByteLength,
      };
      let WebGLMultipleRenderTargets = class WebGLMultipleRenderTargets extends WebGLRenderTarget {
        constructor(t = 1, e = 1, i = 1, r = {}) {
          console.warn(
            'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
          ),
            super(t, e, { ...r, count: i }),
            (this.isWebGLMultipleRenderTargets = !0);
        }
        get texture() {
          return this.textures;
        }
      };
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: h } })
        ),
        "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = h));
    },
  },
]);
